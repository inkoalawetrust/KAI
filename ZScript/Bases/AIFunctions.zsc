//$GZDB_SKIP
//AI functions shared by all NPC types.
Extend Class KAI_Actor
{
	//=====|Range checks|=====\\
	Enum KAIRangeCheck
	{
		CMR_NOHITFRIEND	= 1 << 0, //The function should not run the native shit autoaimed P_HitFriend() check. Only useful for KAI_CheckMissileRange.
		CMR_3DDISTANCE	= 1 << 1, //The range check should use Distance3D instead of Distance2D.
		CMR_INVERTDIST	= 1 << 2, //Invert the missile attack chance with distance. Making the NPC MORE likely to attack the further the target is.
		CMR_IGNOREDIST	= 1 << 3, //Ignore the distance check attack chance code for missile attacks entirely.
	}
	
	//Returns true if the caller is in melee range of the other actor. Basically a rip of P_CheckMeleeRange().
	Bool KAI_CheckMeleeRange (Actor Other, Double Range = -1, Int Flags = 0)
	{
		Double Dist;
		
		If (!Target || CurSector.Flags & Sector.SECF_NOATTACK)
			Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other));
		If (Range < 0) Range = MeleeRange;
		
		If (Dist >= Range + Target.Radius)
			Return False;
		
		If (Target == Goal)
			Return True;
		
		If (!bNoVerticalMeleeRange)
		{
			If (Target.Pos.Z > Pos.Z+Height) Return False;
			If (Pos.Z+Height < Target.Pos.Z) Return False;
		}
		
		If (IsFriend (Other))
			Return False;
		
		If (!CheckSight (Target))
			Return False;
		
		Return True;
	}
	
	//The function is more or less the same as its' native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	Bool KAI_CheckMissileRange (Actor Other, Int Flags = 0)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!Other || !CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		If (!(Flags & CMR_NOHITFRIEND) && bFriendly && HitFriend ()) Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other)) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (Flags & CMR_IGNOREDIST) //Skip stupid distance formula.
			Return True;
		
		Dist *= MissileChanceMult; //If CMF_INVERTDIST is on, keep in mind that the behavior of the MissileChanceMult is also effectively inverted !
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		If (!(Flags & CMR_INVERTDIST))
			Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
		Else
			Return Random2[PR_CheckMissileRange]() <= Max(Int(Dist), MMC);
	}
	
	//=====|Sight and locomotion|=====\\
	Enum KAILookFlags
	{
		KAIL_CHASETARGET = 1 << 0, //If the actor already has a target. Then go to the specified see state. For when the internal A_LookEx() doesn't do it itself.
		KAIL_NOTEMPSTAND = 1 << 1, //Should the actor not temporarily stay still if friendly (Not begin moving due to player fire) between A_LookEx() calls ?
	}
	
	//Generic wrapper for A_LookEx shared by all actors.
	//Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label: These properties are all directly transferred to A_LookEx, so  they work the same as in that function.
	//ExtraFlags: The extra flags that modify KAI_Look's behavior. Look above for available flags.
	Void KAI_Look (Int Flags = 0, Double MinSeeDist = 0, Double MaxSeeDist = 0, Double MaxHearDist = 0, Double FOV = 0, StateLabel Label = Null, Int ExtraFlags = 0)
	{
		//HACK: This shit is probably a super hacky way to just get actors that are already targeting an actor in their Spawn state to actually attack it.
		If (!(Flags & LOF_NOJUMP) && ExtraFlags & KAIL_CHASETARGET && Target)
		{
			If (Label)
				SetStateLabel (Label); //Go to specified state.
			Else
				SetState (SeeState); //Go to default See state.
		}
		Bool Stand = bStandStill;
		If (!(ExtraFlags & KAIL_NOTEMPSTAND))
		{
			Stand = bStandStill;
			bStandStill = True;
		}
		A_LookEx (Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label);
		If (!(ExtraFlags & KAIL_NOTEMPSTAND)) bStandStill = Stand;
	}
	
	Enum KAIMoveTowardsFlags
	{
		KMT_CHASEGOAL 	= 1 << 0, //If the caller has a goal pointer, and the bChaseGoal flag on. It will follow the goal instead of the TargetPos.
		KMT_ZIGZAG	  	= 1 << 1, //Move around with more A_Chase-esque movement (Like zigzagging), instead of only moving in a straight line.
		KMT_NOLINEUSE 	= 1 << 2, //Disable the function being able to make the monster use crossed over lines at all, in case you want your own code for that.
		KMT_3D		  	= 1 << 3, //The actor should be able to move in full 3D, such as if it's a flying NPC.
	}
	
	Double LastTurnDir;
	Int TurnCount; //Keeps track of how many turns in a row an actor calling KAI_MoveTowards with CHF_NORANDOMTURN should make.
	Vector3 ZigZagPos;
	
	//Makes the actor move towards the specified position.
	//TODO: Add a check for if a vehicles' turret would collide with the next move. And probably find a way to call it recursively for turrets on turrets.
	//CREDIT: Written by Custodian. Modified and expanded by me (inkoalawetrust).
	//TargetPos: The position to move to.
	//DetourFactor: How long the actor is allowed to move in a direction after hitting an obstacle, before heading straight for the target again.
	//AngleLimit: How much the actor can turn per step. Used to not have it snap back 180 or anything like that.
	//ChaseFlags: What flags from A_Chase should the function use ? Supports CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	//Flags: The functions' own flags, see above for a list of flags.
	//PitchLimit: How much the actors' pitch can change per call. Used by KMT_3D to limit how much the actor moves up and down, effectively.
	Void KAI_MoveTowards (Vector3 TargetPos, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		If (ChaseFlags & CHF_DONTMOVE || KAI_Math.IsEmptyVector3 (TargetPos)) Return;
		
		//Basically does what P_NewChaseDir() does to handle Thing_SetGoal's "Don't chase target" flag: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L943-946
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
			TargetPos = Goal.Pos;
		
		//Handle making the NPC zig zag in a manner similar to KAI_MoveAway.
		If (Flags & KMT_ZIGZAG)
		{
			If (NewPosStepCount <= 64 && Level.Vec3Diff (Pos,ZigZagPos).Length() >= MeleeRange)
			{
				If (!KAI_Math.IsEmptyVector3 (ZigZagPos))
					TargetPos = ZigZagPos;
				NewPosStepCount++;
			}
			Else
			{
				ZigZagPos = FindRandomMovePos (TargetPos,16,256,FRMP_CLOSEST,(Flags & KMT_3D));
				NewPosStepCount = 0;
			}
		}
		Else
			ZigZagPos = (Double.NaN,Double.NaN,Double.NaN);
		
		//The function works with the CANTLEAVEFLOORPIC flag as well.
		TextureID OldFloor = FloorPic;
		
		double LastAngle = Angle;
		double NextAngle = LastAngle;
		Bool IsVehicle = (Self Is "KAI_BaseVehicle");
		Bool TurretBlock; //Is this movement blocked because one of the turrets' would collide with something?
		
		//MoveCount is greater than 0 when avoiding an obstacle
		if (MoveCount)
		{
			MoveCount--;
		}
		else
		{
			lastturndir = 0;
			//move directly towards Other
			if (!(ChaseFlags & CHF_NORANDOMTURN)) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		}
		
		//When CHF_NORANDOMTURN is on. The actor can take a set amount of turns before no longer turning to face its' target.
		If (ChaseFlags & CHF_NORANDOMTURN && --TurnCount > 0) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		
		Double NextPitch = Pitch; //Used by 3D movement.
		
		//Normal 2D TryMove() movement.
		If (!(Flags & KMT_3D))
		{
			//absolute position of next movement
			vector2 NextPos = Vec2Angle(speed, NextAngle, True);
			FCheckPosition Move;
			Move.FromPMove = True; //Move anyways if there's an actor within your hitbox already.
			If (IsVehicle) //Vehicle push and crush handling.
			{
				Let Vehicle = KAI_BaseVehicle(Self);
				Array <Actor> Pushovers;
				KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
				KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
				//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
			}
			//if (turretblock) console.printf ("DING DING DING TURRET IN THE WAY!");
			//else if (isvehicle) console.printf ("the turrets of %p aren't getting on their way",self);
			//If (!(Flags & KMT_NOLINEUSE)) {a_log ("lemme try opening this door");CheckMonsterUseSpecials ();}
			bool moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			
			//if I hit an obstacle while avoiding another, try moving straight towards Other
			if (!moved && MoveCount || bCantLeaveFloorPic && FloorPic != OldFloor)
			{
				If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
				MoveCount = Int(random(16,32)*DetourFactor);
				NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				NextPos = Vec2Angle(speed, NextAngle, True);
				If (IsVehicle) //Vehicle push and crush handling.
				{
					Let Vehicle = KAI_BaseVehicle(Self);
					Array <Actor> Pushovers;
					KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
					KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
					//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
				}
				moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			}
			
			//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
			If (!moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
			{
				Switch (AngleLimit)
				{
					Case 20:
						TurnCount = Random (2,4);
						Break;
					Case 10:
						TurnCount = Random (3,6);
						Break;
					Case 5:
						TurnCount = Random (8,12);
						Break;
					Default:
						Break;
				}
			}
			
			//test movement angles until I find one that works, avoid that obstacle for MoveCount tics
			if (!moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
			{
				MoveCount = Int(random(16,32) * DetourFactor);
	 
				//try moving the same relative direction as last time
				if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
				
				//find viable movement direction
				for (double i = 1; i < 6; i++)
				{
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
					
					lastTurnDir *= -1.0;
					
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
				}
			}
		}
		//3D velocity based movement
		//TODO:
		//Oh fuck, I need a system to accelerate the NPC up to whatever max velocity. And make it counter any velocity the actor already has, to reach TargetPos.
		//Uh, maybe handle deceleration by slowing the NPC based on just how much its' velocity is making it face away from the target?
		//Account for the CantLeaveFloorPic stuff.
		//Probably still keep an FCheckPosition struct around as we'll still likely need to use CheckPosition().
		//Include the vehicle pushing and crushing code. And also make VehiclePushActors accept 3D coordinates instead, why did I make it a Vector2 when I planned this for months?
		//Use movecount = Int(random(16,32)*DetourFactor) and stuff for making the flying actor bounce off obstacles (With custom code I need to figure out).
		//On the above note, also include support for CHF_STOPIFBLOCKED.
		//Add an optional flag to either the function or KAI_Actor proper that when enabled, allows the use of a virtual override for 3D movement.
		//CREDIT: Boondorl and RaveYard for helping me get this fucking god forsaken math to mostly work.
		Else
		{
			NextPitch = GetPitchToPos(TargetPos,PitchLimit);
			Console.Printf ("nextpitch is %.2f,",nextpitch);
			Vel *= KMT_3D_DecelWrongVector (TargetPos); //Decelerate from wrong velocities, like when an explosion blasts the actor off-course.
			F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,Speed); //Generate velocity that reaches the target over time (Or instantly).
			KMT_3D_SpeedLimit (Speed*3,F3DVel); //HACK: Magic number to make the total vel length cap ACTUALLY match the speed property.
			KAI_LOFRaycast.VisualizeTracePath (Pos,Level.Vec3Offset(Pos,Vel),128,1);
			console.printf ("velocity is %.2f %.2f %.2f, length %.2f",vel,vel.length());
		}
		
		//face movement direction
		If (!(ChaseFlags & CHF_NODIRECTIONTURN))
		{
			Angle = Normalize180(NextAngle);
			If (Flags & KMT_3D)
				Pitch = -NextPitch;
		}
	}
	
	//Handle slowing down the actor based on just how far its' current velocity is from the target position, i.e if it fully faces away, it grinds to a halt.
	//Used to make the actor decelerate and gets its' bearings again when  thrown of course by external forces like explosions.
	//TargetPos: The desired position which there would be 0 deceleration returned if we headed straight for it.
	Protected Double KMT_3D_DecelWrongVector (Vector3 TargetPos)
	{
		Vector3 TheVel = Vel;
		If (TheVel == (0,0,0)) //Can't dot a vector of 0.
			TheVel = (0.001,0.001,0.001);
		Double DistFromTarg = (TargetPos - Pos).Unit() Dot TheVel.Unit(); //Get how much the actor is currently facing away from the target position.
		
		//Map dot product between 0 (Not facing at all) and 1 (Facing the desired vector).
		DistFromTarg = KAI_Math.LinearMap (DistFromTarg,-1,1,0.5,1);
		console.printf ("actor facing away from target pos factor is %.2f",distfromtarg);
		Return DistFromTarg;
	}
	
	//Limit the max speed that the actor reaches over time. If the vel length is too high, extra vel is zeroed out as well until the length goes below SpeedLimit.
	Protected Void KMT_3D_SpeedLimit (Double SpeedLimit, Vector3 ExtraVel)
	{
		If (SpeedLimit == 0) //Wheeeeee
		{
			Vel += ExtraVel;
			Return;
		}
		Double Delta = Vel Dot ExtraVel;
		console.printf ("delta is %.2f",delta);
		Double Acceleration = 1;
		If (Delta < SpeedLimit) //Accelerate the actor, but never let them exceed the speed limit under their own motion.
			Vel += ExtraVel * Min (SpeedLimit - Delta,Acceleration);
	}
	
	//Makes the NPC wander around aimlessly.
	//Attempts: How many positions to try per next position picked.
	//MoveRad: The radius around which to find a viable position to move to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move to.
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_Wander (Int Attempts = 24, Double MoveRad = 256, Int MaxSteps = 72, Double DetourFactor = 0.5, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		Int Friend = KAI_GetFriendPlayer();
		If (!OnWander()) //Virtual callback
			Return;
		
		//Friendly monsters follow the player they work for by default.
		If (bFriendly && !bDontFollowPlayers && PlayerInGame[Friend] && Players[Friend].Mo)
		{
			KAI_MoveTowards (Players[Friend].Mo.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		NextMovePos = FindRandomMovePos (Pos,Attempts,MoveRad,FRMP_RANDOM); //Pick a random position to go to.
	}
	
	Enum MoveAwayFlags
	{
		KMA_STRAIGHT	= 1 << 0, //Move in a straight line away from the Other actor, like A_Chase, instead of using the furthest random position around you.
	}
	
	//Moves the caller AWAY from another actor.
	//Other: The actor to move away from.
	//Attempts: How many positions to try per next position picked.
	//RunRad: The radius around which to find a viable position to run away to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move away to.
	//KMAFlags: The flags unique to KAI_MoveAway.
	//TargPos: If this is set to a non-NaN value. This position vector will be used directly instead of the Other pointer.
	/*ExtraParams: This is a KAIMoveParams struct, KAI_MoveAway() only cares for the obstacle avoidance and corner checking parameters.
	And also the KAI_MoveTowards() PitchLimit. So that I don't need to shoehorn even more parameters in this damn function.*/
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_MoveAway (Actor Other, Int Attempts = 32, Double RunRad = 128, Int MaxSteps = 32, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0,
	Int KMAFlags = 0, Vector3 TargPos = (Double.NaN, Double.NaN, Double.NaN), KAIMoveParams ExtraParams = Null)
	{
		If (!Other && KAI_Math.IsEmptyVector3(TargPos)) {If (KAI_DebugPrintMessages)console.printf ("KAI_MoveAway(): Premptively stopping execution");Return;}
		
		//HACK: Thanks GZDoom :D!
		If (!ExtraParams)
		{
			KAIMoveParams Default_Params;
			/*Default_Params.CornerDist = 0;
			Default_Params.CornerDiv = 0;
			Default_Params.ObstacleDist = 0.0;
			Default_Params.ObstacleSlices = 0.0;*/
			Default_Params.PitchLimit = 40;
			KAI_MoveAway (Other, Attempts, RunRad, MaxSteps, DetourFactor, AngleLimit, ChaseFlags, Flags, KMAFlags, TargPos, Default_Params);
			Return;
		}
		
		Vector3 RunPos = Other ? Other.Pos : TargPos;
		
		//Got a goal to head to, no time to get spooked.
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
		{
			KAI_MoveTowards (Goal.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags, ExtraParams.PitchLimit);
			Return;
		}
		
		
		Vector3 ObstacleAvoidPos; Bool UseObstacleAvoidPos;
		[ObstacleAvoidPos, UseObstacleAvoidPos] = KAI_AvoidObstacles (ExtraParams.ObstacleDist, ExtraParams.ObstacleSlices, Speed);
		//Use the obstacle avoid pos if it's valid, and also not basically your current position, to prevent walking in place.
		If (UseObstacleAvoidPos && !KAI_Math.IsEmptyVector3(ObstacleAvoidPos) && Level.Vec3Diff (ObstacleAvoidPos,Pos).Length() >= MeleeRange)
		{if (kai_debugprintmessages)console.printf ("KAI_MoveAway(): Going to ObstacleAvoidPos %d %d %d",ObstacleAvoidPos);
			NextMovePos = ObstacleAvoidPos;
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{if (kai_debugprintmessages)console.printf ("KAI_MoveAway(): Walking to NextMovePos %d %d %d",nextmovepos);
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags,ExtraParams.PitchLimit);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{if (kai_debugprintmessages)console.printf ("movepos reached, nulling");
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		Actor SightTarget = Other;
		Bool DoCornerCheck = (ExtraParams.CornerDist > 0 && (ExtraParams.CornerDiv > 0 || ExtraParams.CornerDiv == -1));
		If (!SightTarget && DoCornerCheck) SightTarget = Spawn ("KAI_TempPoint",TargPos); //Spawn a debug point to check the sight of a TargPos instead for running from a coordinate.
		
		//TODO: Wait hold on, I think the current way that the dummy debug point for TargPos movement is set doesn't ever remove the debug points it spawns.
		//MAYDO: Add a boolean flag for ExtraParams that makes IsPosReachable() also qualify blocking actors as cover?
		//Try to run behind corners.
		If (DoCornerCheck && CheckSight(SightTarget,SF_IGNOREWATERBOUNDARY))
		{
			Vector3 RealPos = Pos;
			Double CheckLength = ExtraParams.CornerDist;
			
			//Check your left.
			Vector3 LeftPos;
			If (ExtraParams.CornerDiv == -1) //Use exact old behavior
			{
				LeftPos = Vec3Angle (CheckLength,Angle-90);
				SetOrigin (LeftPos,False);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool LeftSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, False);
				If (!LeftSight && IsPosReachable (LeftPos,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my left corner.");
					NextMovePos = LeftPos; //Move to the left.
					Return;
				}
			}
			Else
			{
				//Project a line of checks from the origin of the calling actor all the way out to the maximum length of CornerDist. Finding the closest corner.
				Double Division = (ExtraParams.CornerDist/ExtraParams.CornerDiv);
				/*Note: If I = 0 and I < ExtraParams.CornerDist. Then the first check is ran at the current NPC position instead of Division MU away,
				and the max distance away is skipped (i.e if the ckeck is set to check 394 MU on each side with a division of 12, it checks only 352MU away, AKA 384-32)*/
				For (Double I = Division; I < ExtraParams.CornerDist+Division; I += Division)
				{
					LeftPos = Vec3Angle (I,Angle-90);
					If (KAI_DebugPrintMessages) console.printf ("left corner check is %.2f MU away from actual pos",level.vec3diff (leftpos,pos).length());
					SetOrigin (LeftPos,False);
					//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
					Bool LeftSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
					SetOrigin (RealPos, False);
					If (!LeftSight && Level.Vec3Diff (Pos,LeftPos).Length() >= MeleeRange && IsPosReachable (LeftPos,spacing:Speed,ignoreactors:True))
					{
						If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my left corner.");
						NextMovePos = LeftPos; //Move to the left.
						Return;
					}
				}
			}
			
			//Check your right.
			Vector3 RightPos;
			If (ExtraParams.CornerDiv == -1) //Use exact old behavior
			{
				RightPos = Vec3Angle (CheckLength,Angle+90);
				SetOrigin (RightPos,False);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool RightSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, False);
				If (!RightSight && IsPosReachable (RightPos,spacing:Speed,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my right corner.");
					NextMovePos = RightPos; //Move to the right.
					Return;
				}
			}
			Else
			{
				//Project a line of checks from the origin of the calling actor all the way out to the maximum length of CornerDist. Finding the closest corner.
				Double Division = (ExtraParams.CornerDist/ExtraParams.CornerDiv);
				For (Double I = Division; I < ExtraParams.CornerDist+Division; I += Division)
				{
					RightPos = Vec3Angle (I,Angle+90);
					If (KAI_DebugPrintMessages) console.printf ("right corner check is %.2f MU away from actual pos",level.vec3diff (rightpos,pos).length());
					SetOrigin (RightPos,False);
					//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
					Bool RightSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
					SetOrigin (RealPos, False);
					If (!RightSight && Level.Vec3Diff (Pos,RightPos).Length() > MeleeRange && IsPosReachable (RightPos,spacing:Speed,ignoreactors:True))
					{
						If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my right corner.");
						NextMovePos = RightPos; //Move to the left.
						Return;
					}
				}
			}
		}
		
		If (!(KMAFlags & KMA_STRAIGHT))
			NextMovePos = FindRandomMovePos (RunPos,Attempts,RunRad,FRMP_FURTHEST); //Pick whichever position is the furthest from Runpos.
		Else
		{
			NextMovePos.XY = Vec2Angle (RunRad,GetAngleToPos(RunPos,0)-180);
			//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2),Level.Vec3Diff (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2)).Length());
			NextMovePos.Z = GetZAt (NextMovePos.X,NextMovePos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
		}
	}
	
	Vector3, Bool KAI_AvoidObstacles (Double CheckDist, Double CheckSlices, Double CheckSpacing)
	{
		If (CheckDist <= 0 || CheckSlices <= 0) Return (Double.NaN, Double.NaN, Double.NaN), False;
		Bool UseObstacleAvoidPos; //If on, the position passed in CheckPos will be used.
		Double CheckAngle = (GetAngleToPos(NextMovePos,0)); //Try at the NextMovePos, unless blocked.
		Vector3 CheckPos = (Vec2Angle (Radius+CheckDist,CheckAngle),0);
		CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
		//kai_lofraycast.visualizetracepath (pos.plusz(height/2),checkpos,level.vec3diff(pos.plusz(height/2),checkpos).length());
		//if (kai_debugprintmessages) console.printf ("KAI_AvoidObstacles: NextMovePos %d %d %d, CheckPos %d %d %d",nextmovepos,checkpos);
		//MAYDO: Make the code somehow ignore actors a vehicle can push away ? This would require reverting to using line traces.
		If (CheckDist > 0 && CheckSlices > 0)
		{
			//If (KAI_DebugPrintMessages) Console.Printf ("KAI_AvoidObstacles: Using basic obstacle avoiding algorithm with a distance of %.2f and %d slices",CheckDist,CheckSlices);
			//FLineTraceData PathCheck;
			//Check an arbitrary angles around the vehicle for a valid path. Ooga booga caveman pathfinding.
			For (Int I = 0; I < CheckSlices; I++)
			{
				If (IsPosReachable (CheckPos,spacing:CheckSpacing))
					Break;
				If (KAI_DebugPrintMessages) Console.Printf ("%d %d %d isn't reachable, adjusting movepos",checkpos);
				UseObstacleAvoidPos = True;
				CheckAngle += 360/CheckSlices; //There's an obstacle in front of this path, try another angle.
				CheckPos.XY = (Vec2Angle (Radius+CheckDist,CheckAngle));
				CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			If (UseObstacleAvoidPos)
			{
				//Subtract the extra distance to check ahead off from the final move position.
				CheckPos.XY = Vec2Angle (CheckDist,CheckAngle);
				CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			Else
				CheckPos = (Double.NaN, Double.NaN, Double.NaN);
		}
		
		Return CheckPos, UseObstacleAvoidPos;
	}
	
	Enum FindMovePosFilters
	{
		FRMP_FURTHEST	= 1 << 0, //Pick the furthest of all available positions to move to. This is the default.
		FRMP_CLOSEST	= 1 << 1, //Pick the closest of all available positions to move to.
		FRMP_RANDOM		= 1 << 2, //Pick a random position out of all the viable ones found.
	}
	
	//Find a random position that the caller can actually move to.
	//RelativeTo: Which position should the distance checks be performed to ? Needed for the Furthest and Closest filters.
	//Attempts: How many random positions should be produced ? The more you add, the more heavy the function becomes. (Obviously)
	//CheckRad: What is the maximum radius around which random positions can be produced ?
	//Filter: What position are we looking for exactly ? Look above for a list of filters. These are NOT to be used as flags that stack !
	//Full3D: Generate fully 3D positions instead of alligning Z to the floor. For flying actors.
	Vector3 FindRandomMovePos (Vector3 RelativeTo = (Double.NaN, Double.NaN, Double.NaN), Int Attempts = 32, Double CheckRad = 128, Int Filter = FRMP_FURTHEST, bool Full3D = False)
	{
		If (Filter == 0) Filter = FRMP_FURTHEST;
		
		//HACK: ZScript can't use Vector3 arrays. Because the only thing more dysfunctional than my code is the ZScript VM itself.
		//Nothing better than triple the amount of needed array accesses to slow an already expensive function down even more.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Vector3 CurPos; //The position we are currently checking. Reconstructed from the above arrays.
		
		For (Int I = 0; I <= Attempts; I++)
		{
			CurPos = Vec3Offset (FRandom(CheckRad,-CheckRad),FRandom(CheckRad,-CheckRad),Full3D ? FRandom(CheckRad,-CheckRad) : 0);
			If (!Full3D) CurPos.Z = GetZAt (CurPos.X,CurPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			Xs.Push (CurPos.X); Ys.Push (CurPos.Y); Zs.Push (CurPos.Z); //Epic GZDoom fail.
		}
		
		Actor SightTarget = Spawn ("KAI_TempPoint",Pos);
		For (Int I = Attempts-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			SightTarget.SetXYZ (CurPos); //Move the target to the pos for the visibility check.
			//If it's out of bounds, not visible, or can't be walked to. We can't go there. So remove that potential position.
			If (!Level.IsPointInLevel (CurPos) || !CheckSight(SightTarget,SF_IGNOREVISIBILITY) || !IsPosReachable (CurPos))
			{//actor mo = spawn ("gibbedmarineextra",curpos); mo.bnogravity = true;//Epic fail 
				Xs.Delete (I); Ys.Delete(I); Zs.Delete(I);
			}//else {actor mo = spawn ("candlestick",curpos); mo.bnogravity = true;} //EPIC WIN !!!!!!!!!!!!
		}
		SightTarget.Destroy();
		
		//No valid positions found, return null.
		If (Xs.Size() == 0)
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Return a random position, this filter is checked first to at least make wandering NPCs a bit cheaper.
		If (Filter == FRMP_RANDOM)
		{
			Int RNGesus = Random (0,Xs.Size()-1);
			Return (Xs[RNGesus],Ys[RNGesus],Zs[RNGesus]);
		}
		//Return the furthest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_FURTHEST)
		{
			Double FurthestDistance;
			Vector3 FurthestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (FurthestDistance < CurrentDistance)
				{
					FurthestDistance = CurrentDistance;
					FurthestPos = CurPos;
				}
			}
			Return FurthestPos;
		}
		//Return the closest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_CLOSEST)
		{
			Double NearestDistance = INT.MAX;
			Vector3 NearestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestPos = CurPos;
				}
			}
			Return NearestPos;
		}
		
		Return (Double.NaN, Double.NaN, Double.NaN); //Return null position if all the above failed.
	}
	
	//BUG: For some reason the function will sometimes return positions that are behind drops too tall for the caller as valid. I have no fucking idea why.
	//BUG: It's not portal aware, because of course it isn't ! DESPITE LITERALLY CHECKING BY *ACTUALLY* MOVING THE CALLER IN A STRAIGHT LINE !
	//BUG: God, why is a function that literally walks the caller forward so fucking hard.
	//NOTE: A potential fix might be making Vec3Offset absolute, it should at least fix portals, since it fixed movement through them for KAI_MoveTowards.
	//Checks if the straight line between the callers' position and the specified position can be walked up to.
	//TargetPos: The position to check if it's walkable.
	/*DistCutoff: The amount of map units to trim off the distance between the callers' pos and TargetPos. Useful for subtracting the radius of another actor,
	so that if you are checking if a position to another actor can be reached, the check doesn't return false because the actor itself is in the way !*/
	//Spacing: The spacing of the move checks. Default is 0, which means that the spacing is the diameter of the callers' hitbox.
	//IgnoreActors: Makes' the check ignore blocking actors entirely.
	//Dropoff: The Dropoff value passed to TryMove().
	Bool IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False, Int Dropoff = 1)
	{
		Vector3 OldPos = Pos;
		Bool Interp = bDontInterpolate;
		Bool ThruActs = bThruActors;
		Vector2 Path = Level.Vec2Diff( Pos.XY, TargetPos.XY );
		Double Distance = (Path.Length()-DistCutoff);
		If (Spacing == 0)
			Spacing = Radius*2;
		Distance += Spacing; //HACK: According to RaveYard, apparently the last check in the row might be getting ignored, so this is a simple hack fix.
		If (Distance <= 1) Return False;
		Path /= Distance;
		
		bDontInterpolate = True; //No movement interpolation during the test.
		If (IgnoreActors) bThruActors = True;
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec2Diff (Pos.XY, OldPos.XY).Length() >= Distance) Break; //The check went further than the distance to the target position. Success
			//Run as many times as it takes between you and your destination.
			FCheckPosition Data;
			Data.FromPMove = True;
			If (TryMove (Level.Vec2Offset(OldPos.XY, Path*I), Dropoff, tm:Data))
			{
				//TODO: Get rid of this SetZ when moving in 3D? Honestly I might need to make totally custom code for flying movement. Using Vec3Diff and CheckPosition().
				SetZ (GetZAt (Pos.X,Pos.Y,flags:GZF_ABSOLUTEPOS)); //HACK: Update the actors' Z position. TryMove should do that internally, but it doesn't. GZDoom moment.
				//actor debug = spawn ("kai_debugpoint",(Level.Vec2Offset(OldPos.XY, Path*I),Pos.Z));
				//debug.scale *= 0.5;
			}
			//If one of them fails, then return false.
			Else
			{If (KAI_DebugPrintMessages)console.printf ("i can't walk to %d %d %d",targetpos);
				bDontInterpolate = Interp;
				bThruActors = ThruActs;
				SetOrigin (OldPos,False);
				Return False;
			}
		}
		bDontInterpolate = Interp;
		bThruActors = ThruActs;
		SetOrigin (OldPos,False);
		Return True; //No TryMove call returned false.
	}
	
	//Check how big the specified space is for the calling actor. Works by scaling up the actor to the desired size, and seeing if they are blocked by anything.
	//TargetRadius: The radius up to which the function checks if the actor is being blocked.
	//TargetHeight: Ditto, but for the height.
	//Iterations: How many steps is the caller scaled up from their real hitbox, to the hitbox being tested?
	//ActorBlock: Should the function be blocked by actors that would stop the callers' movement as well?
	//Returns after how many iterations it failed, if any, and at what radius and height it failed at.
	Int, Double, Double CheckSpaceSize (Double TargetRadius, Double TargetHeight, Int Iterations = 8, Bool ActorBlock = False)
	{
		Double RealRadius = Radius; Double RealHeight = Height;
		
		For (Int I = Iterations; I > 0; I--)
		{
			//Skip iterations smaller than the caller, they're expensive.
			If ((TargetRadius/I) <= RealRadius && (TargetHeight/I) <= RealHeight)
				Continue;
			A_SetSize (TargetRadius/I,TargetHeight/I);
			If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Checking if radius %f, height %f, iteration %d is valid",Radius,Height,I);
			Bool Thru = bThruActors;
			If (!ActorBlock) bThruActors = True;
			Bool Success = TestMobjLocation();
			bThruActors = Thru;
			
			If (!Success)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Epic fail");
				Double FailRadius = Radius; Double FailHeight = Height;
				A_SetSize (RealRadius,RealHeight);
				Return I, FailRadius, FailHeight;
			}
		}
		
		A_SetSize (RealRadius,RealHeight);
		Return -1, -1, -1; //Nothing is blocking us.
	}
	
	//=====|Order system|=====\\
	//Sets what order the NPC is currently following.
	//Order: The order to follow from the NPCOrders enum.
	//Increment: If true the NPC simply moves to the next order in the enum, and loops back around once reaching the end.
	//Commander: The actor, if any, ordering the NPC to change orders. If the order is set to ORDER_FOLLOW, they'll become the NPC' master, unless hostile.
	//IgnoreAllegiance: If true, the NPC will accept orders even from enemy actors, but still won't follow them if set to ORDER_FOLLOW.
	//FromACS: Marks this particular call as having being made by ACS_SetMarineOrder(), or just generally called by ACS. DO NOT USE UNLESS YOU ARE CALLING FROM ACS.
	Void SetNPCOrder (NPCOrders Order, Bool Increment = False, Actor Commander = Null, Bool IgnoreAllegiance = False, Bool FromACS = False)
	{
		If (bIgnoreOrders) Return;
		Bool EnemyCommand = IsActorHostile (Commander); //The order is being barked by an enemy.
		Bool LastOrder = CurrentOrder;
		If (Commander && EnemyCommand && !IgnoreAllegiance)
			Return;
		
		Int NewOrder = !Increment ? Order : 0;
		If (Increment)
		{
			NewOrder = CurrentOrder++;
			If (CurrentOrder >= ALLORDERS)
				CurrentOrder = 1;
		}
		If (!OnOrderChange(NewOrder, Increment, Commander, IgnoreAllegiance, FromACS)) //Run additional logic before changing orders.
			Return;
		
		If (Increment)
			CurrentOrder++;
		Else
			CurrentOrder = Order;
		
		If (CurrentOrder >= ALLORDERS) //If the NPCs' current order has reached the end of the list, loop back.
			CurrentOrder = 1;
		
		//If we are set to follow, and we have a commander that is friendly, follow them.
		If (CurrentOrder == ORDER_FOLLOW)
		{//If (KAI_DebugPrintMessages)console.printf ("Okay jolly green retard (%p), is your current order ORDER_FOLLOW ?",self);
			If (bFriendly && Commander == Players[KAI_GetFriendPlayer()].Mo) //If your commander is your friendplayer, remove your master pointer to follow friendplayer.
				Master = Null;
			
			If (Commander && !EnemyCommand && Commander != Players[KAI_GetFriendPlayer()].Mo) //Only set master pointer for non-player commanders.
			{If (KAI_DebugPrintMessages)console.printf ("set ORDER_FOLLOW and master for %p",self);
				Master = Commander;
				If (bFriendly)
					bDontFollowPlayers = True; //Friendly marine needs to follow an actor that isn't the friendplayer, so turn off player following.
			}
			Else If (!Master && !bFriendly && (!Commander || !EnemyCommand)) //We are set to follow but we don't have a (friendly) commander or existing master.
				{If (KAI_DebugPrintMessages)console.printf ("SETTING HOSTILE NPC %p TO ORDER_WANDER",self);CurrentOrder = ORDER_WANDER;}
		}
		
		If (CurrentOrder == ORDER_WANDER && bFriendly) //Friendly wandering NPCs don't follow the player.
			bDontFollowPlayers = True;
		
		//If we are set to follow and have no master or our master is our friend player.
		If (CurrentOrder == ORDER_FOLLOW && bFriendly)
		{
			If (!Master || Master == Players[KAI_GetFriendPlayer()].Mo)
				bDontFollowPlayers = False;
		}
		
		AfterOrderChange(LastOrder, Increment, Commander, IgnoreAllegiance, FromACS);
	}
	
	//This is for map script setups. Used to give orders to NPCS through ACS. For the ACS callback, the Commander is the activator.
	Static Void ACS_SetNPCOrder (Actor Activator, Int NPCTID, NPCOrders Order, Bool Increment, Bool IgnoreAllegiance = False)
	{
		Let NPCSearch = Level.CreateActorIterator (NPCTID,"KAI_Actor"); 
		
		KAI_Actor NPC;
		While ( (NPC = KAI_Actor(NPCSearch.Next())) )
		{
			If (!NPC || NPC.IsDead(NPC)) //Ignore nonexistent or dead NPCs.
				Continue;
			
			If (KAI_DebugPrintMessages)console.printf ("SetNPCOrder() was called from ACS, setting order %d for %p",order,NPC);
			NPC.SetNPCOrder (Order, Increment, Activator, IgnoreAllegiance, True);
		}
	}
	
	//=====|Search functions|=====\\
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= 0) Return Null;
		
		Array <Actor> NearbyEnemies;
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || Mobj.Health >= 10000 || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		Return GetClosestActor (NearbyEnemies,Self.Pos,Range);
	}
	
	//Find a height position (From the three FAF_ positions) at which the NPC can aim at the specified actor with a clear line of sight.
	//Useful for making NPCs aim at a different part of an actor when attacking.
	Int GetFAFAimPos (Actor Other, Vector3 Offset = (0,0,0))
	{
		If (!Other) Return FAF_MIDDLE; //No need to update anything.
		Vector3 OldPos = Other.Pos;
		Vector3 AimDir;
		Vector3 Start = Level.Vec3Offset (Pos,Offset);
		
		//Let's see if the middle of the other actor is hittable first.
		Let Check = New ("KAI_BasicSightCheck"); //Should be cheaper than CheckSight(), probably...
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height/2));
		AimDir = Vec3To (Other);
		Check.Shooter = Self;
		Check.SightTarget = Other;
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_MIDDLE;
		}
		
		//If we are this far that should mean the middle isn't visible, aim for the top.
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height));
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_TOP;
		}
		
		//If that too failed, aim for the bottom.
		Other.SetXYZ (Other.Pos);
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_BOTTOM;
		}
		
		//All else failed, aim to the middle again and return false;
		Return FAF_MIDDLE;
	}
	
	//Get the first NPC group you're in that has a leader in it, otherwise, fall back to returning whatever the first group in the array is.
	//IgnorePlayerLeaders: Ignore checking for the first player group leader and just return the first group.
	KAI_NPCGroup GetFirstPlayerNPCGroup (Bool IgnorePlayerLeaders = False)
	{
		If (!Groups.Size())
			Return Null;
		
		If (!IgnorePlayerLeaders)
		{
			ForEach (Group : Groups) //Focus on the first group you find whose leader is a player. AKA player groups take precedence.
			{
				If (Group && Group.Leader && Group.Leader.Player)
					Return Group;
			}
		}
		
		Return Groups[0]; //Fallback to just following the first group in the list.
	}
	
	//=====|Miscelleneous AI functions|=====\\
	//Makes the caller change their target to NewTarget, also passes which actor shared the target. Also does the needed status changes. Returns true if shared successfully.
	//Sharee: The actor sharing the target.
	//NewTarget: The potential target to have.
	//IgnoreAllegiance: If on, the target will be set even if the Sharee is hostile and/or the NewTarget is friendly.
	Bool KAI_ShareTarget (Actor Sharee, Actor NewTarget, Bool IgnoreAllegiance = False)
	{
		If (NewTarget != Null && !bDormant && !(IsPatrolling (Self) && bChaseGoal) && CanBeTargeted(Self,NewTarget))
		{
			If (!IgnoreAllegiance && (IsActorHostile(Sharee) || !IsActorHostile(NewTarget)))
				Return False;
			
			LastHeard = Target = NewTarget;
			Return True;
		}
		
		Return False;
	}
	
	//A crude replica of the clusterfuck that makes monsters natively able to use push and use lines.
	Bool KAI_NPCUseLines()
	{
		If (bNoTrigger || !BlockingLine) Return False;
       
        If (BlockingLine.Special)
        {
            If (bCanUseWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Use);
                Return True;
            }
            Else If (bCanPushWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Push);
                Return True;
            }
        }
        
        Return False;
	}
	
	Int KAI_GetFriendPlayer()
	{
		If (FriendPlayer != 0)
			Return FriendPlayer-1;
		Else
		{
			If (!Multiplayer)
				Return 0;
		}
		
		Return 0;
	}
	
	//Checks if the actor is in any of the attack states defined, and if it is, it also returns a pointer to that state.
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//ZScript port of this: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2568-2572
	Bool HandleNativeFright()
	{
		If (Target)
			Return (((!target.player || !((target.player.cheats & CF_FRIGHTENING) || (target.bFrightening))) && !(bFrightened)) || Random2[pr_scaredycat]() < 43);
		
		Return False;
	}
	
	//=====|A_Chase exports (Building blocks for custom chase functions)|=====\\
	//The checks A_Chase runs before it begins running the chase code.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2325-2376
	Void KAI_Chase_PreChecks (Int Flags = 0)
	{
		If (bInConversation || bInChase) Return;
		
		//bInChase = True;
		
		//PLAYTEST: I haven't checked if stealth monsters work with the exported A_Chase code.
		If (bStealth)
			VisDir -1;
		
		If (ReactionTime)
			ReactionTime--;
		
		//The latter half hasn't been implemented to mainline GZDoom yet, the bMInvisible flag that is.
		If (Target && (Target.bInvisible/* || Target.bMInvisible*/) && Target != Goal)
			Target = Null;
		
		If (Threshold)
		{
			If (!Target || IsDead (Target))
				Threshold = 0;
			Else
				Threshold--;
		}
		
		//Cocaine mode
		If (Flags && CHF_NIGHTMAREFAST && G_SkillPropertyInt (SKILLP_FASTMONSTERS))
		{
			If (Tics > 3)
			{
				Tics -= Tics/2;
				If (Tics < 3)
					Tics = 3;
			}
		}
		
		If (Target && Target != Goal && (IsDead(Target) || !IsActorHostile(Target)))
			Target = Null;
	}
	
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2401-2432
	//CREDIT: This section of the code was written by Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L74-L106
	//PLAYTEST: No idea if this actually works, or how to test it. It should, it's not only a direct rip, but it was written by someone who knows what they are actually doing (Not inkoalawetrust).
	//Makes friendly monsters using KAI chase functions chase their targets attack- basically just what A_Chase does.
	//It does return true if a new target was found though.
	Bool KAI_Chase_FriendsAttackPlayerEnemies (Int Flags)
	{
		// [RH] Friendly monsters will consider chasing whoever hurts a player if they
		// don't already have a target.
		if (bFRIENDLY && target == null)
		{
			PlayerInfo player;

			if (FriendPlayer != 0)
			{
				player = Players[FriendPlayer - 1];
			}
			else
			{
				int i;
				if (!multiplayer)
				{
					i = 0;
				}
				else for (i = random[newchasedirr](0,255) & (MAXPLAYERS-1); !PlayerInGame[i]; i = (i+1) & (MAXPLAYERS-1))
				{
				}

				player = Players[i];
			}
			if (player.attacker && !IsDead (Player.Attacker) && player.attacker.bSHOOTABLE && random[newchasedirr](0,255) < 80)
			{
				if (!player.attacker.bFRIENDLY ||
					deathmatch && FriendPlayer != 0 && player.attacker.FriendPlayer != 0 &&
					FriendPlayer != player.attacker.FriendPlayer)
				{
					target = player.attacker;
					Return True; //Found a player enemy to attack.
				}
			}
		}
		
		Return False;
	}
	
	//Makes the actor change targets if the current one is unavailable. If no target is found either hang out in the current state or go back to idling.
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2433-2467
	Bool KAI_Chase_Retarget (Int Flags, Bool FriendliesIdle = False)
	{
		If (!Target || !Target.bShootable)
		{
			If (Target && Target.bNonShootable)
			{
				LastEnemy = Target;
				Threshold = 0;
			}
			If (LookForPlayers (True) && Target != Goal)
				Return True;
			If (!Target)
			{
				If (Flags & CHF_DONTIDLE || bFriendly && !FriendliesIdle)
				{
					If (!Target)
					{
						If (!(Flags & CHF_DONTMOVE))
							KAI_Wander();
					}
				}
				Else
					SetIdle(); //Sleepy time
			}
		}
		Return False;
	}
	
	//This is an important one for every chase function of every NPC type. It handles going to patrol points and then heading to the next point in the route.
	//WaitState: The statelabel for the actor to go to if it finds a delayed patrol point. If none is specified, it calls SetState().
	//The rest of the parameters here are what is passed to KAI_MoveTowards
	//This function returns 2 booleans. The first returns true if the goal was changed to the next one in the route, and the second returns true if the actor moved to the goal.
	Bool, Bool KAI_Chase_PatrolHandling (StateLabel WaitState = Null, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (Target == Goal || bChaseGoal && Goal != Null)
		{
			If (KAI_CheckMeleeRange(Goal))
			{
				//Credit: Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L161-L212
				// reached the goal
				ActorIterator iterator = Level.CreateActorIterator(goal.args[0], "PatrolPoint");
				ActorIterator specit = Level.CreateActorIterator(goal.tid, "PatrolSpecial");
				Actor spec;

				// Execute the specials of any PatrolSpecials with the same TID
				// as the goal.
				while ( (spec = specit.Next()) )
				{
					level.ExecuteSpecial(
						spec.special, self, null, false,
						spec.args [0], spec.args [1], spec.args [2], spec.args [3], spec.args [4]
					);
				}

				double lastgoalang = goal.angle;
				int delay;
				actor newgoal = iterator.Next ();
				if (newgoal != null && goal == target)
				{
					delay = newgoal.args[1];
					reactiontime = delay * TICRATE + level.maptime;
				}
				else
				{
					delay = 0;
					reactiontime = Default.reactiontime;
					angle = lastgoalang;
				}
				if (target == goal) target = null;
				bJUSTATTACKED = true;
				if (newgoal != null && delay != 0)
				{
					bINCOMBAT = true;
					If (!WaitState)
						SetIdle();
					Else
						SetStateLabel (WaitState);
				}
				bINCHASE = false;
				goal = newgoal;
				return True, False;
			}
			//We have a goal, go to it.
			If (Goal && Goal == Target)
			{
				KAI_MoveTowards (Goal.Pos,DetourFactor,AngleLimit,ChaseFlags,Flags);
				Return False, True;
			}
		}
		Return False, False;
	}
	
	//Handles the playing of the active sound.
	Bool KAI_Chase_HandleActiveSound (Int Flags, Int Frequency = 3)
	{
		if (!(Flags & CHF_NOPLAYACTIVE) && random[pr_chase](0,255) < Frequency)
		{
			PlayActiveSound();
			Return True;
		}
		Return False;
	}
	
	//This handles Hexens' player boss strafing.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2537-2566
	//StrafeTarget: The actor to strafe relative to, normally this will be the target of course.
	//Flags: the A_Chase flags to pass and check for.
	//ForceStrafe: Force the caller to do a strafe.
	//StrafeRange: How close the StrafeTarget has to be to decide to strafe, default is CLASS_BOSS_STRAFE_RANGE.
	Void KAI_Chase_HandleStrafing (Actor StrafeTarget, Int Flags, Bool ForceStrafe = False, Double StrafeRange = 64*10)
	{
		If (!StrafeTarget) Return; //Nothing to dodge.
		
		If (ForceStrafe || Flags & CHF_FASTCHASE && !(Flags & CHF_DONTMOVE))
		{
			If (ForceStrafe) FastChaseStrafeCount = 0;
			If (FastChaseStrafeCount > 0)
				FastChaseStrafeCount--; //Decrement strafe delay.
			Else
			{
				FastChaseStrafeCount = 0;
				Vel.X = Vel.Y = 0;
				If ((ForceStrafe || Random[pr_chase](0,255) < 100) && Distance2D(StrafeTarget) < StrafeRange)
				{
					Double Ang = AngleTo (StrafeTarget);
					If (Random[pr_chase](0,255) < 128) Ang += 90;
					Else Ang -= 90;
					VelFromAngle (13,Ang);
					FastChaseStrafeCount = 3;
				}
			}
		}
	}
}

//This struct stores parameters passed to KAI_MoveTowards/Away. Used as a simple way to pass all params the functions support from another function that calls them.
//Without cluttering up the other function. i.e for passing additional more detailed parameters for a custom chase function like KAI_LandVehicleChase() does.
//Also used by KAI_MoveAway() to enable and pass custom parameters for the obstacle avoiding and running behind corners.
Struct KAIMoveParams
{
	//KAI_MoveTowards() parameters
	Vector3 TargetPos; //The position to actually move to.
	Double DetourFactor; //A multiplier for how many steps the caller can take around an obstacle before heading straight to the TargetPos again.
	Double AngleLimit; //How much the caller can turn to face their TargetPos per step.
	Double PitchLimit; //Ditto, but for the 3D movement of KMT_3D.
	Int ChaseFlags; //The A_Chase flags KAI_MoveTowards() supports, which are CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	Int Flags; //The functions' own flags, check the KAIMoveTowardsFlags enum for a list of them and what they do.
	
	//KAI_MoveAway() parameters, the function also supports KAI_MoveTowards() parameters, as it's effectivelly a wrapper for it.
	Actor Other; //The actor to run away from.
	Int Attempts; //How many potential points to run to should the function generate. The more you generate the more performance heavy it becomes !
	Double RunRad; //The radius around which additional points should be generated.
	Int MaxSteps; //How many steps trying to move to the current retreat position can the caller take before it picks a new location to run to.
	Int KMAFlags; //The functions' own flags, check the MoveAwayFlags enum for a list of them and what they do.
	
	//Additional parameters that need to be passed through this struct to KAI_MoveAway().
	Double CornerDist; //How far away on the left and right sides should the corner running code check around the caller? If this is 0 or less, this is disabled.
	Int CornerDiv;	//How many additional fractional checks should the corner running code do? i.e divinding a CornerDist of 100 by 10 to check every 10 MU.
					/*If this set to 0, the mechanic isn't used by the function at all, if set to -1, it only checks the end point that is CornerDist MU to the
					left or right of the caller. Which is how the check used to work when I had first coded it, for some fucking reason.*/
	Double ObstacleDist; //How far ahead should the actor check for obstacles to try moving around from? If set to 0 or less, no obstacle avoidance occurs.
	Int ObstacleSlices; //How many reachability checks should be done around a 360 degree circle? i.e setting this to 16 checks in increments of 22.5 degrees around.
}
