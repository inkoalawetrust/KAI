//Miscelleneous functions shared by all NPCs go here.
Extend Class KAI_Actor
{
	//=====|Status checks|=====\\
	//Checks if the specified position relative to the caller, with the specified radius and height. Is a valid position.
	Bool ValidPositionAt (Vector2 Offset = (0,0), Double TempRadius = 32, Double TempHeight = 56)
	{
		//Store the previous position and dimensions of the vehicle.
		Vector3 PrevPos = Pos;
		Double PrevRadius = Radius;
		Double PrevHeight = Height;
		
		A_SetSize (TempRadius,TempHeight);
		SetXYZ (Vec3OffsetRelative (Self,(Offset,Pos.Z),flags:V3R_ANGLEONLY));
		
		Bool Ok = CheckPosition (Pos.XY);
		
		A_SetSize (PrevRadius,PrevHeight);
		SetXYZ (PrevPos);
		
		Return Ok;
	}
	
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//Returns true if the specified actor can resurrect corpses like an Archvile does.
	Bool IsNecromancer (Actor Other)
	{
		If (!Other) Return False;
		
		If (Other.FindState ("Heal")) Return True; //I checked several mods with Archvile-type monsters. And all of them have a Heal state. Making this the only universal way to check for them.
		
		Return False;
	}
	
	//=====|Math-related functions|=====\\
	//CREDIT: Written by Lewisk3.
	//Mathemagically gets the nearest sprite angle (https://zdoom.org/wiki/Sprite#Angles) based on the actors' current angle.
	Double GetNearestCardinalAngle (Bool SixteenAngles = False)
	{
		Double NAngle = Normalize180(Angle) + 180;
		Double Parts = 360 / (SixteenAngles ? 16.0 : 8.0);
		Return (Round(NAngle / Parts) * Parts);
	}
	
	//Gets the angle to the other actor, and also has a limit that can be used to get the angle to the other actor up to a certain point.
	//Basically this is what A_Face()'s max_turn property does, sans the actual angle change on the caller.
	Double KAI_GetAngleTo (Actor Other, Double AngleLimit = 10)
	{
		If (!Other) Return 0;
		If (AngleLimit == 0) Return AngleTo (Other);
		Double AngleTo = AngleTo (Other);
		Double Delta = -DeltaAngle (Angle,AngleTo);
		
		If (AngleLimit != 0)
		{
			If (Delta > 0)
				Return Angle - AngleLimit;
			Else
				Return Angle + AngleLimit;
		}
		
		Return 0;
	}
	
	//Finds the closest actor in an array of actors.
	//ActorList: The array of actors to find the closest one from. Usually scrubbed from a blockmap iterator.
	//Pos: The position from which the distance check is performed on each actor.
	//MaxRange: If this is not 0, any actors in the list further than this distance are automatically eliminated.
	Actor GetClosestActor (Out Array <Actor> ActorList, Vector3 Pos, Double MaxRange = 0)
	{
		If (!ActorList) Return Null;
		Array <Actor> TempList;
		TempList.Move (ActorList);
		Double NearestDistance = INT.MAX;
		
		If (MaxRange > 0)
		{
			For (Int I = TempList.Size()-1; I >= 0; I--)
			{
				If (Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared() > MaxRange)
					TempList.Delete(I);
			}
		}
		
		Actor ClosestActor;
		For (Int I = TempList.Size()-1; I >= 0; I--)
		{
			Double CurrentDistance = Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared();
			If (NearestDistance > CurrentDistance)
			{
				NearestDistance = CurrentDistance;
				ClosestActor = TempList[I];
			}
		}
		
		Return ClosestActor;
	}
	
	//Finds the furthest actor from an array of actors.
	//ActorList: The array of actors to find the closest one from. Usually scrubbed from a blockmap iterator.
	//Pos: The position from which the distance check is performed on each actor.
	//MinDist: If this is not 0, any actors in the list closer than this distance are automatically eliminated.
	Actor GetFurthestActor (Out Array <Actor> ActorList, Vector3 Pos, Double MinDist = 0)
	{
		If (!ActorList) Return Null;
		Array <Actor> TempList;
		TempList.Move (ActorList);
		Double FurthestDistance;
		
		If (MinDist > 0)
		{
			For (Int I = TempList.Size()-1; I >= 0; I--)
			{
				If (Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared() < MinDist)
					TempList.Delete(I);
			}
		}
		
		Actor FurthestActor;
		For (Int I = TempList.Size()-1; I >= 0; I--)
		{
			Double CurrentDistance = Level.Vec3Diff(Pos,TempList[I].Pos).LengthSquared();
			If (FurthestDistance < CurrentDistance)
			{
				FurthestDistance = CurrentDistance;
				FurthestActor = TempList[I];
			}
		}
		
		Return FurthestActor;
	}
}