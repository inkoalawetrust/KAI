//TODO: Uh, I am JUST getting started with this new major feature, very unsure how ANYTHING should look like.
//- I guess KAI_Emplacement probably doesn't need to be based on KAI_Actor, it's basically an interactive prop.
//- Figure out the minor (Huge) design issue of how to map an NPC using an emplacement to the proper morph. And also the same problem but with player skins. Fun!!!!!
	//- Will probably need an associative map, at least for mapping NPC operators to the correct morphs. i.e KAI_HellKnight = HellKnightMorph, KAI_Imp = ImpMorph etc
//- Maybe add a basic player morph class? Or rather the handling for a purely visual pseudo-player that can move relative to the emplacement, for basic morph classes.

//The base emplacement class for the library. Emplacements can be used by both players and KAI_Humanoid NPCs by default.
Class KAI_Emplacement : Actor Abstract
{
	Default
	{
		Radius 16;
		Height 48;
		Mass 50;
		Obituary "%o managed to die from an interactive inanimate object";
		
		+FloorClip;
		+Solid;
		//+Shootable; //NOTE: If you want, it should also be perfectly possible to make an emplacement that can be destroyed! BUT, you'll have to do it yourself.
	}
	
	Mixin KAI_CheckFunctions;
	
	Private Int EmplacementFlags;
	FlagDef NoPlayerUse : EmplacementFlags, 0; //Emplacement can't be manned by players, NPC-only.
	FlagDef NoNPCUse : EmplacementFlags, 1; //Emplacement can't be manned by NPCs, player-only.
	
	//Variables and properties for handling actually morphing NPCs and players to the right classes.
	Map <String, Class <KAI_EmplacementNPC> > NPCMap; //The map used to assign NPCs that may use the emplacement, to what emplacement they should specifically turn into.
	Class <KAI_EmplacementNPC> NPCFallback; //The morph class to fall back if the NPC that's getting on the emplacement isn't in the NPCMap.
	Class <KAI_EmplacementPlayer> PlayerMorph; //The morph all players will turn to, for stuff like class specific morphs and skin-specific sprites, you have to handle it yourself.
	Property NPCFallback : NPCFallback;
	Property PlayerMorph : PlayerMorph;
	//Class <KAI_EmplacementPlayer> PlayerFallback; //Ditto, but for players using the- nevermind, this kind of thing should just be handled by modders I think.
	
	Actor Operator; //Who is currently using this emplacement? If null, this emplacement is not in use. Points to the unmorphed original actor.
	Actor OperatorMorph; //A pointer to the morph the Operator was turned into to use the emplacement.
	Vector3 EnterPos; //The position relative to the emplacement that the operator entered it from.
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		EnterPos = (Double.NaN, Double.NaN, Double.NaN);
	}
	
	Override Bool Used (Actor User)
	{
		Super.Used(User);
		
		If (User.bIsMonster && !(User Is "KAI_Humanoid") || User.bIsMonster && KAI_Humanoid(User).Emplacement) //Can only be used by KAI_Humanoid monsters specifically. Also can't enter if already in another emplacement.
			{console.printf ("fail 1");Return False;}
		
		If (!User || bDormant || IsDead(Self) || IsDead(User) || IsInanimateObject(User)) //Can't use dormant or destroyed emplacements. Also can't be used by inanimate objects.
			{console.printf ("fail 2");Return False;}
		
		EnterEmplacement (User); //Run conditions for when an actor can succesfully operate the emplacement.
		Return True;
	}
	
	//Handle the logic for an NPC or player "entering" an emplacement.
	Virtual Bool EnterEmplacement (Actor User)
	{
		If (Operator) //Fuck off we're full.
			Return False;
		
		If (bNoPlayerUse && User.Player || bNoNPCUse && User.bIsMonster) //Custom flag disqualifiers.
			Return False;
		
		If (User Is "KAI_Humanoid")
			KAI_Humanoid(User).Emplacement = Self; //Needs to be set before Morph() so the PostMorph() override in KAI_Humanoid can pass the operator pointers.
		
		Vector3 CachedPos = User.Pos; //I think the User pointer gets lost once the User morphs? Since User.Pos will create a null pointer VM abort.
		
		Bool Morbed = User.Morph (Self,PlayerMorph,GetNPCMorph(User.GetClassName()),INT.MAX/2,MRF_UNDOBYDEATH|MRF_LOSEACTUALWEAPON|MRF_FULLHEALTH|MRF_KEEPARMOR,Null,Null);
		If (Morbed) //We "entered" the emplacement (Morphed into it)
		{
			EnterPos = Level.Vec3Diff (Pos,CachedPos); //Get position of operator relative to emplacement, to warp them back there upon exiting.
			OperatorMorph.SetOrigin (Pos,True); //Put the operator on the turrets' pitch, angle, and position.
			OperatorMorph.Angle = Angle;
			OperatorMorph.Pitch = Pitch;
			OperatorMorph.A_SetHealth (Operator.Health);
			If (OperatorMorph Is "KAI_EmplacementNPC")
				KAI_EmplacementNPC(OperatorMorph).Emplacement = Self; //So doing "KAI_Humanoid(Alternative).Emplacement" when checking from the NPC morph isn't needed.
			//Else If (OperatorMorph Is "KAI_EmplacementPlayer")
			//	KAI_EmplacementPlayer(OperatorMorph).Emplacement = Self; 
			A_ChangeLinkFlags (True, True); //Become intangible.
			KAI_Humanoid(Operator).OnEmplacementEnter();
			console.printf ("%s entered %p",user.getclassname(),self);
			CONSOLE.PRINTF ("OPERATOR MORPH STARTS WITH %d HEALTH",OPERATORMORPH.HEALTH);
			Return True;
		}else {console.printf ("morbius flopped");}
		If (User Is "KAI_Humanoid")
			KAI_Humanoid(User).Emplacement = Null;
		Return False;
	}
	
	//Handle the logic for an NPC or player "leaving" an emplacement.
	Virtual Void ExitEmplacement ()
	{
		If (!Operator) Return; //There's nobody that needs to leave.
		Bool UnMorb = OperatorMorph.UnMorph (Self,0,True); //DoExitEmplacement() is handled on KAI_EmplacementNPC and KAI_EmplacementPlayer directly.
		//If (UnMorb)
			//DoExitEmplacement();
		Return;
	}
	
	//Runs the status changes to properly exit an emplacement. Like if the operator unmorphs on their own by the morph tics running out somehow, or them dying.
	Void DoExitEmplacement ()
	{
		//If (!Operator)
		//	Return;
		Operator.SetOrigin (KAI_Math.Vec3OffsetRelative(Self,EnterPos,flags:KAI_Math.V3R_ANGLEONLY),True); //Revert position to where the operator was before getting in.
		EnterPos = (Double.NaN, Double.NaN, Double.NaN);
		KAI_Humanoid(Operator).OnEmplacementExit();
		//Operator.A_SetHealth (OperatorMorph.Health); //HACK: Has to be handled in the emplacements' morphs' morph virtuals because of how the stock unmorph works.
		If (Operator.bIsMonster)
			KAI_Humanoid(Operator).Emplacement = Null;
		Operator = OperatorMorph = Null;
		A_ChangeLinkFlags (False, False);
	}
	
	//Add an explicitly supported NPC class, and the emplacement morph they turn to.
	Bool AddNPCMorph (String NPCClass, Class<KAI_EmplacementNPC> MorphClass)
	{
		If (NPCMap.CheckKey(NPCClass)) //Already have an NPC-Morph association.
		{
			Console.Printf ("\c[Yellow]KAI_Emplacement: NPC Class %s is already mapped to KAI_EmplacementNPC %s",NPCClass,MorphClass.GetClassName());
			Return False;
		}
		
		NPCMap.Insert (NPCClass, MorphClass);
		
		Return True;
	}
	
	//Find the morph class associated with that particular NPC, if any. Otherwise it returns the fallback NPC morph, if there's any.
	Class <KAI_EmplacementNPC> GetNPCMorph (String NPCClass)
	{
		Class <KAI_EmplacementNPC> Morph;
		Bool Found;
		[Morph, Found] = NPCMap.CheckValue (NPCClass);
		If (KAI_DebugPrintMessages && Found) Console.Printf ("KAI_Emplacement.GetNPCMorph(): Checking for NPC of class %s, actor is assigned to morph %s",NPCClass,Morph.GetClassName());
		If (Found)
			Return Morph;
		If (KAI_DebugPrintMessages) Console.Printf ("KAI_Emplacement.GetNPCMorph(): Couldn't find morph for NPC class, using NPCFallback class");
		Return NPCFallback;
	}
	
	//Create a fake operator visual effect to serve as a placeholder for NPC and player operators if you have no unique emplacement sprites.
	Actor CreateFakeOperator (Vector3 Position)
	{
		Let FakeOp = KAI_EmplacementFakeOperator(Spawn ("KAI_EmplacementFakeOperator",Level.Vec3Offset(Pos,Position)));
		
		If (FakeOp)
		{
			//FakeOp.Pos = Emplacement.Vec3Offset (-32,0,0);
			FakeOp.Offsets = Level.Vec3Diff (Pos, FakeOp.Pos);
			FakeOp.Operator = Operator;
			FakeOp.Emplacement = Self;
			//FakeOp.Texture = CurState.GetSpriteTexture (0); //Just get some placeholder graphic for now so the thinker will spawn.
		}
		
		Return FakeOp;
	}
}

Class KAI_EmplacementNPC : KAI_Actor Abstract
{
	Default //Pretty much every other property and flag is up to the modder.
	{
		+DontMorph; //Probably not a good idea to have nested morphs. Even the original Hexen animal morphs use this flag sooooo.
		-AvoidHazards;
	}
	Mixin KAI_CheckFunctions;
	Mixin HumanoidAndVehicleCode;
	KAI_Emplacement Emplacement; //The emplacement this morph is part of.
	Actor OperatorHack;
	
	//Handle the NPC exiting the emplacement.
	Override Void PreUnmorph (Actor Mo, Bool Current)
	{
		Super.PreUnmorph (Mo, Current);
		if (!emplacement) console.printf ("what the fuck do you mean the emplacement pointer is null?");
		If (Mo && Emplacement && Emplacement.Operator)
		{
			Console.Printf ("KAI_EMPLACEMENTNPC: RUNNING EMPLACEMENT EXITING CODE ON PREUNMORPH()");
			OperatorHack = Emplacement.Operator;
			Emplacement.DoExitEmplacement();
		}
	}
	
	Override Void PostUnmorph (Actor Mo, Bool Current)
	{
		Super.PostUnmorph (Mo, Current);
		
		If (OperatorHack)
		{
			OperatorHack.A_SetHealth(Health);
			console.printf ("OPERATOR HEALTH %d, MORPH HEALTH %d",operatorhack.health,health);
		}
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		
		If (Emplacement) //Update the hidden emplacement every tick with the pitch and angle you're supposed to be moving it at.
		{
			Emplacement.Angle = Angle;
			Emplacement.Pitch = Pitch;
		}
	}
}

//HACK: I can't get the sprite rotation math right on the intended VisualThinker version. And nobody can help me with it. So this serves as a placeholder class.
Class KAI_EmplacementFakeOperator : Actor
{
	Vector3 Offsets;
	Actor Operator;
	Actor Emplacement;
	Mixin KAI_CheckFunctions;
	State SpriteState; //The state which we get the sprite to use.
	//Int PlayerSkinID; //The number of the players' skin. Only relevant if the operator is both a player, and of course, is using a skin.
	
	TextureID Texture;
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		//Set the first idle frame of the operator as the texture.
		//TODO: Need to also make the sprites have working rotations, fuck...
		If (Operator)
		{
			//If (!Texture)
			//Acquire the first valid see state sprite of the operator to use as the fallback graphic. If the graphic is TNT1A0, look for the next state's sprite.
			{
				//Int SkinNum = Operator.Player ? Operator.Player.GetSkin() : 0;
				State LeState = GetDefaultByType(Operator.GetClass()).SeeState;
				For (Int I; I < 32; I++)
				{
					LeState = LeState.NextState;
				}
				SpriteState = LeState;
				//PlayerSkinID = SkinNum;
				console.printf ("fake operator: took actors' idle sprite (%s)",texman.getname(texture));
			}
		}
		Else
			{console.printf ("fake operator: no actual operator");Destroy();}
	}
	override void ondestroy(){console.printf ("fake operator: we got removed for some other reason");if (!Texture) console.printf ("cuz we got no texture");}
	Override Void Tick()
	{
		If (!Operator || !Emplacement || !KAI_Emplacement(Emplacement).Operator)
		{console.printf ("fake operator: no operator or emplacement");
			Destroy();
			Return;
		}
		
		If (IsFrozen())
			Return;
		
		SetOrigin(KAI_Math.Vec3OffsetRelative (Emplacement, Offsets),True);
		A_Face (Emplacement);
		
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 1
			{
				If (SpriteState)
				{
					Sprite = SpriteState.Sprite;
					Frame = SpriteState.Frame;
				}
				//console.printf ("fake operator: took actors' idle sprite (%s%d)",sprite,frame);
			}
			Loop;
	}
}
/*Class KAI_EmplacementFakeOperator : VisualThinker
{
	Vector3 Offsets;
	Actor Operator;
	Actor Emplacement;
	Mixin KAI_CheckFunctions;
	State SpriteState; //The state which we get the sprite to use.
	Int PlayerSkinID; //The number of the players' skin. Only relevant if the operator is both a player, and of course, is using a skin.
	
	//Cut down version of GetSpriteAngleFromPos(). 
	Int FakeOpGetSpriteAngle (Vector3 CamPos, Bool SixteenAngles)
	{
		Vector3 Coords = Level.SphericalCoords (Pos,CamPos);
		Double Ang = -Coords.X;
		
		Double Angle = Emplacement.Angle + 180;
		Double SprAng = Angle - Ang;
		Double Result;
		If (!SixteenAngles)
		{
			Result = BAM (SprAng - (Angle/* + SpriteRotation/) + 45.0 / 2 * 9) >> 28;
		}
		Else
		{
			Result = BAM (SprAng - (Angle/* + SpriteRotation/) + 45.0 / 2 * 9 - 180.0 / 16) >> 28;
		}
		Return Int(Result);
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		//Set the first idle frame of the operator as the texture.
		//TODO: Need to also make the sprites have working rotations, fuck...
		If (Operator)
		{
			//If (!Texture)
			//Acquire the first valid see state sprite of the operator to use as the fallback graphic. If the graphic is TNT1A0, look for the next state's sprite.
			{
				Int SkinNum = Operator.Player ? Operator.Player.GetSkin() : 0;
				State LeState = GetDefaultByType(Operator.GetClass()).SeeState;
				TextureID Graphic = LeState.GetSpriteTexture (0,SkinNum);
				For (Int I; I < 32; I++)
				{
					If (Graphic.IsValid() && !(Texman.GetName(Graphic) ~== "TNT1A0")) //This is NOT a valid graphic, look for a valid graphic in the next state!
						Break;
					LeState = LeState.NextState;
					Graphic = LeState.GetSpriteTexture (FakeOpGetSpriteAngle(Players[ConsolePlayer].Camera.Pos,True),SkinNum);
				}
				SpriteState = LeState;
				Texture = Graphic;
				PlayerSkinID = SkinNum;
				console.printf ("fake operator: took actors' idle sprite (%s)",texman.getname(texture));
			}
		}
		Else
			{console.printf ("fake operator: no actual operator");Destroy();}
	}
	override void ondestroy(){console.printf ("fake operator: we got removed for some other reason");if (!Texture) console.printf ("cuz we got no texture");}
	Override Void Tick()
	{
		Super.Tick();
		
		If (!Operator || !Emplacement || !KAI_Emplacement(Emplacement).Operator)
		{console.printf ("fake operator: no operator or emplacement");
			Destroy();
			Return;
		}
		
		Texture = SpriteState.GetSpriteTexture (FakeOpGetSpriteAngle(Players[ConsolePlayer].Camera.Pos,True),PlayerSkinID);
		If (IsFrozen())
			Return;
		
		Pos = KAI_Math.Vec3OffsetRelative (Emplacement, Offsets);
	}
}*/

Class KAI_EmplacementPlayer : PlayerPawn
{
	Default //Pretty much every other property and flag is up to the modder.
	{
		+DontMorph; //The Hexen animal player classes used for morphing don't disallow morphing. But I do by default just to be safe.
		+NoSkin; //They do disallow skins though and for good reason I'm pretty sure.
	}
	Mixin KAI_CheckFunctions;
	//NOTE: For emplacement players using skins, modders should likely use PlayerInfo.GetSkin(), to get the original pawns' skin. And add custom support for each skin.
}