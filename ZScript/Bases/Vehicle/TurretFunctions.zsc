//$GZDB_SKIP
//Functions and code exclusive to the turret class.
Extend Class KAI_BaseTurret
{
	//Is the turret too high or too low over its' elevation limits ?
	Int GetElevationState()
	{
		Double Diff = 0.1; //The turret pitch is clamped every tick, so this small difference allows them to still stop shooting.
		If (MaxPitch != 0 && Pitch-Diff < MaxPitch) Return ELEVATION_TOOHIGH;
		If (MinPitch != 0 && Pitch+Diff > MinPitch) Return ELEVATION_TOOLOW;
		Return ELEVATION_INBOUNDS;
	}
	
	//Is the other actor specified too high or below the turrets' pitch limits ?
	//ZOfs and TargZOfs are properties passed over to PitchTo().
	Int IsOverPitchLimits (Actor Other, Double ZOfs = 0, Double TargetZOfs = 0)
	{
		If (!Other || MaxPitch == 0 && MinPitch == 0) Return ELEVATION_INBOUNDS; //No other actor or pitch limits specified.
		
		Double PitchToOther = PitchTo (Other,ZOfs,TargetZOfs);
		
		If (MaxPitch != 0 && PitchToOther < MaxPitch) Return ELEVATION_TOOHIGH;
		If (MinPitch != 0 && PitchToOther > MinPitch) Return ELEVATION_TOOLOW;
		Return ELEVATION_INBOUNDS;
	}
	
	//KLUDGE: This is kind of a shit system. Or rather, one that's not extensible, and can't be automated in the library, so it needs specific manual setup.
	//Conditionally change the turrets' sprites based on pitch.
	Int UpdateTurretElevation (Int FaceDown, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 6 && Pitch >= 0)
			Return FaceDown;
		Else If (Pitch < 6 && Pitch >= -15)
			Return FaceStraight;
		Else If (Pitch < -14 && Pitch >= -50)
			Return FaceUp;
		Else If (Pitch <= -50)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	//=====|Turret traversal|=====\\
	Enum TurretRotationFlags
	{
		RTVF_NOTARGETCHECK	= 1 << 0, //The turret will apply its' rotation mechanics even if it has a target.
		RTVF_RELATIVEONLY	= 1 << 1, //The turret will only rotate relative to its masters' angle + its' TurretRotationOffset, even if the turret isn't destroyed.
	}
	
	//Makes the turret rotate back over time to the direction that the vehicle is facing. Instead of snapping back instantly.
	Void RotateToVehicle (Int Flags = 0)
	{
		If (!Master) Return;
		
		If (IsDead (Self) || Flags & RTVF_RELATIVEONLY)
		{
			Angle = Master.Angle+TurretRotationOffset;
			Return;
		}
		
		If ((!Target || Flags & RTVF_NOTARGETCHECK))
		{
			If (AbsAngle (Master.Angle, Angle) < 0.75) TurretSnapDelay = 0; //Snap back into the vehicles' position if the angle difference is small enough.
			
			//If the pitch difference is too small, just start snapping to the vehicles' direction.
			If (!TurretSnapDelay || Abs (Master.Pitch - Pitch) < 0.75)
				Pitch = Master.Pitch;
			Else
				Pitch += (Master.Pitch - Pitch) * TurnAmount;
			
			If (!TurretSnapDelay)
			{
				Angle = Master.Angle;
			}
			Else
			{
				Angle += DeltaAngle (Angle, Master.Angle) * TurnAmount;
			}
		}
	}
	
	//Update the turret snap timer. Used in turrets' See states.
	Void UpdateTurretSnapTimer (Int DefaultValue = 50)
	{
		If (!Target && TurretSnapDelay > 0)
			TurretSnapDelay--;
		Else If (Target)
			TurretSnapDelay = DefaultValue;
	}
	
	//Performs the special combat traverse code when the turret is in one of its' defined AttackStates. This is called in KAI_BaseTurrets' Tick().
	//Can also be called in 1-tic long non-attack states to produce the same turret traverse.
	Void DoCombatTraverse()
	{
		If (bNoCombatTraverse || !Target) Return;
		//NOTE: A pitch of 270 means no pitch shifting in A_Face, which is bad for the turrets, since code like their LOF checks normally relies on them actually facing the target properly.
		Double AngleTraverse = CombatAngleTurnRate > 0 ? CombatAngleTurnRate/GameTicRate : 0;
		Double PitchTraverse = CombatPitchTurnRate > 0 ? CombatPitchTurnRate/GameTicRate : 0;
		//console.printf ("horz traverse %f, vert traverse %f",angletraverse,pitchtraverse); //DEBUG
		AimAtTarget (AngleTraverse,PitchTraverse,flags:FAF_MIDDLE);
	}
	
	//Aim the turret ahead of the targets' trajectory, allowing to fire in anticipation of where they'll be. Basically, this is the turrets' fire control system.
	//TODO: Probably make a FastTurretAttackSpeed for FastSpeed of projectiles with -fastmonsters on.
	//It basically tries to move the other actor 1 tick into the future, makes the turret face there instead. And revert their position.
	//Tics: The travel time of the turrets' attack in tics. Used to estimate where the target will be once the attack arrives. -1 is an automatic estimation based on the TurretAttackSpeed property.
	//TODO: Change the LOF checks on the MVP turrets to fire at the direction of the target instead of the turrets' aiming direction.
	Void AimAtTarget (Double Max_Turn = 0, Double Max_Pitch = 270, Double Ang_Offset = 0, Double Pitch_Offset = 0, Int Flags = 0, Double Z_Ofs = 0,
	Int Tics = -1)
	{
		If (!Target) Return;
		
		Float FloatTics;
		//Estimate the travel time the turrets' attack needs.
		If (Tics == -1 && TurretAttackSpeed > 0)
			Tics = Distance3D (Target)/TurretAttackSpeed;
		Tics = Clamp (Tics,1,INT.MAX); //Needs at least 1 tic.
		FloatTics = Tics; //Finer precision on multiplier the extrapolated velocity, for extra accuracy.
		Vector3 OldPos = Target.Pos;
		//If the actor to face is your target and it has no velocity.
		/*If (FaceTo == Target && KAI_Math.IsZeroVector3 (FaceTo.Vel))
		{
			//IsTeleportMonster = False;
			Vector3 FuturePos = PredictFutureTargetPosition(FloatTics);
			If (FuturePos == FaceTo.Pos || KAI_Math.IsEmptyVector3(FuturePos))
			{a_log ("still nothing");
				TraceAimingDirection (MaxTargetRange);
				A_Face (FaceTo, Max_Turn, Max_Pitch, Ang_Offset, Pitch_Offset, Flags, Z_Ofs);
				Return;
			}
			//IsTeleportMonster = True; //If the target brought the turret here, and does have some fake velocity, then it's probably a normal monster.
			//a_log ("tracking monster");
			//Then try to predict its' future velocity and turn there instead.
			FaceTo.SetOrigin (FuturePos,True);
			console.printf ("future %.4f %.4f %.4f, present %.4f %.4f %.4f",futurepos.x,futurepos.y,futurepos.z,target.pos.x,target.pos.y,target.pos.z);
			//DEBUG: Fire a white beam at the desired turret direction.
			FSpawnParticleParams P; P.Color1 = "White"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
			KAI_LOFRaycast.VisualizeTracePath(Pos,faceto.pos,MaxTargetRange,params:p);
			TraceAimingDirection (MaxTargetRange);
			A_Face (FaceTo, Max_Turn, Max_Pitch, Ang_Offset, Pitch_Offset, Flags, Z_Ofs);
			FaceTo.SetOrigin (OldPos,True);
			Return;
		}*/
		//If it's not your target or already has velocity, the prediction should be much simpler.
		//Else If (!KAI_Math.IsZeroVector3 (FaceTo.Vel))
		//{
			//console.printf ("non-target current position is %d %d %d",faceto.pos.x,faceto.pos.y,faceto.pos.z);
			Vector3 Test = Level.Vec3Diff (LastEnemyPosition,Target.Pos);
			If (IsTeleportingMonster(Target))
			{
				Vector3 TPOnly = Level.Vec3Diff (Test,Target.Vel); //Get the teleport movement, sans velocity.
				TPOnly = GetTeleportMoveDivision();
				console.printf ("tponly is %.3f %.3f %.3f",tponly.x,tponly.y,tponly.z);
				Test = Level.Vec3Offset (TPOnly,Target.Vel);
			}
			console.printf ("velocity is %.3f %.3f %.3f",target.vel.x,target.vel.y,target.vel.z);
			Target.SetXYZ (Level.Vec3Offset (Target.Pos,Test*FloatTics));
			a_log ("go velocity");
			//DEBUG: Fire a white beam at the desired turret direction.
			FSpawnParticleParams P; P.Color1 = "White"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
			KAI_LOFRaycast.VisualizeTracePath(Pos,Target.pos,MaxTargetRange,8,p);
			//DEBUG: And fire a yellow beam at the actual direction.
			TraceAimingDirection (MaxTargetRange);
			
			//console.printf ("non-target future position is %d %d %d",faceto.pos.x,faceto.pos.y,faceto.pos.z);
			A_Face (Target, Max_Turn, Max_Pitch, Ang_Offset, Pitch_Offset, Flags, Z_Ofs);
			Target.SetXYZ (OldPos);
			Return;
		//}
		//If all else fails, just call A_Face normally.
		//Else
		//	{A_Face (FaceTo, Max_Turn, Max_Pitch, Ang_Offset, Pitch_Offset, Flags, Z_Ofs);a_log ("you fell off+mid");}
	}
	
	//Fire a yellow ray at the specified distance away from the direction the turret is at. Debug function.
	Void TraceAimingDirection (Double Distance)
	{
		FSpawnParticleParams PP; PP.Color1 = "Yellow"; PP.Style = STYLE_None; PP.Lifetime = 1; PP.Size = 10; PP.StartAlpha = 1; PP.FadeStep = -1; PP.Flags = SPF_FULLBRIGHT;
		Vector3 FacingPos = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D(Angle, -Pitch, Distance));
		KAI_LOFRaycast.VisualizeTracePath(Pos,FacingPos,Distance,8,pp);
	}
	
	//Tries to very crudely predict where the target will be in the next tick.
	//KLUDGE: The fact that GZDoom doesn't store the position actors had in the last tick is a huge pain in the ass.
	//FIXME: Figure out why every few dozen tics or so, the future position stops being returned.
	Vector3 PredictFutureTargetPosition (Int FutureTics = 1, Bool ForceFakeVel = False)
	{
		If (!Target) Return (Double.NaN,Double.NaN,Double.NaN);
		
		FutureTics = Clamp (FutureTics,1,INT.MAX); //Needs at least 1 tic.
		
		If (KAI_Math.IsZeroVector3 (Target.Vel) || ForceFakeVel)
		{
			Vector3 FakeVel;
			spawn ("kai_debugpoint",lastenemyposition);
			//Copied from HandleTargetPrediction() (VellIntercept() wrapper)
			If (Target.CurState.Tics)
				FakeVel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition) / Target.CurState.Tics;
			Else //Fallback to prevent division by zero.
				FakeVel = Level.Vec3Diff (LastEnemyPosition,CurrentEnemyPosition);
			
			If (KAI_Math.IsZeroVector3 (FakeVel)) //The target is just flat out not actually moving.
				{a_log ("epic monster tracking fail");Return (Double.NaN,Double.NaN,Double.NaN);}
			
			Return Level.Vec3Offset (Target.Pos,FakeVel*FutureTics);
		}
		
		//If the above didn't trigger, the presumably the target has a velocity to extrapolate.
		//Return Level.Vec3Diff (Target.Pos,Target.Vel*FutureTics);
		Return (Double.NaN,Double.NaN,Double.NaN);
	}
	//==============================
	
	//Returns true if the Other actor is within a cone of the specified size. The Size is the angle and pitch that the Other actor must be within relative to the callers' direction.
	//Honestly probably not a good idea to use this for anything, at least not the distance falloff stuff. Maybe someone can PR a fix for this at some point.
	Bool IsInCone (Actor Other, Double Size = 5, Double FalloffScale = 256)
	{
		If (!Other || Size <= 0)
			Return False;
		//HACK: This is meant to make the cone fall off linearly with distance. But pure linear falloff was too much so I had to scale it.
		//I think it works now ? IDFK I didn't even pass elementary school math. There's a reason I use so little math in anything.
		If (FallOffscale > 0)
		{
			Double OriginalSize = Size;
			Size = Max (0, Size - (Distance3D (Other) / FalloffScale));
			Size = Clamp (Size,0.1,OriginalSize*2); //Clamp the resulting value.
		}
		Return (AbsAngle (AngleTo(Other),Angle) <= Size && Abs (Pitch - PitchTo (Target)) <= Size);
	}
	
	//A ZScript copy of A_MonsterRefire without the shitty HitFriend() check, and with the A_FaceTarget() call toggleable.
	//Chance, AbortState: Work the same as in A_MonsterRefire.
	//DontFaceTarget: If on, the turret won't instantly face the target after each refire.
	//RetargetCheckChance: The chance that RetargetVehicleHull() runs after each refire. Never runs if set to -1. 
	//RetargetCheckFlags: The flags to pass to RetargetVehicleHull() if it DOES run.
	//FOV: If the target is outside this FOV, then have a chance to stop shooting. Default is 180, which basically disables this check.
	State KAI_TurretRefire (Int Chance, StateLabel AbortState, Bool DontFaceTarget = False, Int RetargetCheckChance = -1, Int RetargetCheckFlags = 0, Double FOV = 360)
	{
		If (!DontFaceTarget)
			A_FaceTarget();
		
		If (RetargetCheckChance != -1 && Random2[pr_monsterrefire]() < RetargetCheckChance)
			RetargetVehicleHull (RetargetCheckFlags);
		
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		//KLUDGE: Must manually check if Target is null for CheckFOV, because as of GZDoom 4.10, it doesn't natively do a null check, causing a hard crash !
		If (!Target /*|| HitFriend()*/ || IsDead (Target) || (Target && !CheckFOV (Target,FOV)) || !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
			Return FindState (AbortState);
		
		Return State (Null);
	}
	
	//This function can be used by turrets to make them able to pick different targets from their master, instead of chasing or firing at the same target.
	//Avoid: The actor to avoid targeting.
	//Origin: Specifies the actor the search starts around.
	//CheckRange: The area around the Origin actor to check for alternate targets.
	/*MinAlternateTargetRange: How far the new target must be from the actor that must be avoided. A value of 0 or less makes it just randomly
	pick one of the target candidates. If there is no other target that is further than MinAlternateTargetRange from the actor to avoid, then it picks the
	last target candidate left in the array.*/
	Actor PickDifferentTarget (Actor Avoid, Actor Origin, Double CheckRange, Double MinAlternateTargetRange = -1)
	{
		If (!Avoid || !CheckRange) Return Null;
		
		Array <Actor> TargetList;
		
		BlockThingsIterator EnemyFinder = BlockThingsIterator.Create (Origin,CheckRange);
		
		CheckRange *= CheckRange; //Do the multiplication for Distance3DSquared only once.
		
		While (EnemyFinder.Next())
		{
			Actor Mobj = EnemyFinder.Thing;
			
			If (!Mobj || Mobj == Avoid) Continue; //AVOID THIS TARGET.
			
			If (Mobj.bDormant || IsInanimateObject (Mobj)) Continue; //Don't attack dormant or inanimate object actors.
			
			If (!CanBeTargeted(Self, Mobj)) Continue; //Can't be targeted. (Duh)
			
			If (IsDead (Mobj)) Continue; //Is dead (Duuuuuuuuuuh)
			
			If (Origin.Distance3DSquared(Mobj) > CheckRange) Continue; //Too out of reach.
			
			If (!IsActorHostile (Mobj)) Continue; //Actor isn't hostile.
			
			If (!CheckSight(Mobj)) Continue; //Actor is not visible.
			
			TargetList.Push(Mobj); //Actor passed the checks, put it on the list of candidates.
		}
		
		//If no target was found at all.
		If (!TargetList.Size()) Return Null;
		
		//The minimum distance the new target must have from the actor to avoid is zero, so just pick a random potential target that was found.
		If (MinAlternateTargetRange <= 0) Return TargetList[Random(0,TargetList.Size()-1)];
		
		For (Int I = 0; I < TargetList.Size(); I++)
		{
			If (I == TargetList.Size()-1) Return TargetList[I]; //No target that is further than the actor to avoid, so return the last candidate left.
			
			If (TargetList[I].Distance3DSquared(Avoid) > MinAlternateTargetRange) Return TargetList[I]; //Candidate is too close to the actor to avoid.
			Else {} //Found a potential target that is far enough away from the actor that must be avoided.
		}
		
		Return Null;
	}
	
	Enum TurretLOFFlags
	{
		TLOF_FaceOther		= 1 << 0, //Should the ray be fired at the direction of the other actor instead of the direction the turret is facing ?
		TLOF_DoStayAround	= 1 << 1, //Should the function not mess with the turrets' bDontStayAround flag ?
		TLOF_FriendlyFire	= 1 << 2, //The turret can hit and harm its' allies, used by the lead check code if LeadStopChance is above -1.
	}
	
	//A generic turret LOF check, that is a wrapper for the stock projectile line of fire check.
	//Other: The actor to check for, normally this will be the target. You can also simply not specify another actor.
	//PropHealthThreshold: If a destructible prop is in the turrets' way with this much health or less, then still return true and fire through it.
	//SplashRadius: For explosive attacks, if the LOF misses and hits level geometry, then still return true if the Other actor would be caught in the blast.
	//CheckOffsets: How much to offset the checks' origin relative to the callers' position, default is offset 32 map units off the callers' Z position.
	//Flags: What flags to pass to the check, a list of flags can be found above.
	/*LeadStopChance: The chance that the turret will stop firing if in the calculated trajectory to its' target, there is an obstacle.
	If TLOF_FriendlyFire is on and the check finds an ally, it will immediately stop firing. Default is -1, which means the check doesn't run, if set to 0
	then the check will run, but the turret will stop firing no matter what kind of obstacle is ahead of it.
	*/
	Bool KAI_TurretCheckLOF (Actor Other = Null, Int PropHealthThreshold = 400, Double SplashRadius = 0, Vector3 CheckOffsets = (0,0,32), Int Flags = 0, Int LeadStopChance = -1)
	{
		Vector3 Direction;
		//Let's check in the direction the turret is aiming ahead to first.
		//If (LeadStopChance > -1) KAI_LeadLOFCheck
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		If (!(Flags & TLOF_FaceOther)/* && (Other && Distance3DSquared(Other) > 2048)&& !IsInCone(Other,10)*/)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Other)
			{
				Double PitchTo = PitchTo (Other,14,Other.Height/2);
				Direction = (AngleToVector(AngleTo(Other), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = Other ? Distance3D (Other)+32 : MaxTargetRange;
		Check.Shooter = Self;
		Check.Other = Other;
		Check.SplashRadius = SplashRadius;
		Check.PropHealthThreshold = ProphealthThreshold;
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance);
		
		If (Check.BadLOF)
		{
			If (!(Flags & TLOF_DoStayAround)) bDontStayAround = True;
			Check.Destroy();
			Return False;
		}
		
		If (!(Flags & TLOF_DoStayAround)) bDontStayAround = False;
		Check.Destroy();
		Return True;
	}
	/*
	//Checks the direction that the turret is actually aiming attack when target tracking is enabled. To stop shooting if certain obstacles can stop the lead shots.
	//CheckOffsets: How much to offset the checks' origin relative to the callers' position, default is offset 32 map units off the callers' Z position.
	//StopChance: The chance that the turret will stop firing if it would hit an obstacle. Default is 0, which means that the turret stops immediately.
	Bool KAI_LeadLOFCheck (Vector3 CheckOffsets = (0,0,32), Bool FriendlyFire = False, Int StopChance = 0)
	{
		If (!bNoTargetPrediction)
		{
			Let Lead = New ("KAI_TargetTrackCheck");
			Double Distance = Target ? Distance3D (Target)+32 : MaxTargetRange;
			Vector3 Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
			
			Lead.Shooter = Self;
			Lead.StopChance = StopChance;
			Lead.FriendlyFire = FriendlyFire;
			Lead.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
			
			If (Lead.BadLOF)
			{a_log ("getting a little ahead of myself");
				Lead.Destroy();
				Return False;
			}
		}
		
		Return True;
	}*/
	
	Enum FindInLOFFlags
	{
		FIL_FaceTarget = 1 << 0, //Fire the ray straight at the Other actors' direction instead of wherever the turret is facing.
		FIL_HitscanHit = 1 << 1, //Stop the search if a hitscan blocking line is in the way.
		FIL_MissileHit = 1 << 2, //Ditto, but for projectile blocking lines instead.
	}
	
	//Finds all actors in the line of fire, and adds them to the array specified in FoundActors.
	//Flags: The flags to alter the checks' behavior, see above for the actual flags.
	//Range: The range of the check.
	//ActorLimit: How many actors the check will find before stopping.
	//CheckOffsets: The offsets of the check relative to the caller.
	//Other: The actor to aim the check to if FIL_FaceTarget is on.
	//FoundActors: The array to output all the actors the check found to.
	Void KAI_FindInLOF (Int Flags, Double Range, Int ActorLimit = 0, Vector3 CheckOffsets = (0,0,32), Actor Other = Null, Out Array <Actor> FoundActors = Null)
	{
		Let Check = New ("KAI_LOFActorFinder");
		Vector3 Direction;
		If (!(Flags & FIL_FaceTarget))
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			Double PitchTo = PitchTo (Other,14,Other.Height/2);
			Direction = (AngleToVector(AngleTo(Other), Cos(PitchTo)), -Sin(PitchTo));
		}
		
		Check.Shooter = Self;
		Check.Other = Other;
		Check.ActorLimit = ActorLimit;
		
		Int BlockFlags;
		If (Flags & FIL_HitscanHit && !(Flags & FIL_MissileHit)) BlockFlags |= KAI_LOFRaycast.BLITW_HitscansOnly;
		Else If (Flags & (FIL_MissileHit|FIL_HitscanHit)) BlockFlags |= KAI_LOFRaycast.BLITW_HitscansToo;
		Check.BlockMode = BlockFlags;
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Range,0);
		
		//The most important bit. Transfer the actors the line tracer found to the array that was inputted 
		If (FoundActors)
			FoundActors.Move(Check.Mobjs);
		
		Return;
	}
}