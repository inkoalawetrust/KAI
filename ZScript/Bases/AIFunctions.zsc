//$GZDB_SKIP
//AI functions shared by all NPC types.
Extend Class KAI_Actor
{
	//=====|Range checks|=====\\
	Enum KAIRangeCheck
	{
		CMR_NOHITFRIEND	= 1 << 0, //The function should not run the native shit autoaimed P_HitFriend() check. Only useful for KAI_CheckMissileRange.
		CMR_3DDISTANCE	= 1 << 1, //The range check should use Distance3D instead of Distance2D.
		CMR_INVERTDIST	= 1 << 2, //Invert the missile attack chance with distance. Making the NPC MORE likely to attack the further the target is.
		CMR_IGNOREDIST	= 1 << 3, //Ignore the distance check attack chance code for missile attacks entirely.
	}
	
	//Returns true if the caller is in melee range of the other actor. Basically a rip of P_CheckMeleeRange().
	Bool KAI_CheckMeleeRange (Actor Other, Double Range = -1, Int Flags = 0)
	{
		Double Dist;
		
		If (!Target || CurSector.Flags & Sector.SECF_NOATTACK)
			Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other));
		If (Range < 0) Range = MeleeRange;
		
		If (Dist >= Range + Target.Radius)
			Return False;
		
		If (Target == Goal)
			Return True;
		
		If (!bNoVerticalMeleeRange)
		{
			If (Target.Pos.Z > Pos.Z+Height) Return False;
			If (Pos.Z+Height < Target.Pos.Z) Return False;
		}
		
		If (IsFriend (Other))
			Return False;
		
		If (!CheckSight (Target))
			Return False;
		
		Return True;
	}
	
	//The function is more or less the same as its' native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	Bool KAI_CheckMissileRange (Actor Other, Int Flags = 0)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!Other || !CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		If (!(Flags & CMR_NOHITFRIEND) && bFriendly && HitFriend ()) Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other)) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (Flags & CMR_IGNOREDIST) //Skip stupid distance formula.
			Return True;
		
		Dist *= MissileChanceMult; //If CMF_INVERTDIST is on, keep in mind that the behavior of the MissileChanceMult is also effectively inverted !
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		If (!(Flags & CMR_INVERTDIST))
			Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
		Else
			Return Random2[PR_CheckMissileRange]() <= Max(Int(Dist), MMC);
	}
	
	//=====|Sight and locomotion|=====\\
	Enum KAILookFlags
	{
		KAIL_CHASETARGET = 1 << 0, //If the actor already has a target. Then go to the specified see state. For when the internal A_LookEx() doesn't do it itself.
		KAIL_NOTEMPSTAND = 1 << 1, //Should the actor not temporarily stay still if friendly (Not begin moving due to player fire) between A_LookEx() calls ?
	}
	
	//Generic wrapper for A_LookEx shared by all actors.
	//Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label: These properties are all directly transferred to A_LookEx, so  they work the same as in that function.
	//ExtraFlags: The extra flags that modify KAI_Look's behavior. Look above for available flags.
	Void KAI_Look (Int Flags = 0, Double MinSeeDist = 0, Double MaxSeeDist = 0, Double MaxHearDist = 0, Double FOV = 0, StateLabel Label = Null, Int ExtraFlags = 0)
	{
		//HACK: This shit is probably a super hacky way to just get actors that are already targeting an actor in their Spawn state to actually attack it.
		If (!(Flags & LOF_NOJUMP) && ExtraFlags & KAIL_CHASETARGET && Target)
		{
			If (Label)
				SetStateLabel (Label); //Go to specified state.
			Else
				SetState (SeeState); //Go to default See state.
		}
		Bool Stand = bStandStill;
		If (!(ExtraFlags & KAIL_NOTEMPSTAND))
		{
			Stand = bStandStill;
			bStandStill = True;
		}
		A_LookEx (Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label);
		If (!(ExtraFlags & KAIL_NOTEMPSTAND)) bStandStill = Stand;
	}
	
	Enum KAIMoveTowardsFlags
	{
		KMT_CHASEGOAL 	= 1 << 0, //If the caller has a goal pointer, and the bChaseGoal flag on. It will follow the goal instead of the TargetPos.
		KMT_ZIGZAG	  	= 1 << 1, //Move around with more A_Chase-esque movement (Like zigzagging), instead of only moving in a straight line.
		KMT_NOLINEUSE 	= 1 << 2, //Disable the function being able to make the monster use crossed over lines at all, in case you want your own code for that.
		KMT_3D		  	= 1 << 3, //The actor should be able to move in full 3D, such as if it's a flying NPC.
	}
	
	Double LastTurnDir;
	Int TurnCount; //Keeps track of how many turns in a row an actor calling KAI_MoveTowards with CHF_NORANDOMTURN should make.
	Vector3 ZigZagPos;
	
	//Makes the actor move towards the specified position.
	//TODO: Add a check for if a vehicles' turret would collide with the next move. And probably find a way to call it recursively for turrets on turrets.
	//CREDIT: Original 2D A_Chase-like movement written by Custodian (Beyond Sunset creator). Modified and expanded by me (inkoalawetrust).
	//TargetPos: The position to move to.
	//DetourFactor: How long the actor is allowed to move in a direction after hitting an obstacle, before heading straight for the target again.
	//AngleLimit: How much the actor can turn per step. Used to not have it snap back 180 or anything like that.
	//ChaseFlags: What flags from A_Chase should the function use ? Supports CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	//Flags: The functions' own flags, see above for a list of flags.
	//PitchLimit: How much the actors' pitch can change per call. Used by KMT_3D to limit how much the actor moves up and down, effectively.
	Void KAI_MoveTowards (Vector3 TargetPos, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		If (ChaseFlags & CHF_DONTMOVE || KAI_Math.IsEmptyVector3 (TargetPos)) Return;
		
		//Basically does what P_NewChaseDir() does to handle Thing_SetGoal's "Don't chase target" flag: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L943-946
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
			TargetPos = Goal.Pos;
		
		//Handle making the NPC zig zag in a manner similar to KAI_MoveAway.
		If (Flags & KMT_ZIGZAG)
		{
			If (NewPosStepCount <= 64 && Level.Vec3Diff (Pos,ZigZagPos).Length() >= MeleeRange)
			{
				If (!KAI_Math.IsEmptyVector3 (ZigZagPos))
					TargetPos = ZigZagPos;
				NewPosStepCount++;
			}
			Else
			{
				ZigZagPos = FindRandomMovePos (TargetPos,16,256,FRMP_CLOSEST,(Flags & KMT_3D));
				NewPosStepCount = 0;
			}
		}
		Else
			ZigZagPos = (Double.NaN,Double.NaN,Double.NaN);
		
		//The function works with the CANTLEAVEFLOORPIC flag as well.
		TextureID OldFloor = FloorPic;
		
		double LastAngle = Angle;
		double NextAngle = LastAngle;
		Bool IsVehicle = (Self Is "KAI_BaseVehicle");
		Bool TurretBlock; //Is this movement blocked because one of the turrets' would collide with something?
		
		//MoveCount is greater than 0 when avoiding an obstacle
		if (MoveCount)
		{
			MoveCount--;
		}
		else
		{
			lastturndir = 0;
			//move directly towards Other
			if (!(ChaseFlags & CHF_NORANDOMTURN)) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		}
		
		//When CHF_NORANDOMTURN is on. The actor can take a set amount of turns before no longer turning to face its' target.
		If (ChaseFlags & CHF_NORANDOMTURN && --TurnCount > 0) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		
		Double NextPitch = Pitch; //Used by 3D movement.
		
		//Normal 2D TryMove() movement.
		If (!(Flags & KMT_3D))
		{
			//absolute position of next movement
			vector2 NextPos = Vec2Angle(speed, NextAngle, True);
			FCheckPosition Move;
			Move.FromPMove = True; //Move anyways if there's an actor within your hitbox already.
			If (IsVehicle) //Vehicle push and crush handling.
			{
				Let Vehicle = KAI_BaseVehicle(Self);
				Array <Actor> Pushovers;
				KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
				KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
				//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
			}
			//if (turretblock) console.printf ("DING DING DING TURRET IN THE WAY!");
			//else if (isvehicle) console.printf ("the turrets of %p aren't getting on their way",self);
			//If (!(Flags & KMT_NOLINEUSE)) {a_log ("lemme try opening this door");CheckMonsterUseSpecials ();}
			bool moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			
			//if I hit an obstacle while avoiding another, try moving straight towards Other
			if (!moved && MoveCount || bCantLeaveFloorPic && FloorPic != OldFloor)
			{
				If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
				MoveCount = Int(random(16,32)*DetourFactor);
				NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				NextPos = Vec2Angle(speed, NextAngle, True);
				If (IsVehicle) //Vehicle push and crush handling.
				{
					Let Vehicle = KAI_BaseVehicle(Self);
					Array <Actor> Pushovers;
					KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
					KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
					//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
				}
				moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			}
			
			//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
			If (!moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
			{
				Switch (AngleLimit)
				{
					Case 20:
						TurnCount = Random (2,4);
						Break;
					Case 10:
						TurnCount = Random (3,6);
						Break;
					Case 5:
						TurnCount = Random (8,12);
						Break;
					Default:
						Break;
				}
			}
			
			//test movement angles until I find one that works, avoid that obstacle for MoveCount tics
			if (!moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
			{
				MoveCount = Int(random(16,32) * DetourFactor);
	 
				//try moving the same relative direction as last time
				if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
				
				//find viable movement direction
				for (double i = 1; i < 6; i++)
				{
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
					
					lastTurnDir *= -1.0;
					
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
				}
			}
		}
		//3D velocity based movement
		//TODO:
		//Include the vehicle pushing and crushing code. And also make VehiclePushActors accept 3D coordinates instead, why did I make it a Vector2 when I planned this for months?
		//CREDIT: Boondorl and RaveYard for helping me get this fucking god forsaken math to mostly work.
		Else
		{
			Bool NoStockMovement;
			//Check if the actor flies with custom code
			If (bCustomFlyer)
				NoStockMovement = CustomFlyingMovement (TargetPos, DetourFactor, AngleLimit, ChaseFlags, Flags, PitchLimit);
			
			//No custom flying movement (Or there is but it complements you)? Then run.
			If (!NoStockMovement)
			{
			Bool Moved;
			Vector3 F3DVel;
			Vel *= KMT_3D_DecelWrongVector (TargetPos); //Decelerate from wrong velocities, like when an explosion blasts the actor off-course.
			
			//If (!MoveCount)
			{
				NextPitch = GetPitchToPos(TargetPos,PitchLimit);
				If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D: NextPitch is %.2f,",NextPitch);
				F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,Speed); //Generate velocity that reaches the target over time (Or instantly).
				//Check if move will be blocked.
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
			}
			
			Double ZClimb;
			//Climb up or down from obstacle we hit. Improved version of standard MF_FLOAT behavior for point-to-point movement.
			If (KMT_3D_ScaleObstacle(Level.Vec3Offset(Pos,F3DVel),ZClimb))
			{
				//Climb position is higher than us, go up.
				If (ZClimb > Pos.Z)
					F3DVel.Z = FloatSpeed;
				//It's not, so that means we should go down instead.
				Else
					F3DVel.Z = -FloatSpeed;
				
				NextPitch = GetPitchToPos(Level.Vec3Offset(Pos,F3DVel.PlusZ(Height/2)),PitchLimit);
				F3DVel.X = F3DVel.Y = 0;
				
				//Returned that we moved (To not run the obstacle avoiding code.) If the coast is clear.
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
				//console.printf ("did we move? %d",moved);
			}

			//if I hit an obstacle while avoiding another, try moving straight towards Other
			If (!Moved && MoveCount)
			{
				If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
				MoveCount = Int(random(16,32)*DetourFactor);
				NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,Speed);
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
			}
			
			//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
			If (!Moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
			{
				Switch (AngleLimit)
				{
					Case 20:
						TurnCount = Random (2,4);
						Break;
					Case 10:
						TurnCount = Random (3,6);
						Break;
					Case 5:
						TurnCount = Random (8,12);
						Break;
					Default:
						Break;
				}
			}
			
			If (!Moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
			{
				MoveCount = Int(random(16,32) * DetourFactor);
				
				//try moving the same relative direction as last time
				if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
				
				//find viable movement direction
				for (double i = 1; i < 6; i++)
				{
					NextAngle = LastAngle + (i * 48 * lastturndir);
					
					F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,Speed);
					//Check if next move would be blocked.
					Moved = KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
					If (!Moved)
						Break;
					
					//Now do the opposite side too.
					LastTurnDir *= -1;
					
					NextAngle = LastAngle + (i * 48 * lastturndir);
					F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,Speed);
					//Check if next move would be blocked.
					Moved = KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
					If (!Moved)
						Break;
				}
			}
			
			//Actually move.
			KMT_3D_SpeedLimit (Speed*3,F3DVel); //HACK: Magic number to make the total vel length cap ACTUALLY match the speed property.
			If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D: Velocity is %.2f %.2f %.2f, length %.2f",Vel,Vel.Length());
			}
		}
		
		//face movement direction
		If (!(ChaseFlags & CHF_NODIRECTIONTURN))
		{
			Angle = Normalize180(NextAngle);
			If (Flags & KMT_3D)
				Pitch = -NextPitch;
		}
	}
	
	//Is there a scalable obstacle in front of the flier? If the answer is yes. It also has a Z value that can be set by reference for what Z to move to.
	//Right now it can't properly figure out how to scale a super steep slope from front to back. You know, since slopes are cursed. Will need a way to get the higher and lowest slope points!
	//It can climb down a ceiling slope pillar. A pillar with a slope at the top, it treats it like an unknown blocking but of geometry and so returns false.
	Protected Bool KMT_3D_ScaleObstacle (Vector3 Where, Double &TargetZ)
	{
		FCheckPosition Tm;
		Vector3 RealPos = Pos;
		SetZ (Where.Z);
		Bool Res = CheckMove (Where.XY,tm:Tm);
		Bool CanScale;
		If (!Res)
		{
			Double Padding = 64; //HACK: Don't fucking get stuck bouncing up and down at the vertical corner of obstacles.
			
			If (BlockingFloor && BlockingFloor.FloorPlane.IsSlope())
			{
				//console.printf ("touching slope floor");
				Vector3 Targ = BlockingFloor.FloorPlane.Normal.Unit() * Vel.Length();
				TargetZ = Pos.Z+Targ.Z; //TargetZ is further up the slope.
				console.printf ("climbing sloped floor at z %.2f",targetz);
				CanScale = True;
			}
			Else If (BlockingCeiling && BlockingCeiling.CeilingPlane.IsSlope())
			{
				//console.printf ("touching slope floor");
				Vector3 Targ = BlockingCeiling.CeilingPlane.Normal.Unit() * Vel.Length();
				TargetZ = Pos.Z-Height-Targ.Z; //TargetZ is further down the slope.
				console.printf ("climbing sloped ceiling at z %.2f",targetz);
				CanScale = True;
			}
			
			//We hit a two sided "ceiling" (Blocking I think) line, meaning there is a back sector to get the height of.
			//Unless that line is not even blocking us.
			If (BlockingLine && BlockingLine.Flags & Line.ML_TWOSIDED)
			{console.printf ("hello! I hit a line!");
				Line Blk = BlockingLine;
				Sector TargSec = Blk.BackSector == CurSector ? Blk.FrontSector : Blk.BackSector;
				console.printf ("blocking3dfloor %p",blocking3dfloor);
				//We hit a line with a lowered ceiling or raised floor in it.
				If (!(Blk.Flags & Line.ML_3DMIDTEX) && !Blocking3DFloor)
				{
					Double CeilHeight = TargSec.CeilingPlane.ZAtPoint(Where.XY);
					Double FloorHeight = TargSec.FloorPlane.ZAtPoint(Where.XY);
					Double TargSecHeight = CeilHeight - FloorHeight;
					console.printf ("two sided line found, where %.2f %.2f, ceilheight %.2f, floorheight %.2f",where.xy,ceilheight,floorheight);
					
					//Handle slope ceilings and floors in the next sector, prevents "fun" cases of the flyer climbing down or up a raised slope pillar
					//only to bump on the tip of the slope and fly off like a moron because it's an "obstacle".
					If (FloorHeight > Pos.Z && TargSec.FloorPlane.IsSlope() && !(FloorHeight >= Pos.Z+MaxStepHeight))
					{
						Vector3 Targ = TargSec.FloorPlane.Normal.Unit() * Vel.Length();
						TargetZ = Pos.Z+Targ.Z; //TargetZ is further up the slope.
						//console.printf ("climbing sloped floor at z %.2f",targetz);
						CanScale = True;
					}
					//Or ceiling.
					Else If (CeilHeight < Pos.Z && TargSec.CeilingPlane.IsSlope() && !(CeilHeight <= Pos.Z-MaxStepHeight))
					{
						Vector3 Targ = TargSec.CeilingPlane.Normal.Unit() * Vel.Length();
						TargetZ = Pos.Z-Height-Targ.Z; //TargetZ is further down the slope.
						console.printf ("climbing sloped ceiling at z %.2f",targetz);
						CanScale = True;
						console.printf ("climbing sloped ceiling");
					}
					
					//Nope, just a normal sector.
					//Don't run if the ceiling is higher than the floor or the sector is fully sealed.
					//Or if we are already over the "obstacle" to begin with.
					Else If (!(FloorHeight >= CeilHeight) && TargSecHeight >= Height && (FloorHeight > Pos.Z || CeilHeight < Pos.Z+Height))
					{
						If (FloorHeight > Pos.Z) //Floor at XY is higher than we are, so we need to go up.
							TargetZ = FloorHeight;
						Else If (CeilHeight < Pos.Z+Height) //Ditto but the ceiling is lower than us so go down.
							TargetZ = CeilHeight-Height;
						console.printf ("targetz is now %.2f",targetz);
						CanScale = True;
					}
				}
				//The two sided line we hit is a 3D middle texture.
				Else If (Blk.Flags & Line.ML_3DMIDTEX && !Blocking3DFloor)
				{
					Double Top, Bottom; Bool Valid;
					Int WhatSide = Level.PointOnLineSide (Where.XY,Blk,True);
					[Valid, Top, Bottom] = Blk.GetMidTexturePosition (WhatSide);
					console.printf ("scaling 3d midtex");
					Double Targ; Bool Down;
					[Targ, Down] = KMT_3D_GetObstacleClimbPos ((Top,Bottom,Top-Bottom),(CeilingZ,FloorZ),(Where.XY,RealPos.Z));
					If (Targ == Targ)
					{
						TargetZ = Targ;
						TargetZ += Down ? -Padding : Padding;
						console.printf ("padded targetz is %.2f, down is %d",targetz,down);
						CanScale = True;
					}
				}
				//The line we hit is part of a 3D floor maybe?
				//BUG: When a flyer climbs down a 3D floor while the target stands above the flyer, they will have a stroke when touching the 3DFloor ceiling.
				//No, checking if FFloor.Bottom or whatever doesn't do jack nor shit.
				Else If (Blocking3DFloor)
				{
					Sector TargSec = Blk.BackSector == CurSector ? Blk.FrontSector : Blk.BackSector;
					F3DFloor FFloor = Get3DFloorFromModel (Blocking3DFloor,TargSec);
					console.printf ("blocking3d floor %p, blockingceiling %p, blockingfloor %p",blocking3dfloor,blockingceiling,blockingfloor);
					If (FFloor)
					{
						Double Top = FFloor.Top.ZAtPoint(Where.XY);
						Double Bottom = FFloor.Bottom.ZAtPoint(Where.XY);
						Console.printf ("we hit a 3d floor, whose control sector is %p and its' bottom is %.2f",Blocking3DFloor,bottom);
						Double CeilingHeight = FFloor.Target.HighestCeilingAt(Where.XY);
						Double FloorHeight = FFLoor.Target.LowestFloorAt(Where.XY);
						
						Double Targ; Bool Down;
						[Targ, Down] = KMT_3D_GetObstacleClimbPos ((Top,Bottom,Top-Bottom),(CeilingHeight,FloorHeight),(Where.XY,RealPos.Z));
						//Valid return AND we can fit through.
						If (Targ == Targ)// && Top <= CeilingHeight-Height && Bottom >= FloorHeight+Height)
						{
							TargetZ = Targ;
							TargetZ += Down ? -Padding : Padding;
							console.printf ("padded targetz is %.2f, down is %d",targetz,down);
							CanScale = True;
						}
					}
				}
			}
			
			//We hit a blocking actor.
			If (!MovementBlockingLine && BlockingMobj && !(BlockingMobj.Pos.Z+BlockingMobj.Height <= Pos.Z) && !(BlockingMobj.Pos.Z >= Pos.Z+Height))
			{
				Double Targ; Bool Down;
				//Three little vectors jumping on the bed.
				[Targ, Down] = KMT_3D_GetObstacleClimbPos ((BlockingMobj.Pos.Z+BlockingMobj.Height,BlockingMobj.Pos.Z,BlockingMobj.Height),(BlockingMobj.CeilingZ,BlockingMobj.FloorZ),(Where.XY,RealPos.Z));
				If (Targ == Targ) //Not a NaN return. We can get over this actor.
				{
					TargetZ = Targ;
					TargetZ += Down ? -Padding : Padding;
					console.printf ("padded targetz is %.2f, down is %d",targetz,down);
					CanScale = True;
				}
			}
		}
		SetZ (RealPos.Z);
		Return CanScale;
	}
	
	//For finite height obstacles like 3D floors, determine the position to climb them over, is it up, under, neither, either?
	//Returns NaN if the actor cannot climb the finite height obstacle from here, like if it fully seals a sector or has other crap on its' top and bottom blocking movement.
	//ObsBounds: A vector holding (In order), the top and bottom heights of the obstacle, and its' height.
	//SectorHeights: The heights of the sector, to check if the obstacle blocks the sector by being at or beyond these heights. X is ceiling, Y is floor.
	//CheckPos: The position we're doing the check from. To check if the caller running this function would be blocked try to traverse this nondescript obstacle.
	//			The XY coordinates are used for the collision check for the hypthetical movement. But Z should be the ACTUAL current height of the actor.
	//BUG: The trivial height checks (Not running if the caller is entirely below or above the obstacle), don't run.
	Private Double, Bool KMT_3D_GetObstacleClimbPos (Vector3 ObsBounds, Vector2 SectorHeights, Vector3 CheckPos)
	{
		Double BlockTop = ObsBounds.X;//+ObsBounds.Z;
		Double BlockBottom = ObsBounds.Y;
		Double BlockHeight = ObsBounds.Z;
		
		Bool NoTop, NoBottom;
		Double Up = BlockTop;//BlockingMobj.Z+BlockingMobj.Height;
		Double Down = BlockBottom-Height;
		
		Double TargetZ;
		
		//... the caller is not even being blocked at all.
		If (BlockTop <= Pos.Z || BlockBottom >= Pos.Z+Height)
			Return Double.NaN, False;
		
		Bool GoingDown;
		
		//Can't climb up over. Either cuz the ceiling is fully blocked by the blocker or the gap is just too small to go through.
		If (BlockBottom+BlockHeight >= SectorHeights.X-Height || KMT_3D_MoveBlocked((CheckPos.XY,Up)))
			{NoTop = True;console.printf ("cant go up");}
		
		//Can't go under the blocker, for the same reason as above but with the floor instead.
		If (BlockBottom <= SectorHeights.Y+Height || KMT_3D_MoveBlocked((CheckPos.XY,Down)))
			{NoBottom = True;console.printf ("cant go down");}
		console.printf ("notop %d, nobottom %d",notop,nobottom);
		//Can only go up.
		If (!NoTop && NoBottom)
			{TargetZ = Up;console.printf ("its all uphill from here!");}
		//Can only go down.
		Else If (NoTop && !NoBottom)
		{
			TargetZ = Down;
			GoingDown = True;
			console.printf ("it's all downhill from here!");
		}
		//Can go either way, so pick whichever's closest.
		Else If (!NoTop && !NoBottom)
		{
			//Top is closest.
			If (CheckPos.Z >= BlockBottom+(BlockHeight/2))
				{TargetZ = Up;console.printf ("going up");}
			//Bottom is closer.
			Else
			{console.printf ("bottom is closer");
				TargetZ = Down;
				GoingDown = True;
			}
		}
		//console.printf ("targetz for actor blocker is %.2f",targetz);
		If (!(NoTop && NoBottom)) Return TargetZ, GoingDown;
		Else Return Double.NaN, False;
	}
	
	//Was the move at this position blocked?
	//IgnoreCeiling: Don't count a move as blocked if it's just that it'll be over the ceiling. To prevent KMT_3D from stroking out when bumping against ceilings.
	Protected Bool KMT_3D_MoveBlocked (Vector3 Where, Bool IgnoreCeiling = True)
	{
		Vector3 RealPos = Pos;
		FCheckPosition Tm;
		SetZ (Where.Z); //Z is separate.
		Bool Res = CheckMove (Where.XY,tm:Tm);
		If (IgnoreCeiling && Pos.Z+Height >= CeilingZ) Res = True;
		SetZ (RealPos.Z);
		If (Tm.StepThing) Res = True;
		Return !Res;
	}
	
	//Handle slowing down the actor based on just how far its' current velocity is from the target position, i.e if it fully faces away, it grinds to a halt.
	//Used to make the actor decelerate and gets its' bearings again when  thrown of course by external forces like explosions.
	//TargetPos: The desired position which there would be 0 deceleration returned if we headed straight for it.
	Protected Double KMT_3D_DecelWrongVector (Vector3 TargetPos)
	{
		Vector3 TheVel = Vel;
		If (TheVel == (0,0,0)) //Can't dot a vector of 0.
			TheVel = (0.001,0.001,0.001);
		Double DistFromTarg = (TargetPos - Pos).Unit() Dot TheVel.Unit(); //Get how much the actor is currently facing away from the target position.
		
		//Map dot product between 0 (Not facing at all) and 1 (Facing the desired vector).
		DistFromTarg = KAI_Math.LinearMap (DistFromTarg,-1,1,0.5,1);
		If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_DecelWrongVector(): Actor facing away from target pos factor is %.2f",DistFromTarg);
		Return DistFromTarg;
	}
	
	//Limit the max speed that the actor reaches over time. If the vel length is too high, extra vel is zeroed out as well until the length goes below SpeedLimit.
	Protected Void KMT_3D_SpeedLimit (Double SpeedLimit, Vector3 ExtraVel)
	{
		If (SpeedLimit == 0) //Wheeeeee
		{
			Vel += ExtraVel;
			Return;
		}
		Double Delta = Vel Dot ExtraVel;
		If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_Speedlimit() Delta is %.2f",Delta);
		Double Acceleration = 1;
		If (Delta < SpeedLimit) //Accelerate the actor, but never let them exceed the speed limit under their own motion.
			Vel += ExtraVel * Min (SpeedLimit - Delta,Acceleration);
	}
	
	//Returns a position for KMT_3D actors to head to avoid bumping into things. By averaging where a sphere of traces hit.
	//DOCUMENT: This'll be a fucking doozy to document. TL;DR: Trial and error the parameters with the debug CVAR, ideally use this per tick to propel the actor instead of using it like KAI_MoveAway() does.
	//HorzTraces: How many horizontal traces to fire in the sphere.
	//VertTraces: Ditto but for vertical (Pitch) traces. If set to 0, the function operates in horizontal-only mode.
	//Distance: How far each trace will go. Basically how far the actor checks for obstacles.
	//Threshold: If the distance between the averaged coordinate and the actors' position is less than this. The function will return NaN.
	//Magnitude: How much the averaged coordinate is moved from the origin. Useful to make the obstacle avoiding effect larger when firing a lot of (Or distant) traces for example.
	//MinDist: If any trace hits something closer to the actor than this distance, return that there's nothing to avoid.
	//This function returns the averaged position of where every trace hit. And the average distance that every trace that was blocked by something went.
	Vector3, Double KAI_AvoidObstacles3D (Int HorzTraces, Int VertTraces, Double Distance, Double Threshold = 5, Double Magnitude = 1, Double MinDist = 0)
	{
		If (Distance <= 0 || HorzTraces <= 0)
			Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
		//HACK: Fun hack to store the hit locations of each trace. Of course the trace data can't be put in an array since it too is a struct, that'd be too expensive anyway.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Array <Double> Dists; Double DistSum; //For getting the average distance from all prematurely terminated traces made.
		
		Double Ang, Pit; //Angle and pitch to fire each trace at.
		Pit = -90;
		If (VertTraces <= 0) //Were firing in 2D mode.
			Pit = 0;
		Double HorzDiv = 360/HorzTraces;
		Double VertDiv = VertTraces > 0 ? 180/VertTraces : 0;
		
		Bool StopHorz; //Used to make only one angle trace fire when firing straight up or down.
		FLineTraceData Data;
		FSpawnParticleParams Debug;
		If (KAI_Debug3DObstacleCheck)
		{
			Debug.Color1 = "Green";
			Debug.Style = STYLE_None;
			Debug.Lifetime = KAI_Debug3DObstacleCheck;
			Debug.Size = 4;
			Debug.StartAlpha = 1;
			Debug.FadeStep = -1;
			Debug.Flags = SPF_FULLBRIGHT;
		}
		
		//Run horizontal traces.
		For (Int I = 0; I < HorzTraces; I++)
		{
			If (!StopHorz)
			{
				LineTrace (Normalize180(Ang),Distance,Pit,TRF_BLOCKSELF,0.1,data:Data);
				If (KAI_Debug3DObstacleCheck)
				{
					If (Data.HitType != TRACE_HitNone)
						Debug.Color1 = "Red";
					Else
						Debug.Color1 = "Green";
					KAI_LOFRaycast.VisualizeTracePath (Pos,Data.HitLocation,Data.Distance,16,Debug);
				}
				
				//Special treatment, treat hit skies as if we hit nothing and return a different HitLocation.
				If (!(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
					{Xs.Push (Data.HitLocation.X); Ys.Push (Data.HitLocation.Y); Zs.Push (Data.HitLocation.Z);}
				Else
				{
					Vector3 AltHitPos = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D (Ang,-Pit,Distance));
					Xs.Push (AltHitPos.X); Ys.Push (AltHitPos.Y); Zs.Push (AltHitPos.Z);
				}
				If (Data.HitType != TRACE_HitNone && !(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
				{
					If (MinDist > 0 && MinDist > Data.Distance)
						Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
					Dists.Push(Data.Distance);
					DistSum += Data.Distance;
				}
				Ang += HorzDiv;
			}
			
			If (Pit % 90 ~== 0 && Pit != 0)
				StopHorz = True;
			
			//Run vertical trace for horizontal slice.
			For (Int I = 0; I < VertTraces; I++)
			{
				LineTrace (Normalize180(Ang),Distance,Pit,TRF_BLOCKSELF,0.1,data:Data);
				If (KAI_Debug3DObstacleCheck)
				{
					If (Data.HitType != TRACE_HitNone)
						Debug.Color1 = "Red";
					Else
						Debug.Color1 = "Green";
					KAI_LOFRaycast.VisualizeTracePath (Pos,Data.HitLocation,Data.Distance,16,Debug);
				}
				
				//Special treatment, treat hit skies as if we hit nothing and return a different HitLocation.
				If (!(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
					{Xs.Push (Data.HitLocation.X); Ys.Push (Data.HitLocation.Y); Zs.Push (Data.HitLocation.Z);}
				Else
				{
					Vector3 AltHitPos = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D (Ang,-Pit,Distance));
					Xs.Push (AltHitPos.X); Ys.Push (AltHitPos.Y); Zs.Push (AltHitPos.Z);
				}
				If (Data.HitType != TRACE_HitNone && !(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
				{
					If (MinDist > 0 && MinDist > Data.Distance)
						Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
					Dists.Push(Data.Distance);
					DistSum += Data.Distance;
				}
				Pit += VertDiv;
				If (!(Pit % 90 ~== 0 && Pit != 0))
					StopHorz = False;
			}
		}
		
		Vector3 Sum, Average;
		//Add sums of vector components.
		For (Int I = 0; I < Xs.Size(); I++)
		{
			Sum.X += Xs[I]; Sum.Y += Ys[I]; Sum.Z += Zs[I];
		}
		
		//Average all coordinates. Use ValidAngs instead of HorzDiv to filter out angles that were done because they were aiming straight up or down.
		Average.X = Sum.X/Xs.Size(); Average.Y = Sum.Y/Ys.Size(); Average.Z = Sum.Z/Zs.Size();
		Double AvgDist = DistSum != 0 ? (DistSum/Dists.Size()) : Double.NaN;
		//Set magnitude on positioning relative to the origin. Negative magnitudes scale between the value specified and 1, based on the distance param and averaged second return.
		If (Magnitude < 0 && AvgDist == AvgDist)
		{
			Double Old = Abs(Magnitude);
			Magnitude = KAI_Math.LinearMap (AvgDist,0,Distance,Abs(Magnitude),1);
			If (KAI_Debug3DObstacleCheck)
				Console.Printf ("Dynamic magnitude is %.2f with a max of %.2f",magnitude,old);
		}
		Vector3 RelAv = Level.Vec3Diff (Pos,Average)*Abs(Magnitude);
		Average = Level.Vec3Offset (Pos,RelAv);
		
		If (!KAI_Debug3DObstacleCheck)
		{
			Console.Printf ("Sum of all coordinates is %.2f %.2f %.2f, average is %.2f %.2f %.2f, actual pos is %.2f %.2f %.2f",Sum,Average,Pos);
			If (Dists.Size() != 0) Console.Printf ("Average distance of all traces that were blocked is %.2f",DistSum/Dists.Size());
			KAI_DebugPointDelay.KAI_TempPointSpawn(Average,KAI_Debug3DObstacleCheck);
		}
		
		//The average is too close to the current position.
		If (Threshold > 0 && Level.Vec3Diff (Pos,Average).Length() < Threshold)
			Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN;
		Else
			Return Average, AvgDist;
	}
	
	//Makes the NPC wander around aimlessly.
	//Attempts: How many positions to try per next position picked.
	//MoveRad: The radius around which to find a viable position to move to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move to.
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_Wander (Int Attempts = 24, Double MoveRad = 256, Int MaxSteps = 72, Double DetourFactor = 0.5, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		Int Friend = KAI_GetFriendPlayer();
		If (!OnWander()) //Virtual callback
			Return;
		
		//Friendly monsters follow the player they work for by default.
		If (bFriendly && !bDontFollowPlayers && PlayerInGame[Friend] && Players[Friend].Mo)
		{
			KAI_MoveTowards (Players[Friend].Mo.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		NextMovePos = FindRandomMovePos (Pos,Attempts,MoveRad,FRMP_RANDOM,(Flags & KMT_3D)); //Pick a random position to go to.
	}
	
	Enum MoveAwayFlags
	{
		KMA_STRAIGHT	= 1 << 0, //Move in a straight line away from the Other actor, like A_Chase, instead of using the furthest random position around you.
	}
	
	//Moves the caller AWAY from another actor.
	//Other: The actor to move away from.
	//Attempts: How many positions to try per next position picked.
	//RunRad: The radius around which to find a viable position to run away to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move away to.
	//KMAFlags: The flags unique to KAI_MoveAway.
	//TargPos: If this is set to a non-NaN value. This position vector will be used directly instead of the Other pointer.
	/*ExtraParams: This is a KAIMoveParams struct, KAI_MoveAway() only cares for the obstacle avoidance and corner checking parameters.
	And also the KAI_MoveTowards() PitchLimit. So that I don't need to shoehorn even more parameters in this damn function.*/
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_MoveAway (Actor Other, Int Attempts = 32, Double RunRad = 128, Int MaxSteps = 32, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0,
	Int KMAFlags = 0, Vector3 TargPos = (Double.NaN, Double.NaN, Double.NaN), KAIMoveParams ExtraParams = Null)
	{
		If (!Other && KAI_Math.IsEmptyVector3(TargPos))
		{
			If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Premptively stopping execution");
			Return;
		}
		
		//HACK: Thanks GZDoom :D!
		If (!ExtraParams)
		{
			KAIMoveParams Default_Params;
			/*Default_Params.CornerDist = 0;
			Default_Params.CornerDiv = 0;
			Default_Params.ObstacleDist = 0.0;
			Default_Params.ObstacleSlices = 0;
			Default_Params.ObstacleDiv = 0;
			Default_Params.ObstacleThreshold = 5;
			Default_Params.ObstacleMagnitude = 1;*/
			Default_Params.PitchLimit = 40;
			KAI_MoveAway (Other, Attempts, RunRad, MaxSteps, DetourFactor, AngleLimit, ChaseFlags, Flags, KMAFlags, TargPos, Default_Params);
			Return;
		}
		
		Vector3 RunPos = Other ? Other.Pos : TargPos;
		
		//Got a goal to head to, no time to get spooked.
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
		{
			KAI_MoveTowards (Goal.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags, ExtraParams.PitchLimit);
			Return;
		}
		
		//2D obstacle avoidance
		If (!(Flags & KMT_3D))
		{
			Vector3 ObstacleAvoidPos; Bool UseObstacleAvoidPos;
			[ObstacleAvoidPos, UseObstacleAvoidPos] = KAI_AvoidObstacles (ExtraParams.ObstacleDist, ExtraParams.ObstacleSlices, Radius,RunPos);
			//Use the obstacle avoid pos if it's valid, and also not basically your current position, to prevent walking in place.
			If (UseObstacleAvoidPos && !KAI_Math.IsEmptyVector3(ObstacleAvoidPos) && Level.Vec3Diff (ObstacleAvoidPos,Pos).Length() >= MeleeRange)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Going to ObstacleAvoidPos %d %d %d",ObstacleAvoidPos);
				NextMovePos = ObstacleAvoidPos;
				Return;
			}
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Walking to NextMovePos %d %d %d",nextmovepos);
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags,ExtraParams.PitchLimit);
			//3D obstacle avoidance.
			If (Flags & KMT_3D)
			{
				//Shortest KAI function call.
				Vector3 ObsVec = KAI_AvoidObstacles3D (ExtraParams.ObstacleSlices,ExtraParams.ObstacleDiv,ExtraParams.ObstacleDist,ExtraParams.ObstacleThreshold,ExtraParams.ObstacleMagnitude,ExtraParams.ObstacleMinDist);
				//Obstacle(s) nearby, so independently propel us to the averaged position the function gave us.
				If (!KAI_Math.IsEmptyVector3(ObsVec))
				{
					Vector3 ObsVel = KAI_Math.AngleToVector3D (GetAngleToPos (ObsVec,0),-GetPitchToPos(ObsVec,0),ExtraParams.ObstacleSpeed);
					KMT_3D_SpeedLimit (Speed*3,ObsVel);
					console.printf ("moving away from obstacle");
				}
			}
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			If (KAI_DebugPrintMessages) Console.Printf ("movepos reached, nulling");
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		Actor SightTarget = Other;
		
		//Check if the flying NPC could potentially hide at its' ceiling or floor height. If both have no LOS to the target (And are close enough), then whichever is closest.
		If (ExtraParams.KMAHidePlaneDist && SightTarget.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			Double Dist = Abs(ExtraParams.KMAHidePlaneDist);
			Double RealZ = Pos.Z;
			
			//So we can map which ones are good, AND closest if both the floor and ceiling are good.
			Vector2 FloorGood, CeilGood;
			
			//Floor isn't too far down.
			If (Pos.Z - FloorZ <= Dist)
			{
				SetZ (FloorZ);
				//Can see us on the floor, bad.
				If (!SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY))
					FloorGood = (True,Pos.Z - FloorZ);
				SetZ (RealZ);
			}
			
			//Ceiling isn't too far up.
			If (CeilingZ - (Pos.Z+Height) <= Dist)
			{
				SetZ (CeilingZ);
				If (!SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY))
					CeilGood = (True,CeilingZ - (Pos.Z+Height));
				SetZ (RealZ);
			}
			
			//Only return whichever's if both aren't invalid.
			If (FloorGood.X || CeilGood.X)
			{
				Double FinalZ;
				//If only one wasn't beyond the threshold, pick that one.
				If (FloorGood.X || !CeilGood.X) FinalZ = FloorZ;
				Else If (!FloorGood.X && CeilGood.X) FinalZ = CeilingZ;
				Else If (FloorGood.X && CeilGood.X)
				{
					Double Smallest = Min (FloorGood.Y,CeilGood.Y);
					If (Smallest ~== FloorGood.Y)
						FinalZ = FloorZ;
					Else
						FinalZ = CeilingZ;
				}
				NextMovePos = (Pos.XY,FinalZ);
				Return;
			}
		}
		
		Bool DoCornerCheck = (ExtraParams.CornerDist > 0 && (ExtraParams.CornerDiv > 0 || ExtraParams.CornerDiv == -1));
		If (!SightTarget && DoCornerCheck) SightTarget = Spawn ("KAI_TempPoint",TargPos); //Spawn a debug point to check the sight of a TargPos instead for running from a coordinate.
		
		//MAYDO: Add a boolean flag for ExtraParams (And KAI_CheckCorners()) that makes blocking actors also qualify as cover?
		//Try to run behind corners.
		If (DoCornerCheck)
		{
			If (ExtraParams.CornerSlices == 0)
				ExtraParams.CornerSlices = 4;
			Vector3 CornerPos;
			If (!(Flags & KMT_3D))
				CornerPos = KAI_CheckCorners (SightTarget,ExtraParams.CornerDiv,ExtraParams.CornerDist);
			Else
				CornerPos = KAI_CheckCorners3D (SightTarget,ExtraParams.CornerSlices,ExtraParams.CornerDiv,ExtraParams.CornerDist);
			//We have a corner from where we are not visible against whatever we're running from, run back there.
			If (!KAI_Math.IsEmptyVector3(CornerPos))
			{
				NextMovePos = CornerPos;
				Return;
			}
		}
		
		If (!(KMAFlags & KMA_STRAIGHT))
			NextMovePos = FindRandomMovePos (RunPos,Attempts,RunRad,FRMP_FURTHEST,Flags & KMT_3D); //Pick whichever position is the furthest from RunPos.
		//Run in the exact opposite direction of the target.
		Else
		{
			NextMovePos.XY = Vec2Angle (RunRad,GetAngleToPos(RunPos,0)-180);
			If (!(Flags & KMT_3D))
			{
				//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2),Level.Vec3Diff (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2)).Length());
				NextMovePos.Z = GetZAt (NextMovePos.X,NextMovePos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			//Use AngleToVector3D for getting the opposite pitch vector.
			Else
			{
				Double PitchTo = GetPitchToPos (RunPos,0); //Do NOT "-" the pitch since it's specifically meant to be the exact opposite pitch.
				Vector3 Vec = KAI_Math.AngleToVector3D (0,PitchTo,RunRad);
				NextMovePos.Z = Pos.Z + Vec.Z;
			}
		}
	}
	
	//Checks to the left and right of the caller for a position from where Targ can't see them. And returns it.
	//Targ: The actor (Or rather, the coordinate in general) from which we are running from, used for sight checks.
	//Divisions: How many split steps from the callers' origin to the left/rightmost position are done. i.e 32 steps with a distance of 512 is on check every 16MU.
	//Distance: The left/rightmost distance from the actor checked.
	Vector3 KAI_CheckCorners (Actor Targ, UInt Divisions, Double Distance)
	{
		//If we already have no line of sight to whatever we're supposed to be running from then well...
		If (Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			//Project a line of checks from the origin of the calling actor all the way out to the maximum length of CornerDist. Finding the closest corner.
			Vector3 RealPos = Pos;
			Double CheckLength = Distance;
			Double Division = (Distance/Divisions);
			console.printf ("doing corner check");
			
			//Check your left.
			Vector3 LeftPos;
			/*Note: If I = 0 and I < Distance. Then the first check is ran at the current NPC position instead of Division MU away,
			and the max distance away is skipped (i.e if the ckeck is set to check 394 MU on each side with a division of 12, it checks only 352MU away, AKA 384-32)*/
			For (Double I = Division; I < Distance+Division; I += Division)
			{
				LeftPos = Vec3Angle (I,Angle-90);
				If (KAI_DebugPrintMessages) console.printf ("left corner check is %.2f MU away from actual pos",level.vec3diff (leftpos,pos).length());
				SetOrigin (LeftPos, True);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool LeftSight = Targ.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, True);
				If (!LeftSight && Level.Vec3Diff (Pos,LeftPos).Length() >= MeleeRange && IsPosReachable (LeftPos,spacing:Speed,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my left corner.");
					Return LeftPos; //Move to the left.
				}
			}
			
			//Check your right.
			Vector3 RightPos;
			For (Double I = Division; I < Distance+Division; I += Division)
			{
				RightPos = Vec3Angle (I,Angle+90);
				If (KAI_DebugPrintMessages) console.printf ("right corner check is %.2f MU away from actual pos",level.vec3diff (rightpos,pos).length());
				SetOrigin (RightPos, True);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool RightSight = Targ.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, True);
				If (!RightSight && Level.Vec3Diff (Pos,RightPos).Length() > MeleeRange && IsPosReachable (RightPos,spacing:Speed,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my right corner.");
					Return RightPos; //Move to the left.
				}
			}
		}
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	//Works similar to its' 2D/land counterpart. Except that it fires a fan of checks around the caller. To allow it to also find vertical and diagonal corners.
	//Targ, Divisions, Distance: Works like its' 2D counterpart.
	//Slices: The slices that the clock-like pattern around the caller is split to. Similar to the slices in KAI_AvoidObstacles().
	//StartUp: By default the checks are fired from under the actor, this makes them start from above them. For biasing the check towards the ceiling instead.
	//Counterlockwise: By default the checks move left to right like a clock, this inverts that. For biasing the check towards the right.
	Vector3 KAI_CheckCorners3D (Actor Targ, UInt Slices, UInt Divisions, Double Distance, Bool StartUp = False, Bool Counterclockwise = False)
	{
		If (Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			Vector3 RealPos = Pos;
			
			Double Offset = 360/Slices;
			Vector3 Offs = (0,0,-Offset);
			If (StartUp)
				Offs.Z = Abs(Offs.Z);
			
			//Rotate the "clock".
			For (UInt I = 0; I < Slices; I++)
			{
				Double CRoll = Offs.Z*I;
				If (Counterclockwise)
					CRoll = -CRoll;
				Quat Base = Quat.FromAngles (GetAngleToPos(Targ.Pos,0),0,CRoll);
				Vector3 Dest;
				//Offs.Y += Offs.Y; //Increment for every slice.
				Double Division = (Distance/Divisions);
				Vector3 Rotated = Base * (0,0,Division);
				
				//Check slice.
				Int Iter;
				For (Double D = Division; D < Distance+Division; D += Division)
				{
					Iter++;
					Vector3 CheckPos;
					
					Dest = Level.Vec3Offset (Pos,Rotated*Iter);
					
					//This is out of bounds, get rid of it for performance.
					If (!Level.IsPointInLevel(Dest))
						Continue;
					
					CheckPos = Dest;
					SetOrigin (Dest,True);
					Bool Sight = Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY);
					SetOrigin (RealPos,True);
					If (KAI_Debug3DCornerCheck)
						KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_Debug3DCornerCheck);
					
					If (!Sight && Level.Vec3Diff (Pos,CheckPos).Length() > MeleeRange && IsPosReachable3D (CheckPos,spacing:Radius*2,ignoreactors:True))
					{
						If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind 3D corner.");
						Return CheckPos; 
					}
				}
			}
		}
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	//Fires a row of IsPosReachable checks around the actor. And if the first check isn't blocked, returns which unblock avoid position is further from Targ.
	//If there's no Targ, it just returns the first unblocked position it finds.
	//CheckDist: How far away the checks extend.
	//CheckSlices: How many checks are fired around the actor. (i.e at 16, it'll do one check per 22.5 degrees until it finds a reachable position).
	//CheckSpacing: The spacing of the IsPosReachable checks.
	//Targ: If this isn't NaN, the function gets all valid checks, and picks the furthest one as the unblocked position for the actor to go to.
	Vector3, Bool KAI_AvoidObstacles (Double CheckDist, Double CheckSlices, Double CheckSpacing, Vector3 Targ = (Double.NaN,Double.NaN,Double.NaN))
	{
		If (CheckDist <= 0 || CheckSlices <= 0) Return (Double.NaN, Double.NaN, Double.NaN), False;
		Bool UseObstacleAvoidPos; //If on, the position passed in CheckPos will be used.
		Double CheckAngle = GetAngleToPos(NextMovePos,0); //Try at the NextMovePos, unless blocked.
		Vector3 CheckPos = (Vec2Angle (Radius+CheckDist,CheckAngle),0);
		CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
		
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		
		Vector3 FinalPos = (Double.NaN,Double.NaN,Double.NaN);
		//MAYDO: Make the code somehow ignore actors a vehicle can push away ? This would require reverting to using line traces.
		If (CheckDist > 0 && CheckSlices > 0)
		{
			//If (KAI_DebugPrintMessages) Console.Printf ("KAI_AvoidObstacles: Using basic obstacle avoiding algorithm with a distance of %.2f and %d slices",CheckDist,CheckSlices);
			//FLineTraceData PathCheck;
			//Check an arbitrary angles around the vehicle for a valid path. Ooga booga caveman pathfinding.
			For (Int I = 0; I < CheckSlices; I++)
			{
				If (IsPosReachable (CheckPos,spacing:CheckSpacing))
				{
					//Our current heading is good.
					If (I == 0)
						Return FinalPos, UseObstacleAvoidPos;
					If (KAI_DebugObstacleAvoid) KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_DebugObstacleAvoid);
					
					//Subtract the extra distance to check ahead of from the final move position.
					CheckPos.XY = Vec2Angle (CheckDist,CheckAngle);
					CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
					
					Xs.Push (CheckPos.X); Ys.Push (CheckPos.Y); Zs.Push (CheckPos.Z); //Epic GZDoom fail.
					console.printf ("added reachable pos to array for later use");
				}
				Else
				{
					If (KAI_DebugPrintMessages) Console.Printf ("%d %d %d isn't reachable, adjusting movepos",CheckPos);
					If (KAI_DebugObstacleAvoid)
					{
						Let Debug = KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_DebugObstacleAvoid);
						If (Debug) Debug.A_SetTranslation ('KAI_DebugRed');
					}
					UseObstacleAvoidPos = True;
					//There's an obstacle in front of this path, try another angle.
				}
				CheckAngle += 360/CheckSlices; //Next angle.
				CheckPos.XY = (Vec2Angle (Radius+CheckDist,CheckAngle));
				CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			
			If (!KAI_Math.IsEmptyVector3(Targ))
			{
				Double FurthestDistance;
				Vector3 CurPos;
				For (Int I = Xs.Size()-1; I >= 0; I--)
				{
					CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
					Double CurrentDistance = Level.Vec3Diff (Targ,CurPos).LengthSquared();
					If (FurthestDistance < CurrentDistance)
					{
						FurthestDistance = CurrentDistance;
						FinalPos = CurPos;
					}
				}
			}
			//No position to pick the furthest unblocked position from, so just return the first one.
			Else
				Return (Xs[0],Ys[0],Zs[0]), UseObstacleAvoidPos;
		}
		
		If (KAI_DebugObstacleAvoid && !KAI_Math.IsEmptyVector3(FinalPos))
		{
			Let Debug = KAI_DebugPointDelay.KAI_TempPointSpawn(FinalPos,KAI_DebugObstacleAvoid);
			If (Debug) Debug.Scale *= 3;
		}
		Return FinalPos, UseObstacleAvoidPos;
	}
	
	Enum FindMovePosFilters
	{
		FRMP_FURTHEST	= 1 << 0, //Pick the furthest of all available positions to move to. This is the default.
		FRMP_CLOSEST	= 1 << 1, //Pick the closest of all available positions to move to.
		FRMP_RANDOM		= 1 << 2, //Pick a random position out of all the viable ones found.
	}
	
	//Find a random position that the caller can actually move to.
	//RelativeTo: Which position should the distance checks be performed to ? Needed for the Furthest and Closest filters.
	//Attempts: How many random positions should be produced ? The more you add, the more heavy the function becomes. (Obviously)
	//CheckRad: What is the maximum radius around which random positions can be produced ?
	//Filter: What position are we looking for exactly ? Look above for a list of filters. These are NOT to be used as flags that stack !
	//Full3D: Generate fully 3D positions instead of alligning Z to the floor. For flying actors.
	Vector3 FindRandomMovePos (Vector3 RelativeTo = (Double.NaN, Double.NaN, Double.NaN), Int Attempts = 32, Double CheckRad = 128, Int Filter = FRMP_FURTHEST, bool Full3D = False)
	{
		If (Filter == 0) Filter = FRMP_FURTHEST;
		
		//HACK: ZScript can't use Vector3 arrays. Because the only thing more dysfunctional than my code is the ZScript VM itself.
		//Nothing better than triple the amount of needed array accesses to slow an already expensive function down even more.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Vector3 CurPos; //The position we are currently checking. Reconstructed from the above arrays.
		
		For (Int I = 0; I <= Attempts; I++)
		{
			CurPos = Vec3Offset (FRandom(CheckRad,-CheckRad),FRandom(CheckRad,-CheckRad),Full3D ? FRandom(CheckRad,-CheckRad) : 0);
			If (!Full3D) CurPos.Z = GetZAt (CurPos.X,CurPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			Xs.Push (CurPos.X); Ys.Push (CurPos.Y); Zs.Push (CurPos.Z); //Epic GZDoom fail.
		}
		
		Actor SightTarget = Spawn ("KAI_TempPoint",Pos);
		For (Int I = Attempts-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			SightTarget.SetXYZ (CurPos); //Move the target to the pos for the visibility check.
			//If it's out of bounds, not visible, or can't be walked to. We can't go there. So remove that potential position.
			If (!Level.IsPointInLevel (CurPos) || !CheckSight(SightTarget,SF_IGNOREVISIBILITY) || !IsPosReachable (CurPos))
			{
				Xs.Delete (I); Ys.Delete(I); Zs.Delete(I);
			}
			//else {actor mo = spawn ("candlestick",curpos); mo.bnogravity = true;} //EPIC WIN !!!!!!!!!!!!
			//For 3D positioning. Move down points that can't be directly reached due to the callers' height.
			If (Full3D && (CurPos.Z + Height) > CeilingZ)
				Zs[I] = CeilingZ-Height;
		}
		SightTarget.Destroy();
		
		//No valid positions found, return null.
		If (Xs.Size() == 0)
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Return a random position, this filter is checked first to at least make wandering NPCs a bit cheaper.
		If (Filter == FRMP_RANDOM)
		{
			Int RNGesus = Random (0,Xs.Size()-1);
			Return (Xs[RNGesus],Ys[RNGesus],Zs[RNGesus]);
		}
		//Return the furthest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_FURTHEST)
		{
			Double FurthestDistance;
			Vector3 FurthestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (FurthestDistance < CurrentDistance)
				{
					FurthestDistance = CurrentDistance;
					FurthestPos = CurPos;
				}
			}
			Return FurthestPos;
		}
		//Return the closest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_CLOSEST)
		{
			Double NearestDistance = INT.MAX;
			Vector3 NearestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestPos = CurPos;
				}
			}
			Return NearestPos;
		}
		
		Return (Double.NaN, Double.NaN, Double.NaN); //Return null position if all the above failed.
	}
	
	//BUG: For some reason the function will sometimes return positions that are behind drops too tall for the caller as valid. I have no fucking idea why.
	//BUG: It's not portal aware, because of course it isn't ! DESPITE LITERALLY CHECKING BY *ACTUALLY* MOVING THE CALLER IN A STRAIGHT LINE !
	//BUG: God, why is a function that literally walks the caller forward so fucking hard.
	//NOTE: A potential fix might be making Vec3Offset absolute, it should at least fix portals, since it fixed movement through them for KAI_MoveTowards.
	//Checks if the straight line between the callers' position and the specified position can be walked up to.
	//TargetPos: The position to check if it's walkable.
	/*DistCutoff: The amount of map units to trim off the distance between the callers' pos and TargetPos. Useful for subtracting the radius of another actor,
	so that if you are checking if a position to another actor can be reached, the check doesn't return false because the actor itself is in the way !*/
	//Spacing: The spacing of the move checks. Default is 0, which means that the spacing is the diameter of the callers' hitbox.
	//IgnoreActors: Makes' the check ignore blocking actors entirely.
	//Dropoff: The Dropoff value passed to TryMove().
	Bool IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False, Int Dropoff = 1, Bool Full3D = False)
	{
		If (Full3D)
			Return IsPosReachable3D(TargetPos,DistCutoff,Spacing,IgnoreActors);
		Vector3 OldPos = Pos;
		Bool Interp = bDontInterpolate;
		Bool ThruActs = bThruActors;
		Vector2 Path = Level.Vec2Diff( Pos.XY, TargetPos.XY );
		Double Distance = (Path.Length()-DistCutoff);
		If (Spacing == 0)
			Spacing = Radius*2;
		Distance += Spacing; //HACK: According to RaveYard, apparently the last check in the row might be getting ignored, so this is a simple hack fix.
		If (Distance <= 1) Return False;
		Path /= Distance;
		
		bDontInterpolate = True; //No movement interpolation during the test.
		If (IgnoreActors) bThruActors = True;
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec2Diff (Pos.XY, OldPos.XY).Length() >= Distance) Break; //The check went further than the distance to the target position. Success.
			//Run as many times as it takes between you and your destination.
			FCheckPosition Data;
			Data.FromPMove = True;
			If (TryMove (Level.Vec2Offset(OldPos.XY, Path*I), Dropoff, tm:Data))
			{
				//TODO: Get rid of this SetZ when moving in 3D? Honestly I might need to make totally custom code for flying movement. Using Vec3Diff and CheckPosition().
				SetZ (GetZAt (Pos.X,Pos.Y,flags:GZF_ABSOLUTEPOS)); //HACK: Update the actors' Z position. TryMove should do that internally, but it doesn't. GZDoom moment.
				//actor debug = spawn ("kai_debugpoint",(Level.Vec2Offset(OldPos.XY, Path*I),Pos.Z));
				//debug.scale *= 0.5;
			}
			//If one of them fails, then return false.
			Else
			{If (KAI_DebugPrintMessages)console.printf ("i can't walk to %d %d %d",targetpos);
				bDontInterpolate = Interp;
				bThruActors = ThruActs;
				SetOrigin (OldPos,True);
				Return False;
			}
		}
		bDontInterpolate = Interp;
		bThruActors = ThruActs;
		SetOrigin (OldPos,True);
		Return True; //No TryMove call returned false.
	}
	
	//Called in place of the stock one for flying actors.
	//Works similarly to the normal one. Except that it relies on a row of CheckPosition() calls instead of moving the actor forward.
	Bool IsPosReachable3D (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False)
	{
		Vector3 OldPos = Pos;
		Bool ThruActs = bThruActors;
		If (IgnoreActors) bThruActors = True;
		
		//This is where the fun begins. Get the direction to the target pos, and create a line towards there to iterate.
		Vector3 Path = Level.Vec3Diff(Pos, TargetPos);
		Double Distance = (Path.Length()-DistCutoff);
		If (Spacing == 0)
			Spacing = Radius*2;
		Distance += Spacing; //HACK: According to RaveYard, apparently the last check in the row might be getting ignored, so this is a simple hack fix.
		If (Distance <= 1) Return False;
		Path /= Distance;
		
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec3Diff (Pos, OldPos).Length() >= Distance) Break; //The check went further than the distance to the target position. Success.
			
			//Now, actually check for a bad position.
			FCheckPosition Data;
			Data.FromPMove = True;
			Vector3 CheckPos = Level.Vec3Offset (OldPos,Path*I);
			SetZ (CheckPos.Z); //Set the Z position before the check so CheckPosition's janky ass will hopefully not shit the bed.
			//Spawn ("KAI_DebugPoint",CheckPos);
			If (!CheckPosition(CheckPos.XY,False,Data))
			{
				If (KAI_DebugPrintMessages) Console.Printf ("IsPosReachable3D(): %.2f %.2f %.2f is blocking %p",CheckPos,Self);
				bThruActors = ThruActs;
				SetOrigin(OldPos,True);
				Return False;
			}
		}
		
		bThruActors = ThruActs;
		SetOrigin(OldPos,True);
		Return True;
	}
	
	//Check how big the specified space is for the calling actor. Works by scaling up the actor to the desired size, and seeing if they are blocked by anything.
	//TargetRadius: The radius up to which the function checks if the actor is being blocked.
	//TargetHeight: Ditto, but for the height.
	//Iterations: How many steps is the caller scaled up from their real hitbox, to the hitbox being tested?
	//ActorBlock: Should the function be blocked by actors that would stop the callers' movement as well?
	//Returns after how many iterations it failed, if any, and at what radius and height it failed at.
	Int, Double, Double CheckSpaceSize (Double TargetRadius, Double TargetHeight, Int Iterations = 8, Bool ActorBlock = False)
	{
		Double RealRadius = Radius; Double RealHeight = Height;
		
		For (Int I = Iterations; I > 0; I--)
		{
			//Skip iterations smaller than the caller, they're expensive.
			If ((TargetRadius/I) <= RealRadius && (TargetHeight/I) <= RealHeight)
				Continue;
			A_SetSize (TargetRadius/I,TargetHeight/I);
			If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Checking if radius %f, height %f, iteration %d is valid",Radius,Height,I);
			Bool Thru = bThruActors;
			If (!ActorBlock) bThruActors = True;
			Bool Success = TestMobjLocation();
			bThruActors = Thru;
			
			If (!Success)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Epic fail");
				Double FailRadius = Radius; Double FailHeight = Height;
				A_SetSize (RealRadius,RealHeight);
				Return I, FailRadius, FailHeight;
			}
		}
		
		A_SetSize (RealRadius,RealHeight);
		Return -1, -1, -1; //Nothing is blocking us.
	}
	
	//=====|Order system|=====\\
	//Sets what order the NPC is currently following.
	//Order: The order to follow from the NPCOrders enum.
	//Increment: If true the NPC simply moves to the next order in the enum, and loops back around once reaching the end.
	//Commander: The actor, if any, ordering the NPC to change orders. If the order is set to ORDER_FOLLOW, they'll become the NPC' master, unless hostile.
	//IgnoreAllegiance: If true, the NPC will accept orders even from enemy actors, but still won't follow them if set to ORDER_FOLLOW.
	//FromACS: Marks this particular call as having being made by ACS_SetMarineOrder(), or just generally called by ACS. DO NOT USE UNLESS YOU ARE CALLING FROM ACS.
	Void SetNPCOrder (NPCOrders Order, Bool Increment = False, Actor Commander = Null, Bool IgnoreAllegiance = False, Bool FromACS = False)
	{
		If (bIgnoreOrders) Return;
		Bool EnemyCommand = IsActorHostile (Commander); //The order is being barked by an enemy.
		Bool LastOrder = CurrentOrder;
		If (Commander && EnemyCommand && !IgnoreAllegiance)
			Return;
		
		Int NewOrder = !Increment ? Order : 0;
		If (Increment)
		{
			NewOrder = CurrentOrder++;
			If (CurrentOrder >= ALLORDERS)
				CurrentOrder = 1;
		}
		If (!OnOrderChange(NewOrder, Increment, Commander, IgnoreAllegiance, FromACS)) //Run additional logic before changing orders.
			Return;
		
		If (Increment)
			CurrentOrder++;
		Else
			CurrentOrder = Order;
		
		If (CurrentOrder >= ALLORDERS) //If the NPCs' current order has reached the end of the list, loop back.
			CurrentOrder = 1;
		
		//If we are set to follow, and we have a commander that is friendly, follow them.
		If (CurrentOrder == ORDER_FOLLOW)
		{//If (KAI_DebugPrintMessages)console.printf ("Okay jolly green retard (%p), is your current order ORDER_FOLLOW ?",self);
			If (bFriendly && Commander == Players[KAI_GetFriendPlayer()].Mo) //If your commander is your friendplayer, remove your master pointer to follow friendplayer.
				Master = Null;
			
			If (Commander && !EnemyCommand && Commander != Players[KAI_GetFriendPlayer()].Mo) //Only set master pointer for non-player commanders.
			{If (KAI_DebugPrintMessages)console.printf ("set ORDER_FOLLOW and master for %p",self);
				Master = Commander;
				If (bFriendly)
					bDontFollowPlayers = True; //Friendly marine needs to follow an actor that isn't the friendplayer, so turn off player following.
			}
			Else If (!Master && !bFriendly && (!Commander || !EnemyCommand)) //We are set to follow but we don't have a (friendly) commander or existing master.
				{If (KAI_DebugPrintMessages)console.printf ("SETTING HOSTILE NPC %p TO ORDER_WANDER",self);CurrentOrder = ORDER_WANDER;}
		}
		
		If (CurrentOrder == ORDER_WANDER && bFriendly) //Friendly wandering NPCs don't follow the player.
			bDontFollowPlayers = True;
		
		//If we are set to follow and have no master or our master is our friend player.
		If (CurrentOrder == ORDER_FOLLOW && bFriendly)
		{
			If (!Master || Master == Players[KAI_GetFriendPlayer()].Mo)
				bDontFollowPlayers = False;
		}
		
		AfterOrderChange(LastOrder, Increment, Commander, IgnoreAllegiance, FromACS);
	}
	
	//This is for map script setups. Used to give orders to NPCS through ACS. For the ACS callback, the Commander is the activator.
	Static Void ACS_SetNPCOrder (Actor Activator, Int NPCTID, NPCOrders Order, Bool Increment, Bool IgnoreAllegiance = False)
	{
		Let NPCSearch = Level.CreateActorIterator (NPCTID,"KAI_Actor"); 
		
		KAI_Actor NPC;
		While ( (NPC = KAI_Actor(NPCSearch.Next())) )
		{
			If (!NPC || NPC.IsDead(NPC)) //Ignore nonexistent or dead NPCs.
				Continue;
			
			If (KAI_DebugPrintMessages)console.printf ("SetNPCOrder() was called from ACS, setting order %d for %p",order,NPC);
			NPC.SetNPCOrder (Order, Increment, Activator, IgnoreAllegiance, True);
		}
	}
	
	//=====|Search functions|=====\\
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= 0) Return Null;
		
		Array <Actor> NearbyEnemies;
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || Mobj.Health >= 10000 || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		Return GetClosestActor (NearbyEnemies,Self.Pos,Range);
	}
	
	//Find a height position (From the three FAF_ positions) at which the NPC can aim at the specified actor with a clear line of sight.
	//Useful for making NPCs aim at a different part of an actor when attacking.
	Int GetFAFAimPos (Actor Other, Vector3 Offset = (0,0,0))
	{
		If (!Other) Return FAF_MIDDLE; //No need to update anything.
		Vector3 OldPos = Other.Pos;
		Vector3 AimDir;
		Vector3 Start = Level.Vec3Offset (Pos,Offset);
		
		//Let's see if the middle of the other actor is hittable first.
		Let Check = New ("KAI_BasicSightCheck"); //Should be cheaper than CheckSight(), probably...
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height/2));
		AimDir = Vec3To (Other);
		Check.Shooter = Self;
		Check.SightTarget = Other;
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_MIDDLE;
		}
		
		//If we are this far that should mean the middle isn't visible, aim for the top.
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height));
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_TOP;
		}
		
		//If that too failed, aim for the bottom.
		Other.SetXYZ (Other.Pos);
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_BOTTOM;
		}
		
		//All else failed, aim to the middle again and return false;
		Return FAF_MIDDLE;
	}
	
	//Get the first NPC group you're in that has a leader in it, otherwise, fall back to returning whatever the first group in the array is.
	//IgnorePlayerLeaders: Ignore checking for the first player group leader and just return the first group.
	KAI_NPCGroup GetFirstPlayerNPCGroup (Bool IgnorePlayerLeaders = False)
	{
		If (!Groups.Size())
			Return Null;
		
		If (!IgnorePlayerLeaders)
		{
			ForEach (Group : Groups) //Focus on the first group you find whose leader is a player. AKA player groups take precedence.
			{
				If (Group && Group.Leader && Group.Leader.Player)
					Return Group;
			}
		}
		
		Return Groups[0]; //Fallback to just following the first group in the list.
	}
	
	//=====|Miscelleneous AI functions|=====\\
	//Makes the caller change their target to NewTarget, also passes which actor shared the target. Also does the needed status changes. Returns true if shared successfully.
	//Sharee: The actor sharing the target.
	//NewTarget: The potential target to have.
	//IgnoreAllegiance: If on, the target will be set even if the Sharee is hostile and/or the NewTarget is friendly.
	Bool KAI_ShareTarget (Actor Sharee, Actor NewTarget, Bool IgnoreAllegiance = False)
	{
		If (NewTarget != Null && !bDormant && !(IsPatrolling (Self) && bChaseGoal) && CanBeTargeted(Self,NewTarget))
		{
			If (!IgnoreAllegiance && (IsActorHostile(Sharee) || !IsActorHostile(NewTarget)))
				Return False;
			
			LastHeard = Target = NewTarget;
			Return True;
		}
		
		Return False;
	}
	
	//A crude replica of the clusterfuck that makes monsters natively able to use push and use lines.
	Bool KAI_NPCUseLines()
	{
		If (bNoTrigger || !BlockingLine) Return False;
       
        If (BlockingLine.Special)
        {
            If (bCanUseWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Use);
                Return True;
            }
            Else If (bCanPushWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Push);
                Return True;
            }
        }
        
        Return False;
	}
	
	Int KAI_GetFriendPlayer()
	{
		If (FriendPlayer != 0)
			Return FriendPlayer-1;
		Else
		{
			If (!Multiplayer)
				Return 0;
		}
		
		Return 0;
	}
	
	//Checks if the actor is in any of the attack states defined, and if it is, it also returns a pointer to that state.
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//ZScript port of this: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2568-2572
	Bool HandleNativeFright()
	{
		If (Target)
			Return (((!target.player || !((target.player.cheats & CF_FRIGHTENING) || (target.bFrightening))) && !(bFrightened)) || Random2[pr_scaredycat]() < 43);
		
		Return False;
	}
	
	//=====|A_Chase exports (Building blocks for custom chase functions)|=====\\
	//The checks A_Chase runs before it begins running the chase code.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2325-2376
	Void KAI_Chase_PreChecks (Int Flags = 0)
	{
		If (bInConversation || bInChase) Return;
		
		//bInChase = True;
		
		//PLAYTEST: I haven't checked if stealth monsters work with the exported A_Chase code.
		If (bStealth)
			VisDir -1;
		
		If (ReactionTime)
			ReactionTime--;
		
		//The latter half hasn't been implemented to mainline GZDoom yet, the bMInvisible flag that is.
		If (Target && (Target.bInvisible/* || Target.bMInvisible*/) && Target != Goal)
			Target = Null;
		
		If (Threshold)
		{
			If (!Target || IsDead (Target))
				Threshold = 0;
			Else
				Threshold--;
		}
		
		//Cocaine mode
		If (Flags && CHF_NIGHTMAREFAST && G_SkillPropertyInt (SKILLP_FASTMONSTERS))
		{
			If (Tics > 3)
			{
				Tics -= Tics/2;
				If (Tics < 3)
					Tics = 3;
			}
		}
		
		If (Target && Target != Goal && (IsDead(Target) || !IsActorHostile(Target)))
			Target = Null;
	}
	
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2401-2432
	//CREDIT: This section of the code was written by Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L74-L106
	//PLAYTEST: No idea if this actually works, or how to test it. It should, it's not only a direct rip, but it was written by someone who knows what they are actually doing (Not inkoalawetrust).
	//Makes friendly monsters using KAI chase functions chase their targets attack- basically just what A_Chase does.
	//It does return true if a new target was found though.
	Bool KAI_Chase_FriendsAttackPlayerEnemies (Int Flags)
	{
		// [RH] Friendly monsters will consider chasing whoever hurts a player if they
		// don't already have a target.
		if (bFRIENDLY && target == null)
		{
			PlayerInfo player;

			if (FriendPlayer != 0)
			{
				player = Players[FriendPlayer - 1];
			}
			else
			{
				int i;
				if (!multiplayer)
				{
					i = 0;
				}
				else for (i = random[newchasedirr](0,255) & (MAXPLAYERS-1); !PlayerInGame[i]; i = (i+1) & (MAXPLAYERS-1))
				{
				}

				player = Players[i];
			}
			if (player.attacker && !IsDead (Player.Attacker) && player.attacker.bSHOOTABLE && random[newchasedirr](0,255) < 80)
			{
				if (!player.attacker.bFRIENDLY ||
					deathmatch && FriendPlayer != 0 && player.attacker.FriendPlayer != 0 &&
					FriendPlayer != player.attacker.FriendPlayer)
				{
					target = player.attacker;
					Return True; //Found a player enemy to attack.
				}
			}
		}
		
		Return False;
	}
	
	//Makes the actor change targets if the current one is unavailable. If no target is found either hang out in the current state or go back to idling.
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2433-2467
	Bool KAI_Chase_Retarget (Int Flags, Bool FriendliesIdle = False)
	{
		If (!Target || !Target.bShootable)
		{
			If (Target && Target.bNonShootable)
			{
				LastEnemy = Target;
				Threshold = 0;
			}
			If (LookForPlayers (True) && Target != Goal)
				Return True;
			If (!Target)
			{
				If (Flags & CHF_DONTIDLE || bFriendly && !FriendliesIdle)
				{
					If (!Target)
					{
						If (!(Flags & CHF_DONTMOVE))
							KAI_Wander();
					}
				}
				Else
					SetIdle(); //Sleepy time
			}
		}
		Return False;
	}
	
	//This is an important one for every chase function of every NPC type. It handles going to patrol points and then heading to the next point in the route.
	//WaitState: The statelabel for the actor to go to if it finds a delayed patrol point. If none is specified, it calls SetState().
	//The rest of the parameters here are what is passed to KAI_MoveTowards
	//This function returns 2 booleans. The first returns true if the goal was changed to the next one in the route, and the second returns true if the actor moved to the goal.
	Bool, Bool KAI_Chase_PatrolHandling (StateLabel WaitState = Null, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (Target == Goal || bChaseGoal && Goal != Null)
		{
			If (KAI_CheckMeleeRange(Goal))
			{
				//Credit: Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L161-L212
				// reached the goal
				ActorIterator iterator = Level.CreateActorIterator(goal.args[0], "PatrolPoint");
				ActorIterator specit = Level.CreateActorIterator(goal.tid, "PatrolSpecial");
				Actor spec;

				// Execute the specials of any PatrolSpecials with the same TID
				// as the goal.
				while ( (spec = specit.Next()) )
				{
					level.ExecuteSpecial(
						spec.special, self, null, false,
						spec.args [0], spec.args [1], spec.args [2], spec.args [3], spec.args [4]
					);
				}

				double lastgoalang = goal.angle;
				int delay;
				actor newgoal = iterator.Next ();
				if (newgoal != null && goal == target)
				{
					delay = newgoal.args[1];
					reactiontime = delay * TICRATE + level.maptime;
				}
				else
				{
					delay = 0;
					reactiontime = Default.reactiontime;
					angle = lastgoalang;
				}
				if (target == goal) target = null;
				bJUSTATTACKED = true;
				if (newgoal != null && delay != 0)
				{
					bINCOMBAT = true;
					If (!WaitState)
						SetIdle();
					Else
						SetStateLabel (WaitState);
				}
				bINCHASE = false;
				goal = newgoal;
				return True, False;
			}
			//We have a goal, go to it.
			If (Goal && Goal == Target)
			{
				KAI_MoveTowards (Goal.Pos,DetourFactor,AngleLimit,ChaseFlags,Flags);
				Return False, True;
			}
		}
		Return False, False;
	}
	
	//Handles the playing of the active sound.
	Bool KAI_Chase_HandleActiveSound (Int Flags, Int Frequency = 3)
	{
		if (!(Flags & CHF_NOPLAYACTIVE) && random[pr_chase](0,255) < Frequency)
		{
			PlayActiveSound();
			Return True;
		}
		Return False;
	}
	
	//This handles Hexens' player boss strafing.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2537-2566
	//StrafeTarget: The actor to strafe relative to, normally this will be the target of course.
	//Flags: the A_Chase flags to pass and check for.
	//ForceStrafe: Force the caller to do a strafe.
	//StrafeRange: How close the StrafeTarget has to be to decide to strafe, default is CLASS_BOSS_STRAFE_RANGE.
	Void KAI_Chase_HandleStrafing (Actor StrafeTarget, Int Flags, Bool ForceStrafe = False, Double StrafeRange = 64*10)
	{
		If (!StrafeTarget) Return; //Nothing to dodge.
		
		If (ForceStrafe || Flags & CHF_FASTCHASE && !(Flags & CHF_DONTMOVE))
		{
			If (ForceStrafe) FastChaseStrafeCount = 0;
			If (FastChaseStrafeCount > 0)
				FastChaseStrafeCount--; //Decrement strafe delay.
			Else
			{
				FastChaseStrafeCount = 0;
				Vel.X = Vel.Y = 0;
				If ((ForceStrafe || Random[pr_chase](0,255) < 100) && Distance2D(StrafeTarget) < StrafeRange)
				{
					Double Ang = AngleTo (StrafeTarget);
					If (Random[pr_chase](0,255) < 128) Ang += 90;
					Else Ang -= 90;
					VelFromAngle (13,Ang);
					FastChaseStrafeCount = 3;
				}
			}
		}
	}
}

//This struct stores parameters passed to KAI_MoveTowards/Away. Used as a simple way to pass all params the functions support from another function that calls them.
//Without cluttering up the other function. i.e for passing additional more detailed parameters for a custom chase function like KAI_LandVehicleChase() does.
//Also used by KAI_MoveAway() to enable and pass custom parameters for the obstacle avoiding and running behind corners.
Struct KAIMoveParams
{
	//KAI_MoveTowards() parameters
	Vector3 TargetPos; //The position to actually move to.
	Double DetourFactor; //A multiplier for how many steps the caller can take around an obstacle before heading straight to the TargetPos again.
	Double AngleLimit; //How much the caller can turn to face their TargetPos per step.
	Double PitchLimit; //Ditto, but for the 3D movement of KMT_3D.
	Int ChaseFlags; //The A_Chase flags KAI_MoveTowards() supports, which are CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	Int Flags; //The functions' own flags, check the KAIMoveTowardsFlags enum for a list of them and what they do.
	
	//KAI_MoveAway() parameters, the function also supports KAI_MoveTowards() parameters, as it's effectivelly a wrapper for it.
	Actor Other; //The actor to run away from.
	Int Attempts; //How many potential points to run to should the function generate. The more you generate the more performance heavy it becomes !
	Double RunRad; //The radius around which additional points should be generated.
	Int MaxSteps; //How many steps trying to move to the current retreat position can the caller take before it picks a new location to run to.
	Int KMAFlags; //The functions' own flags, check the MoveAwayFlags enum for a list of them and what they do.
	Double KMAHidePlaneDist; //If non-0. KMA will check the callers' ceiling and floor heights. And see if they could hide at whichever is closest, if they're under this threshold.
	
	//Additional parameters that need to be passed through this struct to KAI_MoveAway().
	Double CornerDist; //How far away on the left and right sides should the corner running code check around the caller? If this is 0 or less, this is disabled.
	Int CornerDiv;	//How many additional fractional checks should the corner running code do? i.e divinding a CornerDist of 100 by 10 to check every 10 MU.
	Int CornerSlices; //Used by KMA when using KMT_3D movement. Determines how many slices to use for checking corners in a clock-like pattern.
	Double ObstacleDist; //How far ahead should the actor check for obstacles to try moving around from? If set to 0 or less, no obstacle avoidance occurs.
	Int ObstacleSlices; //How many reachability checks should be done around a 360 degree circle? i.e setting this to 16 checks in increments of 22.5 degrees around.
	Int ObstacleDiv; //Used by AvoidObstacles3D, how many vertical (Pitch) slices should the check have?
	Double ObstacleThreshold; //Ditto, makes KMA ignore any positions that are closer to the actors' current position than this threshold distance, i.e to ignore noise.
	Double ObstacleMagnitude; //Ditto, makes KMA increase just how extreme the averaged position to head to is, negative values make it use a special linear scaling factor.
	Double ObstacleSpeed; //The speed at which AvoidObstacles3D pushes the caller away from obstacles.
	Double ObstacleMinDist; //If any trace from AvoidObstacles3D hits something closer than this distance, the function returns NaN. Useful if you want the avoidance to give up if far too close anyway.
}
