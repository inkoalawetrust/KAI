/*EXPLANATION:
//This branch was part of my attempt to make monsters move using actual real momentum by default with this TryMove() replacement.
//However the friction handling was totally fucked no matter what I did. Even after asking RaveYard for help with the issue.
//He couldn't do it either, even when I told him to just try doing it on his own without me interfering, since in practice
//he was the one making this function anyway. But he wasn't able to get friction to work on his own either even with his actual
//knowledge of math. And since nobody else tried helping me with this either. I just gave up on this feature.
//If you think you can do it, feel free to submit a pull request to the library.
*/

/*Here is RaveYard's attempt at doing this on his own without me fucking anything up by the way:
class Pusher : Actor
{
	// https://www.wolframalpha.com/input?i=F%280%29%3Dv%2C+F%28n%29%3D%28F%28n-1%29+*+f%29
	// https://www.wolframalpha.com/input?i=F%280%29%3D0%2C+F%28n%29%3D+F%28n-1%29+%2B+v*+f%5E%28n-1%29
	static double TravelDistance(double f, double v, int n)
	{
		if(f == 1) return v * n;
		return (v * ( f ** n - 1)) / (f - 1);
	}
	
	// https://www.wolframalpha.com/input?i=d+%3D+%28v+%28f%5En+-+1%29%29%2F%28f+-+1%29%2C+solve+v
	static double InitialVelocityRequiredToTravel(double f, double d, int n)
	{
		if(f == 1)
			return d / n; // no friction
			
		double fn = f ** n;
		if(fn == 1)
			fn = 1.000001; // hack
			
		return d * ( f - 1 ) / (fn - 1);
	}

	// [RaveYard]: Good enough ffs
	void Pushby(Vector2 offset, int tics)
	{
		//Console.Printf("Push by: %f", offset.length());
		vel.xy += offset.Unit() * InitialVelocityRequiredToTravel(GetFriction(), offset.Length(), tics);
		//Console.Printf("Estimated travel distance: %f", TravelDistance(GetFriction(), vel.xy.length(), tics));
	}
}

class Derp : Pusher
{
	Vector3 startPos;
	states
	{
		Spawn:
			POSS A 0 nodelay {
				SetZ(floorz);
				startPos = pos;
			
				friction = FRandom(0.1, 1.2);
				
				Console.printf("---------------------\nFriction: %f (%f)", GetFriction(), friction);
				//Console.Printf("est travel dist: %f", TravelDistance(GetFriction(), 8, 35));
			}
			POSS A 35 { int t = Random(1, 70); A_SetTics(t); PushBy((64, 0), t);} // wait
			POSS A 0 {
				let diff = Level.Vec3Diff(startPos, pos);
				
				Console.Printf("Travelled: %f\nVel: %f", diff.length(), vel.length());
			}
			POSS A 35 { int t = Random(1, 70); A_SetTics(t); PushBy((64, 0), t);} // wait
			POSS A 0 {
				let diff = Level.Vec3Diff(startPos, pos);
				
				Console.Printf("Travelled: %f\nVel: %f", diff.length(), vel.length());
			}
			POSS A 35 {
				vel = (0, 0, 0);
				SetOrigin(startPos, true);
			}
			loop;
	}
}

class Derp2 : Pusher
{
	states
	{
		Spawn:
			POSS ABCD 8 {
				PushBy(AngleToVector(AngleTo(players[0].mo), 16), 8);
				angle = VectorAngle(vel.x, vel.y);
			}
			loop;
	}
}
*/

Version "4.10.0"

//CUSTOM CODE TAGS: (Temporary list !)
//DOCUMENT: This bit of code needs documentation. Like these tags, which need to be put in a better place.
//PLAYTEST: The code has been written, but not tested, so it might be buggy.
//URGENT: This is something urgent, likely a bugfix, some really visible debug code I don't want to appear in-game etcetera.
//CREDIT: This is to credit some bit of code or function to someone else. Usually when someone else helps me with writing some code.
//DEBUG: Unlike the defintion on Wikipedia, here this signifies some bit of debugging code, probably something that should be removed or commented out before a full release.
//MAYDO: Unlike TODO, this means that it's something I may or may not do. Hence the name.
//IDEA: This is just an idea for the project. Likely some far away goal that would take a lot of time to implement.

//Uh, add cool license and ASCII art or whatever the fuck here.

//TODO: Okay, there's obviously a fucking lot to do, but here are some mental notes so I don't forget.
/*Add documentation of the code tags used by the project. The tags include the common ones Wikipedia lists (https://en.wikipedia.org/wiki/Comment_(computer_programming)#Tags)
But there are also some I want to make specifically for this codebase, like MAYDO.*/
//Implement a warning zone system similar to the MVPs. But that works for all actors, not just the Smart Marines. Also maybe keep using inventory tokens for it, for non-KAI mod support.

//IDEA:
//Add a projectile array that is updated every time a projectile appears and vanishes from the world. Will probably do this for the active protection system for the MVPs' tank.
//DEBUG DEBUG DEBUG
class TestPinky : KAI_Actor Replaces Demon
{
Default
	{
		Health 150;
		PainChance 180;
		Speed 10;
		Radius 30;
		Height 56;
		Mass 400;
		Monster;
		+FLOORCLIP+missileevenmore;+MISSILEMORE;
		SeeSound "demon/sight";
		AttackSound "demon/melee";
		PainSound "demon/pain";
		DeathSound "demon/death";
		ActiveSound "demon/active";
		Obituary "$OB_DEMONHIT";
		Tag "$FN_DEMON";
	}
	int moves;
	override void postbeginplay(){
	super.postbeginplay(); boldmovement = random (false,true);}
	States
	{
	Spawn:
		SARG AB 10 A_Look;
		Loop;
	See:
		SARG AABBCCDD 2 Fast// A_Chase;
		{
			//If (!done && Target) {done = true;IsPosReachable(Target.Pos,(Target.Radius*2)+(Radius*2)+8);}
			If (Target ) {KAI_MoveTowards (Target.Pos);moves++;}
			
			/*KAI_Chase_PreChecks(0);
			KAI_Chase_Retarget(0);if (goal && target != goal) target = goal;
			if (goal)KAI_MoveTowards(goal.Pos,detourfactor:0.5);
			KAI_Chase_HandleActiveSound(0);
			KAI_Chase_PatrolHandling();*/
			
			//KAI_Wander(32,1024,256);
			//if (target) KAI_MoveAway(target,runrad:256,detourfactor:0.5);
			//A_Chase ("Melee",Null);
		}
		Loop;
	//Shit out plasma balls to test VelInterceptEx().
	Missile:
		TNT1 A 0 A_FaceTarget(0,0);
		SARG EF 4 Fast;// A_FaceTarget;
		SARG G 1 Fast
		{A_FaceTarget(0,0);//A_StartSound ("Vehicle/APC/SmallMGFire",CHAN_WEAPON,CHANF_OVERLAP,1.0,0.4);
			Actor Misl = A_SpawnProjectile ("PlasmaBall",angle:Angle,CMF_AIMDIRECTION,Pitch);
			//Speed it up for science purposes.
			Misl.Speed = 50;
			Misl.Vel3DFromAngle (Misl.Speed,Angle,Pitch);
			//VelIntercept ();
			VelInterceptEx (Misl,(0.4,-0.4),(0.55,-0.55),1024);
			if (!target || isdead(target))a_look();
		}
		Wait;//Goto See;
	}
}

//=====|Library structure|=====\\
/*The most basic NPC class, all types are based on this, land/water/air vehicles, humanoids, flying creatures, you name it. 
So, the code that is meant to be shared by all NPCs also goes here.*/
#Include "ZScript/Bases/Base.zsc"
#Include "ZScript/Bases/AIFunctions.zsc"
#Include "ZScript/Bases/OtherFunctions.zsc"
#Include "ZScript/Bases/OtherCode.zsc"
	
	//The base *land* vehicle class. As of 8/4/2023, this basically a direct rip from a dev build of MVP 0.5.0.
	//Any future vehicle types like air and water vehicles will be based on this.
	#Include "ZScript/Bases/Vehicle/Base.zsc"
	#Include "ZScript/Bases/Vehicle/BaseProp.zsc"
	#Include "ZScript/Bases/Vehicle/CommonFunctions.zsc"
	#Include "ZScript/Bases/Vehicle/TurretFunctions.zsc"
		//Air, sea, etc vehicles.
	
	//The base creature class, for living NPCs like demons and animals.
	#Include "ZScript/Bases/Creature/Base.zsc"
		//The base class for more intelligent creatures, based on KAI_Creature.
		/*This will stay empty until I get around to remaking the Smart Marines. Once the rewrite starts,
		I will begin moving any generic code to this base.*/
		#Include "ZScript/Bases/Humanoid/Base.zsc"