/*KLUDGE: Mixins can't be used by different mods, so this class that contains ALL the mixin code in the KAI library is needed. You need to inherit from this
if you want to make something that's not an NPC, but can still use the mixin code the library includes.*/
Class KAI_MixinActor : Actor Abstract
{
	Mixin KAI_UniversalFunctions;
	Mixin KAI_CheckFunctions;
}

Class KAI_Actor : Actor Abstract
{
	Default
	{
		//Properties
		//These are the default player pawns' dimensions, and also my old Smart Marines' dimensions by extension.
		Radius 16;
		Height 56;
		CameraHeight 48; //I think that's about eye level ?
		Mass 100; //Generally, I (inkoalawetrust) basically measure ZDooms' mass units as 1 unit being 1 kilogram.
		Speed 8;
		FriendlySeeBlocks 48; //4096 map units, longer than the default of 1280 map units.
		MaxTargetRange 8196; //Maximum range the actor can attack enemies from.
		Obituary "%o managed to be killed by an abstract class, congratulations %o, we are all very proud of you. Or maybe a modder forgot to define a custom obituary.";
		KAI_Actor.AggressionMultiplier 1.0;
		
		//Flags
		Monster; //Of course.
		+AvoidHazards; //Obviously this is on by default for an intelligent NPC base. However, from what I've seen in the code and playtested, this flag doesn't actually do anything on its' own.
		+SeeFriendlyMonsters; //Hostile KAI NPCs can see friendly monsters by default.
		+FloorClip;
	}
	
	Mixin KAI_CheckFunctions; //Of course all KAI NPCs have access to the library's check functions.
	
	//=====|Virtual functions|=====\\
	//NOTE: The code on these virtuals is basically just the default. Different base classes will likely add on this base code or replace it entirely.
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay ();
		UserVariableDefaults(); //User variables cannot be handled in BeginPlay().
		NextRetreatPos = (Double.NaN,Double.NaN,Double.NaN); //This should be empty.
		if (!(self is "kai_baseturret"))debugpoint = spawn ("kai_debugpoint",pos);//DEBUG
	}
	actor debugpoint; //DEBUG
	Override Void OnDestroy()
	{
		Super.OnDestroy();
		AttackStates.Clear(); //Clean the array before removal, because the GC can't: https://github.com/ZDoom/gzdoom/issues/2019
	}
	
	Override Void Tick()
	{
		Super.Tick();
		If (IsFrozen()) Return;
		if (!kai_math.isemptyvector3(NextRetreatPos) && debugpoint) debugpoint.setorigin (NextRetreatPos,true); //DEBUG
		//Keeps track of the current targets' position for the target prediction code.
		If (Target && Target.Tics == Target.CurState.Tics)
		{
			LastEnemyPosition = CurrentEnemyPosition;
			CurrentEnemyPosition = Target.Pos;
		}
		Else If (!Target)
			LastEnemyPosition = CurrentEnemyPosition = (Double.NaN,Double.NaN,Double.NaN);
	}
	
	/*Allows actors to define the defaults for their own user variables. This is better than the //$UserDefaultValue editor key,
	because it allows default user variable values to be set for actors that are spawned in-game as well, not just ones placed in UDB*/
	Virtual Void UserVariableDefaults(){}
	
	/*PLAYTEST: For the time being I'm focusing on the vehicles (This code IS a rip from the MVP after all.)
	So I have not actually playtested if the default CanAttack() and ShouldAttack() code works like the native code. Since the vehicles just override it.
	I'll begin putting more attention to the non-vehicle NPC code once I begin rewriting the Smart Marines, to code them more properly this time.*/
	//TODO: Maybe have this check for SECF_NOATTACK sectors ? Or not, since it would trigger vehicles in my MVP to run away from enemies in them.
	//Used by the chase functions of each NPC type to check for all the different methods each actor has to attack.
	Virtual Bool CanAttack()
	{
		If ((MissileState || MeleeState) && !IsDead(Self)) Return True; //Actors just check if they have an attack state and are alive by default. More or less stock ZDoom.
		Return False;
	}
	
	//Called in NPCs' chase functions to handle the unique attack decision code of each actor.
	//This is basically a customizable version of the native attack decision code: https://github.com/ZDoom/gzdoom/blob/e3f8230035f08116d1a62c74aaa78b9c0408df6e/src/playsim/p_enemy.cpp#L2574-L2601
	//NOTE: The virtual needs to do the jump to an attack state itself !
	//NoStateJump: If true, then the actor should not call SetStateLabel.
	Virtual Bool ShouldAttack (Bool NoStateJump = False)
	{
		If (HandleNativeFright())
		{
			If (MeleeState && KAI_CheckMeleeRange (Target))
			{
				If (AttackSound)
					S_StartSound (AttackSound, CHAN_WEAPON, 0, 1, ATTN_NORM);
				
				If (!NoStateJump) SetState (MeleeState);
				Return True;
			}
			
			If (MissileState)
			{
				If (IsFast(Self) && MoveCount)
					Return False;
				
				If (!KAI_CheckMissileRange (Target))
					Return False;
				
				If (!NoStateJump) SetState (MissileState);
				Return True;
			}
		}
		Return False;
	}
	
	//Called when the actor calls KAI_Wander.
	Virtual Void OnWander(){}
	
	//Return the location that the actors' attack will hit at. This is just whatever the targets' position is by default.
	Virtual Vector3 GetAttackLocation()
	{
		If (Target) Return Target.Pos;
		Return (Double.NaN,Double.NaN,Double.NaN); //This is an actual empty vector. Not one that is (0,0,0), but fully null.
	}
	
	//Returns if the other actor should be considered hostile, can be used to define different criteria for hostility. Like if the other actor is targeting the callers' allies, or a specific actor.
	ClearScope Virtual Bool IsActorHostile (Actor Other)
	{
		Return IsHostile(Other);
	}
	
	//Tries to heuristically determine how dangerous another actor is. This is pretty hard to do universally. Since stuff like attacks can't be checked.
	//Other: The actor to check.
	//CheckPlayers: Should the checks factor in players too ? e.g counting players with god or buddha mode as THREAT_UNSTOPPABLE. Useful for say not having NPCs just run away from cheating players.
	//MAYDO: Count players as THREAT_ABOVENORMAL maybe ? Probably not as THREAT_DANGEROUS, since while accurate (They are way smarter after all, unless they are me), it could lead to unwanted behavior.
	ClearScope Virtual Int AssessThreatLevel (Actor Other, Bool CheckPlayers = True)
	{
		If (!Other || IsDead (Other)) Return THREAT_NONE; //Nonexistent or dead actors aren't a problem.
		
		//KAI NPCs can have specific threat levels set, in which case, just return whatever the NPCs' threat level is.
		If (Other Is "KAI_Actor" && KAI_Actor(Other).ThreatLevel != THREAT_ASSESS)
			Return KAI_Actor(Other).ThreatLevel;
		
		//Alternatively, if this is a non-KAI NPC. But has the KAI data token, and that token has a threat level specified, pass that instead.
		Inventory Token = Other.FindInventory ("KAI_DataToken");
		If (!(Other Is "KAI_Actor") && Token && KAI_DataToken(Token).ThreatLevel != THREAT_ASSESS)
			Return KAI_DataToken(Token).ThreatLevel;
		
		//It's not even a player or NPC.
		If (IsInanimateObject (Other))
			Return THREAT_NONE;
		
		//If indestructible. Then the other actor is unstoppable (Obviously)
		If (HasGodMode (Other, !CheckPlayers) || HasBuddha (Other, !CheckPlayers) || IsIndestructible (Other) ||
		//Also unstoppable if, more esoterically, it has NONSHOOTABLE (Hitscans go through), NOBLOCKMAP (Projectiles go through), and NORADIUSDMG (No splash damage)
		//NOTE: If you have any FORCERADIUSDMG attacks, you might want to remove these 3 flag checks. Since your actor can harm an enemy with these properties.
		Other.bNonShootable && Other.bNoBlockmap && Other.bNoRadiusDmg)
			Return THREAT_UNSTOPPABLE;
		
		//If the actor has 2500+ health.
		If ((Other.SpawnHealth() >= 2500 || Other.Health >= 2500) ||
		//Or it's enormous (3.4m tall and 4.5m wide or bigger, larger than the Challenger 2 tank, which is huge).
		(Other.Height >= 110 && Other.Radius >= 72))
			Return THREAT_VERYDANGEROUS;
		//Alternatively, if the actor has as much health as a THREAT_DANGEROUS actor, but can reflect projectiles back at enemies, it's also very dangerous.
		Else If ((Other.SpawnHealth() >= 1000 || Other.Health >= 1000) && Other.bReflective && Other.bAimReflect)
			Return THREAT_VERYDANGEROUS;
		
		//If the actor has 1000+ health. Or 500+ health and deflects projectiles, then it's dangerous.
		If ((Other.SpawnHealth() >= 1000 || Other.Health >= 1000) || (Other.SpawnHealth() >= 500 || Other.Health >= 500) && Other.bReflective)
			Return THREAT_DANGEROUS;
		
		//If the actor has 500+ health.
		If ((Other.SpawnHealth() >= 500 || Other.Health >= 500) ||
		//Or has 100+ health and flies or is fast.
		(Other.SpawnHealth() >= 100 || Other.Health >= 100) && (IsFlying (Other) || Other.Speed >= 15) ||
		//Or is weak, but flies around fast.
		(Other.SpawnHealth() >= 50 || Other.Health >= 50) && IsFlying (Other) && Other.Speed >= 15)
			Return THREAT_ABOVENORMAL;
		
		//If the actor has 100+ health. Or is weak, but fast.
		If ((Other.SpawnHealth() >= 100 || Other.Health >= 100) || (Other.SpawnHealth() >= 20 || Other.Health >= 20) && Other.Speed >= 15)
			Return THREAT_NORMAL;
		
		//If the actor has 50+ health (About as much as an Imp or Chaingunner)
		If ((Other.SpawnHealth() >= 50 || Other.Health >= 50))
			Return THREAT_MILD;
		
		//If the actor has 20+ health. AKA is about as strong as a Shotgunner or Zombieman.
		If ((Other.SpawnHealth() >= 20 || Other.Health >= 20))
			Return THREAT_LOW;
		
		//If the actor has 10 health OR LESS. Or it's health is lower than 20 (As specified right above) and it dies on contact with anything, then it's super weak.
		If ((Other.SpawnHealth() <= 10 || Other.Health <= 10) || Other.bTouchy)
			Return THREAT_VERYLOW;
		
		Return THREAT_NONE; //If it's none of the above, then it's probably not a problem, probably.
	}
	
	//Actor properties and flags.
	Double AggressionMultiplier; //Can be used to further increase the chance of KAI_CheckMissileRange returning true. The LOWER it is the more frequent the attacking.
	Int ThreatLevelThreshold; //If another actors' threat level is at or over this threshold, then the NPC should do some action (Like run away, or be more likely to use stronger attacks).
	Property AggressionMultiplier : AggressionMultiplier;
	Property ThreatLevelThreshold : ThreatLevelThreshold;
	Int ThreatLevel; //The NPCs' predetermined threat level. In its basic form it can be used as just a static value. But you could also dynamically change it, e.g based on what attacks your NPC currently has available.
	Property ThreatLevel : ThreatLevel;
	Private Int NPCFlags;
	FlagDef NoTargetPrediction : NPCFlags, 0; //The NPC will not calculate its' targets' movement and lead its' shots.
	
	//Actor variables
	Array <State> AttackStates; //Can be used to store all of the attack state labels an actor has. Such as for actors with multiple attacks besides a missile and melee attack, like vanilla monsters only have.
	Vector3 LastEnemyPosition; //Used by the target prediction. If the turret has a target with no velocity, it grabs their last position every tick to compare it to the current position.
	Vector3 CurrentEnemyPosition;
	Vector3 NextRetreatPos; //The next position the NPC should retreat back to. Used by KAI_MoveAway().
	Int NewPosStepCount; //How many steps the actor has taken before NextRetreatPos is reset, so the actor will get a new point to move to.
	
	Enum ThreatLevels
	{
		THREAT_ASSESS		= 0, //No threat level specified, this is the default, and means that the threat level is to be determined by the AssessThreatLevel() virtual.
		THREAT_NONE			= 1, //The actor is harmless. e.g a prop or a defenseless enemy
		
		THREAT_VERYLOW		= 2, //The actor poses minimal threat. e.g a mosquito enemy or something
		THREAT_LOW			= 3, //The actor poses little threat. e.g a Zombieman or Shotgunner
		THREAT_MILD			= 4, //The actor is somewhat dangerous. e.g a Chaingunner
		THREAT_NORMAL		= 5, //The actor is an average threat. e.g a Pinky, or Imp
		THREAT_ABOVENORMAL	= 6, //The actor is an above average threat. e.g a Hell Knight, Cacodemon, or Revenant
		THREAT_DANGEROUS	= 7, //The actor is dangerous. e.g a Baron of Hell, Arachnotron or Mancubus
		THREAT_VERYDANGEROUS= 8, //The actor is a major threat. e.g bosses like Cyberdemons and Spider Masterminds
		
		THREAT_UNSTOPPABLE	= 666, //The actor is straight up unstoppable, like an NPC with NODAMAGE, or player with ultimate god mode, a good time to run away.
	}
	
	//Constants
	//Const NullVector = (Double.NaN,Double.NaN,Double.NaN);
}

//TODO: Optimize the fast tracer code by storing the tracers in an array and moving them, instead of spawning new ones every tick.
//IDEA: Make a custom ripping system, where the ripper rips once per actor. Simplifying the damage process, and make it easier to make LOF checks for rippers.
//NOTE: This code is kinda mostly made for bullets and other such projectiles, hence the bullet tracer-like code and deflection system. But can be used for fireballs and the likes just fine !
//The base projectile for KAI actors, it's not necessary to really use this. But it does have some advantages:
//It's based on FastProjectile, so it can properly move both with fast and slow velocities.
/*It's got a toggleable custom trail system. The default trail spawn code for FastProjectile works for actors faster than normal projectiles.
But begins breaking up with truly fast projectiles, this custom trail code doesn't. You can reenable the stock FastProjectile trails.*/
//It has a deflection function, which makes the projectile deflect like a bullet.
//It has code that allows you to change the visual pitch of the projectile based on its' actual pitch. Similar to what KAI_BaseTurret allows for on the vehicle base.
//Has a virtual that is called for each trail spawned, with a pointer to the trail.
Class KAI_BaseProjectile : FastProjectile
{
	Default
	{
		MissileHeight 8;
		KAI_BaseProjectile.TrailLineSpacing 2;
		Projectile;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		If (Target) Species = Target.Species; //MAYDO: Have this rely on a flag ? It's kinda here because of the MVP where it was ripped from.
	}
	
	Override Void Tick ()
	{
		Vector3 OldPos = Pos;
		Super.Tick();
		
		//bMissile is removed when a projectile explodes.
		If (!bMissile || IsFrozen()) Return;
		
		If (TrailDelay)
		{
			TrailDelay--;
			Return;
		}
		
		If (bNoTrailLine) //Used stock FastProjectile trail. Simple as.
		{
			Effect();
			Return;
		}
		
		//CREDIT: Boondorl wrote the original code that draws a line of tracers between the current and previous position.
		If (TrailActor)
		{
			Vector3 Path = Level.Vec3Diff( Pos, OldPos );
			Double Distance = Path.Length();
			If (Distance <= 1) Return;
			Path /= Distance;
			
			Double CurScaleX = ScaleAmountX;
			Double CurScaleY = ScaleAmountY;
			Double CurAlpha = FadeAmount;
			
			For( Double I = InitialTrailsSkipped; I < Distance; I += TrailLineSpacing )
			{
				If (MaxTrails != 0 && MaxTrails <= I) Break; //Too many trail actors.
				
				Let Trail = Spawn(TrailActor,level.Vec3Offset(pos, Path*i));
				If (Trail)
				{
					TrailSpawn (Trail); //Return spawned trail.
					//If it's time to begin scaling and fading the trail.
					If (I >= TrailFadeAndScaleStart)
					{
						Trail.Scale.X += CurScaleX;
						Trail.Scale.Y += CurScaleY;
						Trail.Alpha += CurAlpha;
						CurScaleX += ScaleAmountX;
						CurScaleY += ScaleAmountY;
						CurAlpha += FadeAmount;
					}
				}
			}
		}
	}
	
	//Mostly ripped from the native FastProjectile, with some changes and additions.
	Override Void Effect()
	{
		If (!bNoTrailLine) Return;
		Class<Actor> Trail = TrailActor;
		Actor Act;
		If (Trail != Null)
		{
			Double HitZ = Pos.Z - 8;

			If (HitZ < FloorZ)
			{
				HitZ = FloorZ;
			}
			// Do not clip this offset to the floor.
			HitZ += MissileHeight;
			
			Act = Spawn (Trail, (Pos.XY, HitZ), ALLOW_REPLACE);
			If (Act != Null)
			{
				TrailSpawn (Act);
				If (bGetOwner && Target != Null)
					Act.Target = Target;
				Else
					Act.Target = Self;
				
				//Act.Angle = Angle; //These are handled by TrailSpawn().
				//Act.Pitch = Pitch;
			}
		}
	}
	
	//Returns each trail actor spawned, allowing you to perform per-trail modifications.
	Virtual Void TrailSpawn (Actor Trail)
	{
		If (!Trail) Return;
		
		Trail.Master = Self;
		Trail.Angle = Angle;
		Trail.Pitch = Pitch;
		//Pass trail properties. Only really works for the dedicated trail class in particular, so it only runs if the trail is KAI_Tracer or a child class.
		If (Trail Is "KAI_Tracer")
		{
			KAI_Tracer(Trail).SpawnOffsets.X = SpawnOffsetX;
			KAI_Tracer(Trail).SpawnOffsets.Y = SpawnOffsetY;
			KAI_Tracer(Trail).SpawnOffsets.Z = SpawnOffsetZ;
		}
	}
	
	//DOCUMENT: The actual parameters on this function. Here in the code, and on the GitHub wiki I'll set up once the KAI is tidy and finished enough.
	Bool DeflectProjectile (Actor Victim, Int DeflectChance, Double DamageReductionFactor, Double SlowDownFactor = 0,
	Vector2 RandomAngle = (0,0), Vector2 RandomPitch = (0,0), Double Volume = 1, Double Attenuation = 0.9)
	{
		If (Random (0,255) < DeflectChance) Return False; //Fission mailed.
		
		Int Damage = GetMissileDamage(7,1); //Get your damage, be it a static number or a damage function.
		Victim.DamageMobj (Self,Target,Int(Damage*DamageReductionFactor),DamageType); //Harm the caller even when deflected.
		Angle -= 180; //Turn around.
		Vel *= -1; //Opposite day today
		Speed *= SlowDownFactor; //Slow down by a set amount. Can just be randomized in the parameters instead.
		//Randomize the direction you'll fly to.
		Angle += FRandom (RandomAngle.X,RandomAngle.Y);
		Pitch += FRandom (RandomPitch.X,RandomPitch.Y);
		Vel3DFromAngle (Speed,Angle,Pitch);
		
		//Spark effect.
		//MAYDO: Make the spark effect customizable ? Potentially through an OnDeflection() virtual.
		TextureID NullTex;
		For (Int I = 0; I < 24; I++)
		{
			A_SpawnParticleEx (
			"yellow",
			NullTex,
			STYLE_Add,
			lifetime:23,
			size:3,
			xoff:FRandom (6,-6),
			yoff:FRandom (6,-6),
			zoff:FRandom (6,-6),
			velx:FRandom (1,-1),
			vely:FRandom (1,-1),
			velz:FRandom (1,3),
			accelz: FRandom (-0.1,-0.25)
			);
		}
		Victim.A_StartSound (BounceSound,flags:CHANF_OVERLAP,Volume,Attenuation); //Ricochet sound, uses the BounceSound property, naturally.
		DontCollide = Victim; //You should no longer collide with the actor you just deflected, to avoid getting stuck inside it.
		
		Return True;
	}
	
	//Has different values than UpdateTurretElevation().
	Int UpdateProjectileElevation (Int FaceDown, Int FaceDown2, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 70)
			Return FaceDown2;
		Else If (Pitch >= 30 && Pitch < 70)
			Return FaceDown;
		Else If (Pitch < 30 && Pitch > -30)
			Return FaceStraight;
		Else If (Pitch <= -30 && Pitch > -70)
			Return FaceUp;
		Else If (Pitch <= -70)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	//Is the other actor hostile to the projectiles' shooter ? Useful for SpecialMissileHit checks.
	Bool IsHostileToShooter(Actor Other)
	{
		If (!Target || !Other) Return False;
		
		//KAI NPCs have a custom virtual to check for hostility.
		If (Target Is "KAI_Actor")
			Return KAI_Actor(Target).IsActorHostile (Other);
		
		Return Target.IsHostile (Other); //If not a KAI NPC, use the native IsHostile().
	}
	
	Override Int SpecialMissileHit (Actor Victim)
	{
		If (!Victim || Victim && Victim == DontCollide) Return 1;
		If (bNoFriendlyFire && !IsInanimateObject (Victim) && !IsHostileToShooter (Victim)) Return 1;
		//MAYDO: This makes the now bad assumption that projectile is for vehicles only- actually no. I think this may be fine ?
		//If not, maybe replace this with a dynamic array of specific actors the projectile should't collide with.
		If (Target && Target Is "KAI_BaseTurret" && Victim && Victim == Target.Master) Return 1; //If fired from a turret, ignore the vehicle it's attached on.
		
		Return -1;
	}
	
	Actor DontCollide; //Stores an actor that will be ignored by SpecialMissileHit, so deflected projectiles don't deflect dozens of times when bouncing off. Sorse spaghetti has nothing on Doom spaghet.
	
	Mixin KAI_UniversalFunctions;
	Mixin KAI_CheckFunctions;
	Private Int ProjectileFlags;
	FlagDef NoTrailLine : ProjectileFlags, 0; //The projectile uses the normal FastProjectile trail spawning code.
	FlagDef NoFriendlyFire : ProjectileFlags, 1; //The projectile should not collide with actors friendly to its' shooter.
	Class <Actor> TrailActor;
	Property TrailActor : TrailActor;
	
	Int TrailDelay, MaxTrails, InitialTrailsSkipped, TrailFadeAndScaleStart;
	Property TrailDelay : TrailDelay;
	Property MaxTrails : MaxTrails;
	Property InitialTrailsSkipped : InitialTrailsSkipped;
	Property TrailFadeAndScaleStart : TrailFadeAndScaleStart;
	
	Double TrailLineSpacing;
	Property TrailLineSpacing : TrailLineSpacing;
	
	Double ScaleAmountX, ScaleAmountY, FadeAmount;
	Property ScaleAmountX : ScaleAmountX;
	Property ScaleAmountY : ScaleAmountY;
	Property FadeAmount : FadeAmount;
	
	Double SpawnOffsetX, SpawnOffsetY, SpawnOffsetZ;
	Property SpawnOffsetX : SpawnOffsetX;
	Property SpawnOffsetY : SpawnOffsetY;
	Property SpawnOffsetZ : SpawnOffsetZ;
}

//A generic tracer effect particle.
//MAYDO: A flag to enable state progression ? Maybe not. The entire point is for this actor to be as "light" as ZScript allows.
Class KAI_Tracer : Actor
{
	Default {RenderStyle "Add"; Scale 0.5; ReactionTime 1; +NoBlockmap; +NoInteraction;}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		SetOrigin (KAI_Math.Vec3OffsetRelative (Self,SpawnOffsets),False);
	}
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		//Super.Tick(); //Not needed.
		If (GetAge() >= ReactionTime)
			Destroy();
	}
	
	Vector3 SpawnOffsets;
}

Class KAI_DebugPoint : Actor
{
	Override Void PostBeginPlay(){}
	Override Void Tick(){}
	States
	{
		Spawn:
			PLSS A -1;
			Stop;
	}
}

//PLAYTEST: The token and its' associated ACS API work for simply setting the threat level. But I'm not sure how dynamically changing the tokens' threat level would work for non-KAI actors exactly.
//This inventory token is a surrogate to allow non-KAI NPCs and mods to use certain types of KAI info. Such as threat levels.
//This token is useful for tasks like:
//Adding optional KAI support to your mod without turning your actors into KAI NPCs. And also without needing to make a compatibility patch, or getting startup errors without the library loaded.
/*Making something like an event handler addon that gives specific NPCs tokens with hardcoded threat levels. Like for example giving all Pain Elementals this token,
to specify that Elementals are THREAT_DANGEROUS instead of THREAT_ABOVENORMAL, due to their constant spamming of tanky Lost Souls.*/
Class KAI_DataToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		+Inventory.Quiet;
		+Inventory.Undroppable;
		+Inventory.Unclearable;
		+Inventory.Untossable;
		+Inventory.HubPower;
		+Inventory.NoScreenFlash;
	}
	
	Int ThreatLevel; //The threat level of the tokens' owner.
	
	/*override void attachtoowner (actor other) //DEBUG
	{
		Super.AttachToOwner(Other);
		if (other && other.player)
			ACS_ScriptCall("KAIToken_SetThreatLevel",666);
			//user_threatlevel = 666; //THREAT_UNSTOPPABLE
	}*/
}
//Debug actor to assess the threat level of an actor in front of it, to see if the system works as intended.
class threatassess : kai_Actor replaces gibbedmarineextra
{
states
{
	spawn:
		tnt1 a 1 a_lookex(fov:360);
		loop;
	see:
		tnt1 a 1
		{
			string text;
			switch (AssessThreatLevel (Target))
			{
				case THREAT_VERYDANGEROUS:
					text = "THREAT_VERYDANGEROUS";
					break;
				case THREAT_DANGEROUS:
					text = "THREAT_DANGEROUS";
					break;
				case THREAT_ABOVENORMAL:
					text = "THREAT_ABOVENORMAL";
					break;
				case THREAT_NORMAL:
					text = "THREAT_NORMAL";
					break;
				case THREAT_MILD:
					text = "THREAT_MILD";
					break;
				case THREAT_LOW:
					text = "THREAT_LOW";
					break;
				case THREAT_VERYLOW:
					text = "THREAT_VERYLOW";
					break;
				case THREAT_UNSTOPPABLE:
					text = "THREAT_UNSTOPPABLE";
					break;
				case THREAT_NONE:
					text = "THREAT_NONE";
					break;
				default:
					text = "oops";
					break;
			}
			Console.Printf ("%s threat level:%s",target.getclassname(),text);
		}
		stop;
}
}