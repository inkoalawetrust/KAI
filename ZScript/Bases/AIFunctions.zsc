//$GZDB_SKIP
//AI functions shared by all NPC types.
Extend Class KAI_Actor
{
	//=====|Range checks|=====\\
	Enum KAIRangeCheck
	{
		CMR_NOHITFRIEND	= 1 << 0, //The function should not run the native shit autoaimed P_HitFriend() check. Only useful for KAI_CheckMissileRange.
		CMR_3DDISTANCE	= 1 << 1, //The range check should use Distance3D instead of Distance2D.
		CMR_INVERTDIST	= 1 << 2, //Invert the missile attack chance with distance. Making the NPC MORE likely to attack the further the target is.
		CMR_IGNOREDIST	= 1 << 3, //Ignore the distance check attack chance code for missile attacks entirely.
	}
	
	//Returns true if the caller is in melee range of the other actor. Basically a rip of P_CheckMeleeRange().
	Bool KAI_CheckMeleeRange (Actor Other, Double Range = -1, Int Flags = 0)
	{
		Double Dist;
		
		If (!Other || CurSector.Flags & Sector.SECF_NOATTACK)
			Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other));
		If (Range < 0) Range = MeleeRange;
		
		If (Dist >= Range + Other.Radius)
			Return False;
		
		If (Other == Goal)
			Return True;
		
		If (!bNoVerticalMeleeRange)
		{
			If (Other.Pos.Z > Pos.Z+Height) Return False;
			If (Pos.Z+Height < Other.Pos.Z) Return False;
		}
		
		If (IsFriend (Other))
			Return False;
		
		If (!CheckSight (Other))
			Return False;
		
		Return True;
	}
	
	//The function is more or less the same as its' native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	Bool KAI_CheckMissileRange (Actor Other, Int Flags = 0)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!Other || !CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		If (!(Flags & CMR_NOHITFRIEND) && bFriendly && HitFriend ()) Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other)) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (Flags & CMR_IGNOREDIST) //Skip stupid distance formula.
			Return True;
		
		Dist *= MissileChanceMult; //If CMF_INVERTDIST is on, keep in mind that the behavior of the MissileChanceMult is also effectively inverted !
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		If (!(Flags & CMR_INVERTDIST))
			Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
		Else
			Return Random2[PR_CheckMissileRange]() <= Max(Int(Dist), MMC);
	}
	
	//=====|Sight and locomotion|=====\\
	Enum KAILookFlags
	{
		KAIL_CHASETARGET = 1 << 0, //If the actor already has a target. Then go to the specified see state. For when the internal A_LookEx() doesn't do it itself.
		KAIL_NOTEMPSTAND = 1 << 1, //Should the actor not temporarily stay still if friendly (Not begin moving due to player fire) between A_LookEx() calls ?
	}
	
	//Generic wrapper for A_LookEx shared by all actors.
	//Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label: These properties are all directly transferred to A_LookEx, so  they work the same as in that function.
	//ExtraFlags: The extra flags that modify KAI_Look's behavior. Look above for available flags.
	Void KAI_Look (Int Flags = 0, Double MinSeeDist = 0, Double MaxSeeDist = 0, Double MaxHearDist = 0, Double FOV = 0, StateLabel Label = Null, Int ExtraFlags = 0)
	{
		//HACK: This shit is probably a super hacky way to just get actors that are already targeting an actor in their Spawn state to actually attack it.
		If (!(Flags & LOF_NOJUMP) && ExtraFlags & KAIL_CHASETARGET && Target)
		{
			If (Label)
				SetStateLabel (Label); //Go to specified state.
			Else
				SetState (SeeState); //Go to default See state.
		}
		Bool Stand = bStandStill;
		If (!(ExtraFlags & KAIL_NOTEMPSTAND))
		{
			Stand = bStandStill;
			bStandStill = True;
		}
		A_LookEx (Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label);
		If (!(ExtraFlags & KAIL_NOTEMPSTAND)) bStandStill = Stand;
	}
	
	Enum KAIChaseFlags
	{
		KAIC_FRIENDSIDLE	= 1 << 0, //Basically the opposite of CHF_DONTIDLE. Friendly KAI monsters will ALSO idle like monsters do when they have nothing to chase.
		KAIC_ZIGZAG			= 1 << 1, //Zig-zag on your way to the target. Passed to KAI_MoveTowards().
		KAIC_IGNOREHAZARDS	= 1 << 2, //Don't avoid hazards regardless of bAvoidHazards.
	}
	
	//IDEA: Actually integrate some KAI features into this generic function, whatever I CAN reasonably integrate into one function.
	//MAYBE having KAI_Humanoid callers able to run up to and use emplacements.
	
	//Basic generic chase function for making NPCs go up to their target pointer and attack it. Literally just A_Chase() lite.
	//Melee: An arbitrary state override to go to for melee attacks.
	//Missile: Ditto but for ranged attacks.
	//Wait: When patrolling, the idle state they go to once reachING a point where the actor is supposed to stop.
	//Flags: The vanilla A_Chase flags to use.
	//FlagsEx: The KAI_Chase flags to use.
	//RetreatRange: If a powerful target (One with a threat level over the callers' ThreatLevelThreshod) is over this range, run away unless we're fearless.
	//StrafeDist: Used by the Hexen strafe logic, the target must be at least this close for the NPC to strafe with CHF_FASTCHASE.
	Void KAI_Chase (StateLabel Melee = Null, StateLabel Missile = Null, StateLabel Wait = Null, Int Flags = 0, KAIChaseFlags FlagsEx = 0, Double RetreatRange = 0, Double StrafeDist = 64*10, String Voice = "", KAIMoveParams Extra = Null)
	{
		//HACK: Pass default detail params.
		If (!Extra)
		{
			KAIMoveParams Params;
			//Params.TargetPos //No need to use that... unless I decide to allow for position overrides I guess?
			Params.DetourFactor = 1;
			Params.AngleLimit = 45; //Set it high by default.
			Params.PitchLimit = 0; //No pitch limit.
			//Params.ChaseFlags = ; //Don't need this, that's what the Flags parameter is for.
			//Params.Flags = ; //Ditto, we just expose a few flags like KMT_ZIGZAG and maybe KMT_NOLINEUSE.
			//Retreating parameters
			Params.Attempts = 8;
			Params.RunRad = Radius+64;
			Params.MaxSteps = 16;
			Params.KMAFlags = 0; //Up to you to do KMA_STRAIGHT if you wanna.
			//Everything else are parameters for KMA's built-in support for AvoidObstacles(3D) and CheckCorners(3D), so totally optional.
			
			KAI_Chase (Melee, Missile, Wait, Flags, FlagsEx, RetreatRange, StrafeDist, Voice, Params);
			Return;
		}
		
		KAI_Voice Yapper = KAIHandler ? KAIHandler.GetNPCVoice(Voice) : Null;
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(Flags);
		Bool PreTarg = Target;
		KAI_Chase_FriendsAttackPlayerEnemies(Flags); //If friendly, attack anything that attacked our player. Unless busy already.
		KAI_Chase_Retarget(Flags,FlagsEx & KAIC_FRIENDSIDLE); //Look for new target if we have none right now.
		If (!PreTarg && Target && Yapper && !IsActorPlayingSound (CHAN_VOICE)) //We have seen an enemy from within KAI_Chase() itself.
		{
			If (Target.Player && Yapper.PlayerSee.Size())
				SayVoiceLine (VOICE_PLAYERSEE,Yapper);
			Else
				SayVoiceLine (VOICE_SEE,Yapper);
				
		}
		KAI_Chase_HandleActiveSound(Flags); //rawr xd
		
		//Necromancy
		If (Flags & CHF_RESURRECT && A_CheckForResurrection())
		{
			If (Yapper && !IsActorPlayingSound (CHAN_VOICE)) SayVoiceLine (VOICE_ALLYREVIVE,Yapper);
			Return;
		}
		
		Bool RunAway = (!bNoFear && (IsFrightening (Target) || bFrightened)); //Run away from spooky actors, or maybe we're just a little bitch.
		Double Aggro = MissileChanceMult; //Because it can be temporarily raised to make the NPC far less aggressive when trying to run away with bAvoidMelee.
		//if (runaway) console.printf ("oooh, very scary!");
		
		//Only move to the target if we, you know, have one. What to do if there is none is handed by KAI_Chase_Retarget().
		If (Target && !(Flags & CHF_DONTMOVE))
		{
			//If we're set to run away from targets over our threat threshold that get too close, do so.
			If (!bNoFear && Target != Goal && !RunAway && RetreatRange > 0 && ThreatLevelThreshold != THREAT_ASSESS && Distance3DSquared(Target) <= RetreatRange*RetreatRange &&
			AssessThreatLevel(Target, True) >= ThreatLevelThreshold && CheckSight (Target,SF_IGNOREWATERBOUNDARY))
				RunAway = True;
			
			If (RunAway && Yapper && Random (0,255) < 1 && !IsActorPlayingSound (CHAN_VOICE))
			{
				If (Target.Player && Yapper.PlayerFear.Size())
					SayVoiceLine (VOICE_PLAYERFEAR,Yapper);
				Else
					SayVoiceLine (VOICE_FEAR,Yapper);
			}
			
			KAI_Chase_HandleStrafing (Target,Flags,False,StrafeDist);
			
			Int KMT = (FlagsEx & KAIC_ZIGZAG) ? KMT_ZIGZAG : 0; //Pass KMT_ZIGZAG on.
			If (IsFlying(Self)) //They fly now !?
				KMT |= KMT_3D; //They fly now.
			If (RunAway && KMT & KMT_ZIGZAG)
				KMT &= ~KMT_ZIGZAG; //Don't zigzag when retreating.
			KMT |= KMT_CHASEGOAL;
			
			Bool MovedAlready;
			If (bAvoidHazards && !(Flags & KAIC_IGNOREHAZARDS))
			{
				Int KMAFlags = Extra.KMAFlags; If (!(KMT & KMT_3D)) KMAFlags |= KMA_STRAIGHT;
				//Run from generic harmful sectors. Takes precedence.
				If (IsHarmfulSector (CurSector,Self))
				{
					KMT &= ~KMT_ZIGZAG; KMT &= ~KMT_CHASEGOAL; //Don't zigzag or chase your goal when retreating.
					Vector3 RunPos = (CurSector.CenterSpot,0); //Run from sector center.
					RunPos.Z = GetZAt (RunPos.X,RunPos.Y);
					KAI_MoveAway (Null,Extra.Attempts,Extra.RunRad,Extra.MaxSteps,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,KMAFlags,RunPos,extraparams:Extra);
					MovedAlready = True;
				}
				//And also from KAI hazard areas.
				Else If (Hazards.Size())
				{
					KMT &= ~KMT_ZIGZAG; KMT &= ~KMT_CHASEGOAL; //Don't zigzag or chase your goal when retreating.
					Vector3 HazPos = GetHazardOriginPos (GetNearestHazard(Hazards));
					Speed *= 2;
					KAI_MoveAway (Null,Extra.Attempts,Extra.RunRad,Extra.MaxSteps,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,KMAFlags,HazPos,extraparams:Extra);
					Speed /= 2;
					If (!KAI_Math.IsEmptyVector3(HazPos)) MovedAlready = True;
				}
				If (MovedAlready)
				{
					MissileChanceMult = 4; //Busy trying to live.
					//Yap about hazards.
					If (Yapper && Random (0,255) < 2 && !IsActorPlayingSound (CHAN_VOICE))
						SayVoiceLine (VOICE_HAZARD,Yapper);
				}
			}
			
			Bool B;
			If (!MovedAlready)
				[B,MovedAlready] = KAI_Chase_PatrolHandling (Wait,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,Extra.PitchLimit); //Handle ZDoom patrol routes.
			
			//Avoid melee attackers.
			If (Target && (bAvoidMelee || Level.Info.Flags3 & LEVEL3_AVOIDMELEE))
			{
				Bool IsMeleeAttacker;
				If (!Target.Player && Target.MeleeState) //Melee NPC
				{
					Double Dist = (Target.MeleeRange + Target.Radius)*2;
					IsMeleeAttacker = Distance3DSquared (Target) < Dist*Dist;
				}
				Else If (Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.bMeleeWeapon) //Melee player
					IsMeleeAttacker = Distance3dSquared(Target) <= 192*192;
				
				//Run straight away, regardless of other KMAFlags.
				If (IsMeleeAttacker)
				{
					MissileChanceMult = 3; //Far less likely to attack so we can fuck off.
					Int KMAFlags = Extra.KMAFlags; KMAFlags |= KMA_STRAIGHT;
					KAI_MoveAway (Target,Extra.Attempts,Extra.RunRad,Extra.MaxSteps,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,KMAFlags,extraparams:Extra);
					MovedAlready = True;
				}
			}
			
			If (!MovedAlready && Target)
			{
				If (!RunAway)
					KAI_MoveTowards (Target.Pos,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,Extra.PitchLimit);
				//Running away from something, this is fully customizable, including being able to pass parameters for AvoidObstacles(3D) and CheckCorners(3D).
				Else
					KAI_MoveAway (Target,Extra.Attempts,Extra.RunRad,Extra.MaxSteps,Extra.DetourFactor,Extra.AngleLimit,Flags,KMT,Extra.KMAFlags,extraparams:Extra);
			}
		}
		
		//Decide to attack using the virtuals. But only if not patrolling.
		State RealMelee = MeleeState;
		State RealRange = MissileState;
		//Use custom attack state overrides.
		If (Melee) MeleeState = FindState(Melee,True);
		If (Missile) MissileState = FindState(Missile,True);
		
		If (Target != Goal && CanAttack() && ShouldAttack())
		{
			MissileChanceMult = Aggro;
			MeleeState = RealMelee; //Set states back now that the check is done.
			MissileState = RealRange;
			Return;
		}
		MissileChanceMult = Aggro;
	}
	
	Enum KAIMoveTowardsFlags
	{
		KMT_CHASEGOAL 	= 1 << 0, //If the caller has a goal pointer, and the bChaseGoal flag on. It will follow the goal instead of the TargetPos.
		KMT_ZIGZAG	  	= 1 << 1, //Move around with more A_Chase-esque movement (Like zigzagging), instead of only moving in a straight line.
		KMT_NOLINEUSE 	= 1 << 2, //Disable the function being able to make the monster use crossed over lines at all, in case you want your own code for that.
		KMT_3D		  	= 1 << 3, //The actor should be able to move in full 3D, such as if it's a flying NPC.
	}
	
	Double LastTurnDir;
	Int TurnCount; //Keeps track of how many turns in a row an actor calling KAI_MoveTowards with CHF_NORANDOMTURN should make.
	Vector3 ZigZagPos;
	
	//Makes the actor move towards the specified position.
	//TODO:
	//Add a check for if a vehicles' turret would collide with the next move. And probably find a way to call it recursively for turrets on turrets.
	//One day I should probably add support for vanilla style 8-directional movement. Maybe even 16 angle movement.
	//CREDIT: Original 2D A_Chase-like movement written by Custodian (Beyond Sunset creator). Modified and expanded by me (inkoalawetrust).
	//TargetPos: The position to move to.
	//DetourFactor: How long the actor is allowed to move in a direction after hitting an obstacle, before heading straight for the target again.
	//AngleLimit: How much the actor can turn per step. Used to not have it snap back 180 or anything like that.
	//ChaseFlags: What flags from A_Chase should the function use ? Supports CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	//Flags: The functions' own flags, see above for a list of flags.
	//PitchLimit: How much the actors' pitch can change per call. Used by KMT_3D to limit how much the actor moves up and down, effectively.
	Void KAI_MoveTowards (Vector3 TargetPos, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		If (ChaseFlags & CHF_DONTMOVE || KAI_Math.IsEmptyVector3 (TargetPos)) Return;
		
		//Basically does what P_NewChaseDir() does to handle Thing_SetGoal's "Don't chase target" flag: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L943-946
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
			TargetPos = Goal.Pos;
		
		//Handle making the NPC zig zag in a manner similar to KAI_MoveAway.
		If (Flags & KMT_ZIGZAG)
		{
			If (NewPosStepCount <= 32 && Level.Vec3Diff (Pos,ZigZagPos).Length() >= MeleeRange)
			{
				If (!KAI_Math.IsEmptyVector3 (ZigZagPos))
					TargetPos = ZigZagPos;
				NewPosStepCount++;
			}
			Else
			{
				ZigZagPos = FindRandomMovePos (TargetPos,16,256,FRMP_CLOSEST,(Flags & KMT_3D));
				NewPosStepCount = 0;
			}
		}
		Else
			ZigZagPos = (Double.NaN,Double.NaN,Double.NaN);
		
		//The function works with the CANTLEAVEFLOORPIC flag as well.
		TextureID OldFloor = FloorPic;
		
		double LastAngle = Angle;
		double NextAngle = LastAngle;
		Bool IsVehicle = (Self Is "KAI_BaseVehicle");
		Bool TurretBlock; //Is this movement blocked because one of the turrets' would collide with something?
		
		//MoveCount is greater than 0 when avoiding an obstacle
		if (MoveCount)
		{
			MoveCount--;
		}
		else
		{
			lastturndir = 0;
			//move directly towards Other
			if (!(ChaseFlags & CHF_NORANDOMTURN)) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		}
		
		//When CHF_NORANDOMTURN is on. The actor can take a set amount of turns before no longer turning to face its' target.
		If (ChaseFlags & CHF_NORANDOMTURN && --TurnCount > 0) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		
		Double NextPitch = Pitch; //Used by 3D movement.
		
		//Normal 2D TryMove() movement.
		If (!(Flags & KMT_3D))
		{
			bInFloat = False; //Just in case.
			
			//absolute position of next movement
			vector2 NextPos = Vec2Angle(speed, NextAngle, True);
			FCheckPosition Move;
			Move.FromPMove = True; //Move anyways if there's an actor within your hitbox already.
			If (IsVehicle) //Vehicle push and crush handling.
			{
				Let Vehicle = KAI_BaseVehicle(Self);
				Array <Actor> Pushovers;
				KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
				KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
				//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
			}
			//if (turretblock) console.printf ("DING DING DING TURRET IN THE WAY!");
			//else if (isvehicle) console.printf ("the turrets of %p aren't getting on their way",self);
			//If (!(Flags & KMT_NOLINEUSE)) {a_log ("lemme try opening this door");CheckMonsterUseSpecials ();}
			bool moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			
			//if I hit an obstacle while avoiding another, try moving straight towards Other
			if (!moved && MoveCount || bCantLeaveFloorPic && FloorPic != OldFloor)
			{
				If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
				MoveCount = Int(random(16,32)*DetourFactor);
				NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				NextPos = Vec2Angle(speed, NextAngle, True);
				If (IsVehicle) //Vehicle push and crush handling.
				{
					Let Vehicle = KAI_BaseVehicle(Self);
					Array <Actor> Pushovers;
					KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
					KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
					//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
				}
				moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
			}
			
			//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
			If (!moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
			{
				Switch (AngleLimit)
				{
					Case 20:
						TurnCount = Random (2,4);
						Break;
					Case 10:
						TurnCount = Random (3,6);
						Break;
					Case 5:
						TurnCount = Random (8,12);
						Break;
					Default:
						Break;
				}
			}
			
			//test movement angles until I find one that works, avoid that obstacle for MoveCount tics
			if (!moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
			{
				MoveCount = Int(random(16,32) * DetourFactor);
	 
				//try moving the same relative direction as last time
				if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
				
				//find viable movement direction
				for (double i = 1; i < 6; i++)
				{
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
					
					lastTurnDir *= -1.0;
					
					NextAngle = LastAngle + (i * 48 * lastturndir);
					NextPos = Vec2Angle(speed, NextAngle, True);
					If (IsVehicle) //Vehicle push and crush handling.
					{
						Let Vehicle = KAI_BaseVehicle(Self);
						Array <Actor> Pushovers;
						KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
						KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
						//TurretBlock = !Vehicle.CheckTurretCollision ((NextPos,Pos.Z),3);
					}
					moved = !TurretBlock ? TryMove(NextPos, 0, false, Move) : False;
					if (moved) break;
				}
			}
		}
		//3D velocity based movement
		//TODO:
		//Include the vehicle pushing and crushing code. And also make VehiclePushActors accept 3D coordinates instead, why did I make it a Vector2 when I planned this for months?
		//CREDIT: Boondorl and RaveYard for helping me get this fucking god forsaken math to mostly work.
		Else
		{
			//HACK: P_Move() disables this flag after successful steps, so always have it on when taking flying steps in case an NPC uses both TryMove() and KMT.
			//As for what this flag does, it stops +FLOAT actors from changing their Z coordinate directly to match the height of their target.
			bInFloat = True;
			Bool NoStockMovement;
			//Check if the actor flies with custom code
			If (bCustomFlyer)
				NoStockMovement = CustomFlyingMovement (TargetPos, DetourFactor, AngleLimit, ChaseFlags, Flags, PitchLimit);
			
			//No custom flying movement (Or there is but it complements you)? Then run.
			If (!NoStockMovement)
			{
			Bool Moved;
			Vector3 F3DVel;
			If (!MoveCount) KMT_3D_DecelWrongVector (TargetPos); //Decelerate from wrong velocities, like when an explosion blasts the actor off-course. But not when we're SUPPOSED to be detouring.
			
			//If (!MoveCount)
			{
				NextPitch = GetPitchToPos(TargetPos,PitchLimit);
				If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D: NextPitch is %.2f,",NextPitch);
				F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,FlightAcceleration); //Generate velocity that reaches the target over time (Or instantly).
				//Check if move will be blocked.
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
			}
			
			Double ZClimb;
			//Climb up or down from obstacle we hit. Improved version of standard MF_FLOAT behavior for point-to-point movement.
			If (KMT_3D_ScaleObstacle(Level.Vec3Offset(Pos,F3DVel),ZClimb))
			{
				//Climb position is higher than us, go up.
				If (ZClimb > Pos.Z)
					F3DVel.Z = FloatSpeed;
				//It's not, so that means we should go down instead.
				Else
					F3DVel.Z = -FloatSpeed;
				
				NextPitch = GetPitchToPos(Level.Vec3Offset(Pos,F3DVel.PlusZ(Height/2)),PitchLimit);
				F3DVel.X = F3DVel.Y = 0;
				
				//Returned that we moved (To not run the obstacle avoiding code.) If the coast is clear.
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
			}

			//if I hit an obstacle while avoiding another, try moving straight towards Other
			If (!Moved && MoveCount)
			{
				If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
				MoveCount = Int(random(16,32)*DetourFactor);
				NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,FlightAcceleration);
				Moved = !KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
			}
			
			//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
			If (!Moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
			{
				Switch (AngleLimit)
				{
					Case 20:
						TurnCount = Random (2,4);
						Break;
					Case 10:
						TurnCount = Random (3,6);
						Break;
					Case 5:
						TurnCount = Random (8,12);
						Break;
					Default:
						Break;
				}
			}
			
			If (!Moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
			{
				MoveCount = Int(random(16,32) * DetourFactor);
				
				//try moving the same relative direction as last time
				if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
				
				//find viable movement direction
				for (double i = 1; i < 6; i++)
				{
					If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D: Flyer hit obstacle attampting to get around it");
					NextAngle = LastAngle + (i * 48 * lastturndir);
					
					F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,FlightAcceleration);
					//Check if next move would be blocked.
					Moved = KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
					If (!Moved)
						Break;
					
					//Now do the opposite side too.
					LastTurnDir *= -1;
					
					NextAngle = LastAngle + (i * 48 * lastturndir);
					F3DVel = KAI_Math.AngleToVector3D (NextAngle,-NextPitch,FlightAcceleration);
					//Check if next move would be blocked.
					Moved = KMT_3D_MoveBlocked (Level.Vec3Offset(Pos,F3DVel));
					If (!Moved)
						Break;
				}
			}
			
			//Actually move.
			KMT_3D_SpeedLimit (Speed,F3DVel);
			If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D: Velocity is %.2f %.2f %.2f, length %.2f, going to %.2f %.2f %.2f",Vel,Vel.Length(),TargetPos);
			}
		}
		
		//face movement direction
		If (!(ChaseFlags & CHF_NODIRECTIONTURN))
		{
			Angle = Normalize180(NextAngle);
			If (Flags & KMT_3D)
				Pitch = -NextPitch;
		}
	}
	
	//Is there a scalable obstacle in front of the flier? If the answer is yes. It also has a Z value that can be set by reference for what Z to move to.
	//Right now it can't properly figure out how to scale a super steep slope from front to back. You know, since slopes are cursed. Will need a way to get the higher and lowest slope points!
	//It can climb down a ceiling slope pillar. A pillar with a slope at the top, it treats it like an unknown blocking but of geometry and so returns false.
	Protected Bool KMT_3D_ScaleObstacle (Vector3 Where, Double &TargetZ)
	{
		FCheckPosition Tm;
		Vector3 RealPos = Pos;
		SetZ (Where.Z);
		Bool Res = CheckMove (Where.XY,tm:Tm);
		Bool CanScale;
		If (!Res)
		{
			Double Padding = 64; //HACK: Don't fucking get stuck bouncing up and down at the vertical corner of obstacles.
			
			If (BlockingFloor && BlockingFloor.FloorPlane.IsSlope())
			{
				Vector3 Targ = BlockingFloor.FloorPlane.Normal.Unit() * Vel.Length();
				TargetZ = Pos.Z+Targ.Z; //TargetZ is further up the slope.
				CanScale = True;
			}
			Else If (BlockingCeiling && BlockingCeiling.CeilingPlane.IsSlope())
			{
				Vector3 Targ = BlockingCeiling.CeilingPlane.Normal.Unit() * Vel.Length();
				TargetZ = Pos.Z-Height-Targ.Z; //TargetZ is further down the slope.
				CanScale = True;
			}
			
			//We hit a two sided "ceiling" (Blocking I think) line, meaning there is a back sector to get the height of.
			//Unless that line is not even blocking us.
			If (BlockingLine && BlockingLine.Flags & Line.ML_TWOSIDED)
			{
				Line Blk = BlockingLine;
				Sector TargSec = Blk.BackSector == CurSector ? Blk.FrontSector : Blk.BackSector;
				
				//We hit a line with a lowered ceiling or raised floor in it.
				If (!(Blk.Flags & Line.ML_3DMIDTEX) && !Blocking3DFloor)
				{
					Double CeilHeight = TargSec.CeilingPlane.ZAtPoint(Where.XY);
					Double FloorHeight = TargSec.FloorPlane.ZAtPoint(Where.XY);
					Double TargSecHeight = CeilHeight - FloorHeight;
					
					//Handle slope ceilings and floors in the next sector, prevents "fun" cases of the flyer climbing down or up a raised slope pillar
					//only to bump on the tip of the slope and fly off like a moron because it's an "obstacle".
					If (FloorHeight > Pos.Z && TargSec.FloorPlane.IsSlope() && !(FloorHeight >= Pos.Z+MaxStepHeight))
					{
						Vector3 Targ = TargSec.FloorPlane.Normal.Unit() * Vel.Length();
						TargetZ = Pos.Z+Targ.Z; //TargetZ is further up the slope.
						CanScale = True;
					}
					//Or ceiling.
					Else If (CeilHeight < Pos.Z && TargSec.CeilingPlane.IsSlope() && !(CeilHeight <= Pos.Z-MaxStepHeight))
					{
						Vector3 Targ = TargSec.CeilingPlane.Normal.Unit() * Vel.Length();
						TargetZ = Pos.Z-Height-Targ.Z; //TargetZ is further down the slope.
						CanScale = True;
					}
					
					//Nope, just a normal sector.
					//Don't run if the ceiling is higher than the floor or the sector is fully sealed.
					//Or if we are already over the "obstacle" to begin with.
					Else If (!(FloorHeight >= CeilHeight) && TargSecHeight >= Height && (FloorHeight > Pos.Z || CeilHeight < Pos.Z+Height))
					{
						If (FloorHeight > Pos.Z) //Floor at XY is higher than we are, so we need to go up.
							TargetZ = FloorHeight;
						Else If (CeilHeight < Pos.Z+Height) //Ditto but the ceiling is lower than us so go down.
							TargetZ = CeilHeight-Height;
						
						If (TargetZ == FloorHeight && IsPosReachable3D((Pos.XY,FloorHeight),0,Height,False,True) || TargetZ == CeilHeight-Height && IsPosReachable3D((Pos.XY,CeilHeight-Height),0,Height,False,True))
							CanScale = True;
					}
				}
				//The two sided line we hit is a 3D middle texture.
				Else If (Blk.Flags & Line.ML_3DMIDTEX && !Blocking3DFloor)
				{
					Double Top, Bottom; Bool Valid;
					Int WhatSide = Level.PointOnLineSide (Where.XY,Blk,True);
					[Valid, Top, Bottom] = Blk.GetMidTexturePosition (WhatSide);
					
					Double Targ; Bool Down;
					[Targ, Down] = KMT_3D_GetObstacleClimbPos ((Top,Bottom,Top-Bottom),(CeilingZ,FloorZ),(Where.XY,RealPos.Z));
					If (Targ == Targ)
					{
						TargetZ = Targ;
						TargetZ += Down ? -Padding : Padding;
						CanScale = True;
					}
				}
				//The line we hit is part of a 3D floor maybe?
				//BUG: When a flyer climbs down a 3D floor while the target stands above the flyer, they will have a stroke when touching the 3DFloor ceiling.
				//No, checking if FFloor.Bottom or whatever doesn't do jack nor shit.
				Else If (Blocking3DFloor)
				{
					Sector TargSec = Blk.BackSector == CurSector ? Blk.FrontSector : Blk.BackSector;
					F3DFloor FFloor = Get3DFloorFromModel (Blocking3DFloor,TargSec);
					
					If (FFloor)
					{
						Double Top = FFloor.Top.ZAtPoint(Where.XY);
						Double Bottom = FFloor.Bottom.ZAtPoint(Where.XY);
						Double CeilingHeight = FFloor.Target.HighestCeilingAt(Where.XY);
						Double FloorHeight = FFLoor.Target.LowestFloorAt(Where.XY);
						
						Double Targ; Bool Down;
						[Targ, Down] = KMT_3D_GetObstacleClimbPos ((Top,Bottom,Top-Bottom),(CeilingHeight,FloorHeight),(Where.XY,RealPos.Z));
						//Valid return AND we can fit through.
						If (Targ == Targ)// && Top <= CeilingHeight-Height && Bottom >= FloorHeight+Height)
						{
							TargetZ = Targ;
							TargetZ += Down ? -Padding : Padding;
							CanScale = True;
						}
					}
				}
			}
			
			//We hit a blocking actor.
			If (!MovementBlockingLine && BlockingMobj && !(BlockingMobj.Pos.Z+BlockingMobj.Height <= Pos.Z) && !(BlockingMobj.Pos.Z >= Pos.Z+Height))
			{
				Double Targ; Bool Down;
				//Three little vectors jumping on the bed.
				[Targ, Down] = KMT_3D_GetObstacleClimbPos ((BlockingMobj.Pos.Z+BlockingMobj.Height,BlockingMobj.Pos.Z,BlockingMobj.Height),(BlockingMobj.CeilingZ,BlockingMobj.FloorZ),(Where.XY,RealPos.Z));
				If (Targ == Targ) //Not a NaN return. We can get over this actor.
				{
					TargetZ = Targ;
					TargetZ += Down ? -Padding : Padding;
					CanScale = True;
				}
			}
		}
		SetZ (RealPos.Z);
		Return CanScale;
	}
	
	//For finite height obstacles like 3D floors, determine the position to climb them over, is it up, under, neither, either?
	//Returns NaN if the actor cannot climb the finite height obstacle from here, like if it fully seals a sector or has other crap on its' top and bottom blocking movement.
	//ObsBounds: A vector holding (In order), the top and bottom heights of the obstacle, and its' height.
	//SectorHeights: The heights of the sector, to check if the obstacle blocks the sector by being at or beyond these heights. X is ceiling, Y is floor.
	//CheckPos: The position we're doing the check from. To check if the caller running this function would be blocked try to traverse this nondescript obstacle.
	//			The XY coordinates are used for the collision check for the hypthetical movement. But Z should be the ACTUAL current height of the actor.
	//BUG: The trivial height checks (Not running if the caller is entirely below or above the obstacle), don't run.
	Private Double, Bool KMT_3D_GetObstacleClimbPos (Vector3 ObsBounds, Vector2 SectorHeights, Vector3 CheckPos)
	{
		Double BlockTop = ObsBounds.X;//+ObsBounds.Z;
		Double BlockBottom = ObsBounds.Y;
		Double BlockHeight = ObsBounds.Z;
		
		Bool NoTop, NoBottom;
		Double Up = BlockTop;//BlockingMobj.Z+BlockingMobj.Height;
		Double Down = BlockBottom-Height;
		
		Double TargetZ;
		
		//... the caller is not even being blocked at all.
		If (BlockTop <= Pos.Z || BlockBottom >= Pos.Z+Height)
			Return Double.NaN, False;
		
		Bool GoingDown;
		
		//Can't climb up over. Either cuz the ceiling is fully blocked by the blocker or the gap is just too small to go through.
		If (BlockBottom+BlockHeight >= SectorHeights.X-Height || KMT_3D_MoveBlocked((CheckPos.XY,Up)))
			NoTop = True;
		
		//Can't go under the blocker, for the same reason as above but with the floor instead.
		If (BlockBottom <= SectorHeights.Y+Height || KMT_3D_MoveBlocked((CheckPos.XY,Down)))
			NoBottom = True;
		
		//Can only go up.
		If (!NoTop && NoBottom)
			TargetZ = Up;
		//Can only go down.
		Else If (NoTop && !NoBottom)
		{
			TargetZ = Down;
			GoingDown = True;
		}
		//Can go either way, so pick whichever's closest.
		Else If (!NoTop && !NoBottom)
		{
			//Top is closest.
			If (CheckPos.Z >= BlockBottom+(BlockHeight/2))
				TargetZ = Up;
			//Bottom is closer.
			Else
			{
				TargetZ = Down;
				GoingDown = True;
			}
		}
		//console.printf ("targetz for actor blocker is %.2f",targetz);
		If (!(NoTop && NoBottom)) Return TargetZ, GoingDown;
		Else Return Double.NaN, False;
	}
	
	//Was the move at this position blocked?
	//IgnoreCeiling: Don't count a move as blocked if it's just that it'll be over the ceiling. To prevent KMT_3D from stroking out when bumping against ceilings.
	Protected Bool KMT_3D_MoveBlocked (Vector3 Where, Bool IgnoreCeiling = True)
	{
		Vector3 RealPos = Pos;
		FCheckPosition Tm;
		SetZ (Where.Z); //Z is separate.
		Bool Res = CheckMove (Where.XY,tm:Tm);
		//Colliding between a line and a 3D floor over our heads. Very specific scenario isn't it?
		If (IgnoreCeiling && Pos.Z+Height >= CeilingZ) Res = True;
		SetZ (RealPos.Z);
		If (Tm.StepThing) Res = True;
		If (BlockingLine && IsInside3DFloor (Where,Height,True)) Res = False;
		Return !Res;
	}
	
	//Handle slowing down the actor based on just how far its' current velocity is from the target position, i.e if it fully faces away, it grinds to a halt.
	//Used to make the actor decelerate and gets its' bearings again when  thrown off course by external forces like explosions.
	//TargetPos: The desired position which there would be 0 deceleration returned if we headed straight for it.
	Protected Void KMT_3D_DecelWrongVector (Vector3 TargetPos)
	{
		If (FlightWrongDirFactor <= 0) //Function disabled.
			Return;
		
		Vector3 TheVel = Vel;
		If (TheVel == (0,0,0)) //Can't dot a vector of 0.
			TheVel = (0.001,0.001,0.001);
		Double DistFromTarg = Level.Vec3Diff(Pos,TargetPos).Unit() Dot TheVel.Unit(); //Get how much the actor is currently facing away from the target position.
		
		If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_DecelWrongVector(): Unprocessed DistFromTarg is %.2f",DistFromTarg);
		//Map dot product between 0 (Not facing at all) and 1 (Facing the desired vector).
		DistFromTarg = KAI_Math.LinearMap (DistFromTarg,-0.25,1.0,FlightWrongDirFactor,0);
		Double Decel = FlightDeceleration*DistFromTarg; //Scale deceleration with how wrong our current heading is.
		If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_DecelWrongVector(): Actor facing away from target pos factor is %.2f, decel is %.2f",DistFromTarg,decel);
		Vel += TheVel.Unit() * -Decel;
		//Return DistFromTarg;
	}
	
	//Limit the max speed that the actor reaches over time. If the vel length is too high, extra vel is zeroed out as well until the length goes below SpeedLimit.
	Protected Void KMT_3D_SpeedLimit (Double SpeedLimit, Vector3 ExtraVel)
	{
		//Absolute speed too high, slow down there cowboy.
		If (Vel.Length() > SpeedLimit)
			Vel += Vel.Unit() * -FlightDeceleration;
		
		If (SpeedLimit == 0) //Wheeeeee
		{
			Vel += ExtraVel;
			Return;
		}
		
		Vector3 NewVel = Vel + ExtraVel;
		If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_Speedlimit() Unmodified vel length will be %.2f, but SpeedLimit is %.2f",NewVel.Length(),SpeedLimit);
		//If ExtraVel will put our velocity over the speed limit, decrement it in steps into a value that won't do that.
		While (NewVel.Length() >= SpeedLimit && ExtraVel.Length() > 0.01)
		{
			//If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_Speedlimit() Decrementing ExtraVel from %.2f",ExtraVel);
			ExtraVel *= 0.97;
			//If (KAI_DebugPrintFlyers) Console.Printf ("KMT_3D_Speedlimit() To %.2f",ExtraVel);
			NewVel = Vel + ExtraVel;
		}
		
		Vel += ExtraVel;
	}
	
	//Returns a position for KMT_3D actors to head to avoid bumping into things. By averaging where a sphere of traces hit.
	//HorzTraces: How many horizontal traces to fire in the sphere.
	//VertTraces: Ditto but for vertical (Pitch) traces. If set to 0, the function operates in horizontal-only mode.
	//Distance: How far each trace will go. Basically how far the actor checks for obstacles.
	//Threshold: If the distance between the averaged coordinate and the actors' position is less than this. The function will return NaN.
	//Magnitude: How much the averaged coordinate is moved from the origin. Useful to make the obstacle avoiding effect larger when firing a lot of (Or distant) traces for example.
	//MinDist: If any trace hits something closer to the actor than this distance, return that there's nothing to avoid.
	//This function returns the averaged position of where every trace hit. And the average distance that every trace that was blocked by something went.
	Vector3, Double KAI_AvoidObstacles3D (Int HorzTraces, Int VertTraces, Double Distance, Double Threshold = 5, Double Magnitude = 1, Double MinDist = 0)
	{
		If (Distance <= 0 || HorzTraces <= 0)
			Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
		//HACK: Fun hack to store the hit locations of each trace. Of course the trace data can't be put in an array since it too is a struct, that'd be too expensive anyway.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Array <Double> Dists; Double DistSum; //For getting the average distance from all prematurely terminated traces made.
		
		Double Ang, Pit; //Angle and pitch to fire each trace at.
		Pit = -90;
		If (VertTraces <= 0) //Were firing in 2D mode.
			Pit = 0;
		Double HorzDiv = 360/HorzTraces;
		Double VertDiv = VertTraces > 0 ? 180/VertTraces : 0;
		
		Bool StopHorz; //Used to make only one angle trace fire when firing straight up or down.
		FLineTraceData Data;
		FSpawnParticleParams Debug;
		If (KAI_Debug3DObstacleCheck)
		{
			Debug.Color1 = "Green";
			Debug.Style = STYLE_None;
			Debug.Lifetime = KAI_Debug3DObstacleCheck;
			Debug.Size = 4;
			Debug.StartAlpha = 1;
			Debug.FadeStep = -1;
			Debug.Flags = SPF_FULLBRIGHT;
		}
		
		//Run horizontal traces.
		For (Int I = 0; I < HorzTraces; I++)
		{
			If (!StopHorz)
			{
				LineTrace (Normalize180(Ang),Distance,Pit,TRF_BLOCKSELF,0.1,data:Data);
				If (KAI_Debug3DObstacleCheck)
				{
					If (Data.HitType != TRACE_HitNone)
						Debug.Color1 = "Red";
					Else
						Debug.Color1 = "Green";
					KAI_LOFRaycast.VisualizeTracePath (Pos,Data.HitLocation,Data.Distance,16,Debug);
				}
				
				//Special treatment, treat hit skies as if we hit nothing and return a different HitLocation.
				If (!(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
					{Xs.Push (Data.HitLocation.X); Ys.Push (Data.HitLocation.Y); Zs.Push (Data.HitLocation.Z);}
				Else
				{
					Vector3 AltHitPos = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D (Ang,-Pit,Distance));
					Xs.Push (AltHitPos.X); Ys.Push (AltHitPos.Y); Zs.Push (AltHitPos.Z);
				}
				If (Data.HitType != TRACE_HitNone && !(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
				{
					If (MinDist > 0 && MinDist > Data.Distance)
						Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
					Dists.Push(Data.Distance);
					DistSum += Data.Distance;
				}
				Ang += HorzDiv;
			}
			
			If (Pit % 90 ~== 0 && Pit != 0)
				StopHorz = True;
			
			//Run vertical trace for horizontal slice.
			For (Int I = 0; I < VertTraces; I++)
			{
				LineTrace (Normalize180(Ang),Distance,Pit,TRF_BLOCKSELF,0.1,data:Data);
				If (KAI_Debug3DObstacleCheck)
				{
					If (Data.HitType != TRACE_HitNone)
						Debug.Color1 = "Red";
					Else
						Debug.Color1 = "Green";
					KAI_LOFRaycast.VisualizeTracePath (Pos,Data.HitLocation,Data.Distance,16,Debug);
				}
				
				//Special treatment, treat hit skies as if we hit nothing and return a different HitLocation.
				If (!(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
					{Xs.Push (Data.HitLocation.X); Ys.Push (Data.HitLocation.Y); Zs.Push (Data.HitLocation.Z);}
				Else
				{
					Vector3 AltHitPos = Level.Vec3Offset(Pos,KAI_Math.AngleToVector3D (Ang,-Pit,Distance));
					Xs.Push (AltHitPos.X); Ys.Push (AltHitPos.Y); Zs.Push (AltHitPos.Z);
				}
				If (Data.HitType != TRACE_HitNone && !(Data.HitSector && Data.HitSector.GetTexture(Data.SectorPlane) == SkyFlatNum))
				{
					If (MinDist > 0 && MinDist > Data.Distance)
						Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN; 
					Dists.Push(Data.Distance);
					DistSum += Data.Distance;
				}
				Pit += VertDiv;
				If (!(Pit % 90 ~== 0 && Pit != 0))
					StopHorz = False;
			}
		}
		
		Vector3 Sum, Average;
		//Add sums of vector components.
		For (Int I = 0; I < Xs.Size(); I++)
		{
			Sum.X += Xs[I]; Sum.Y += Ys[I]; Sum.Z += Zs[I];
		}
		
		//Average all coordinates. Use ValidAngs instead of HorzDiv to filter out angles that were done because they were aiming straight up or down.
		Average.X = Sum.X/Xs.Size(); Average.Y = Sum.Y/Ys.Size(); Average.Z = Sum.Z/Zs.Size();
		Double AvgDist = DistSum != 0 ? (DistSum/Dists.Size()) : Double.NaN;
		//Set magnitude on positioning relative to the origin. Negative magnitudes scale between the value specified and 1, based on the distance param and averaged second return.
		If (Magnitude < 0 && AvgDist == AvgDist)
		{
			Double Old = Abs(Magnitude);
			Magnitude = KAI_Math.LinearMap (AvgDist,0,Distance,Abs(Magnitude),1);
			If (KAI_Debug3DObstacleCheck)
				Console.Printf ("Dynamic magnitude is %.2f with a max of %.2f",magnitude,old);
		}
		Vector3 RelAv = Level.Vec3Diff (Pos,Average)*Abs(Magnitude);
		Average = Level.Vec3Offset (Pos,RelAv);
		
		If (!KAI_Debug3DObstacleCheck)
		{
			Console.Printf ("Sum of all coordinates is %.2f %.2f %.2f, average is %.2f %.2f %.2f, actual pos is %.2f %.2f %.2f",Sum,Average,Pos);
			If (Dists.Size() != 0) Console.Printf ("Average distance of all traces that were blocked is %.2f",DistSum/Dists.Size());
			KAI_DebugPointDelay.KAI_TempPointSpawn(Average,KAI_Debug3DObstacleCheck);
		}
		
		//The average is too close to the current position.
		If (Threshold > 0 && Level.Vec3Diff (Pos,Average).Length() < Threshold)
			Return (Double.NaN,Double.NaN,Double.NaN), Double.NaN;
		Else
			Return Average, AvgDist;
	}
	
	//Makes the NPC wander around aimlessly.
	//Attempts: How many positions to try per next position picked.
	//MoveRad: The radius around which to find a viable position to move to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move to.
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_Wander (Int Attempts = 24, Double MoveRad = 256, Int MaxSteps = 72, Double DetourFactor = 0.5, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		Int Friend = KAI_GetFriendPlayer();
		If (!bNoWanderVirtual && !OnWander()) //Virtual callback
			Return;
		
		//Friendly monsters follow the player they work for by default.
		If (bFriendly && !bDontFollowPlayers && PlayerInGame[Friend] && Players[Friend].Mo)
		{
			KAI_MoveTowards (Players[Friend].Mo.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		NextMovePos = FindRandomMovePos (Pos,Attempts,MoveRad,FRMP_RANDOM,(Flags & KMT_3D)); //Pick a random position to go to.
		//Take the first new step to not pause between new positions.
		KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags, PitchLimit);
		NewPosStepCount++;
	}
	
	Enum MoveAwayFlags
	{
		KMA_STRAIGHT	= 1 << 0, //Move in a straight line away from the Other actor, like A_Chase, instead of using the furthest random position around you.
	}
	
	//Moves the caller AWAY from another actor.
	//Other: The actor to move away from.
	//Attempts: How many positions to try per next position picked.
	//RunRad: The radius around which to find a viable position to run away to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move away to.
	//KMAFlags: The flags unique to KAI_MoveAway.
	//TargPos: If this is set to a non-NaN value. This position vector will be used directly instead of the Other pointer.
	/*ExtraParams: This is a KAIMoveParams struct, KAI_MoveAway() only cares for the obstacle avoidance and corner checking parameters.
	And also the KAI_MoveTowards() PitchLimit. So that I don't need to shoehorn even more parameters in this damn function.*/
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_MoveAway (Actor Other, Int Attempts = 32, Double RunRad = 128, Int MaxSteps = 32, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0,
	Int KMAFlags = 0, Vector3 TargPos = (Double.NaN, Double.NaN, Double.NaN), KAIMoveParams ExtraParams = Null)
	{
		If (!Other && KAI_Math.IsEmptyVector3(TargPos))
		{
			If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Premptively stopping execution");
			Return;
		}
		
		//HACK: Thanks GZDoom :D!
		If (!ExtraParams)
		{
			KAIMoveParams Default_Params;
			/*Default_Params.CornerDist = 0;
			Default_Params.CornerDiv = 0;
			Default_Params.ObstacleDist = 0.0;
			Default_Params.ObstacleSlices = 0;
			Default_Params.ObstacleDiv = 0;
			Default_Params.ObstacleThreshold = 5;
			Default_Params.ObstacleMagnitude = 1;*/
			Default_Params.PitchLimit = 40;
			KAI_MoveAway (Other, Attempts, RunRad, MaxSteps, DetourFactor, AngleLimit, ChaseFlags, Flags, KMAFlags, TargPos, Default_Params);
			Return;
		}
		
		Vector3 RunPos = Other ? Other.Pos : TargPos;
		
		//Got a goal to head to, no time to get spooked.
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
		{
			KAI_MoveTowards (Goal.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags, ExtraParams.PitchLimit);
			Return;
		}
		
		//2D obstacle avoidance
		If (!(Flags & KMT_3D))
		{
			Vector3 ObstacleAvoidPos; Bool UseObstacleAvoidPos;
			[ObstacleAvoidPos, UseObstacleAvoidPos] = KAI_AvoidObstacles (ExtraParams.ObstacleDist, ExtraParams.ObstacleSlices, Radius,RunPos);
			//Use the obstacle avoid pos if it's valid, and also not basically your current position, to prevent walking in place.
			If (UseObstacleAvoidPos && !KAI_Math.IsEmptyVector3(ObstacleAvoidPos) && Level.Vec3Diff (ObstacleAvoidPos,Pos).Length() >= MeleeRange)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Going to ObstacleAvoidPos %d %d %d",ObstacleAvoidPos);
				NextMovePos = ObstacleAvoidPos;
				Return;
			}
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): Walking to NextMovePos %d %d %d",nextmovepos);
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags,ExtraParams.PitchLimit);
			//3D obstacle avoidance.
			If (Flags & KMT_3D)
			{
				//Shortest KAI function call.
				Vector3 ObsVec = KAI_AvoidObstacles3D (ExtraParams.ObstacleSlices,ExtraParams.ObstacleDiv,ExtraParams.ObstacleDist,ExtraParams.ObstacleThreshold,ExtraParams.ObstacleMagnitude,ExtraParams.ObstacleMinDist);
				//Obstacle(s) nearby, so independently propel us to the averaged position the function gave us.
				If (!KAI_Math.IsEmptyVector3(ObsVec))
				{
					Vector3 ObsVel = KAI_Math.AngleToVector3D (GetAngleToPos (ObsVec,0),-GetPitchToPos(ObsVec,0),ExtraParams.ObstacleSpeed);
					KMT_3D_SpeedLimit (Speed,ObsVel);
					console.printf ("moving away from obstacle");
				}
			}
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			If (KAI_DebugPrintMessages) Console.Printf ("movepos reached, nulling");
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		Actor SightTarget = Other;
		
		//Check if the flying NPC could potentially hide at its' ceiling or floor height. If both have no LOS to the target (And are close enough), then whichever is closest.
		If (ExtraParams.KMAHidePlaneDist && SightTarget.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			Double Dist = Abs(ExtraParams.KMAHidePlaneDist);
			Double RealZ = Pos.Z;
			
			//So we can map which ones are good, AND closest if both the floor and ceiling are good.
			Vector2 FloorGood, CeilGood;
			
			//Floor isn't too far down.
			If (Pos.Z - FloorZ <= Dist)
			{
				SetZ (FloorZ);
				//Can see us on the floor, bad.
				If (!SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY))
					FloorGood = (True,Pos.Z - FloorZ);
				SetZ (RealZ);
			}
			
			//Ceiling isn't too far up.
			If (CeilingZ - (Pos.Z+Height) <= Dist)
			{
				SetZ (CeilingZ);
				If (!SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY))
					CeilGood = (True,CeilingZ - (Pos.Z+Height));
				SetZ (RealZ);
			}
			
			//Only return whichever's if both aren't invalid.
			If (FloorGood.X || CeilGood.X)
			{
				Double FinalZ;
				//If only one wasn't beyond the threshold, pick that one.
				If (FloorGood.X || !CeilGood.X) FinalZ = FloorZ;
				Else If (!FloorGood.X && CeilGood.X) FinalZ = CeilingZ;
				Else If (FloorGood.X && CeilGood.X)
				{
					Double Smallest = Min (FloorGood.Y,CeilGood.Y);
					If (Smallest ~== FloorGood.Y)
						FinalZ = FloorZ;
					Else
						FinalZ = CeilingZ;
				}
				NextMovePos = (Pos.XY,FinalZ);
				Return;
			}
		}
		
		Bool DoCornerCheck = (ExtraParams.CornerDist > 0 && (ExtraParams.CornerDiv > 0 || ExtraParams.CornerDiv == -1));
		If (!SightTarget && DoCornerCheck) SightTarget = Spawn ("KAI_TempPoint",TargPos); //Spawn a debug point to check the sight of a TargPos instead for running from a coordinate.
		
		//MAYDO: Add a boolean flag for ExtraParams (And KAI_CheckCorners()) that makes blocking actors also qualify as cover?
		//Try to run behind corners.
		If (DoCornerCheck)
		{
			If (ExtraParams.CornerSlices == 0)
				ExtraParams.CornerSlices = 4;
			Vector3 CornerPos;
			If (!(Flags & KMT_3D))
				CornerPos = KAI_CheckCorners (SightTarget,ExtraParams.CornerDiv,ExtraParams.CornerDist);
			Else
				CornerPos = KAI_CheckCorners3D (SightTarget,ExtraParams.CornerSlices,ExtraParams.CornerDiv,ExtraParams.CornerDist);
			//We have a corner from where we are not visible against whatever we're running from, run back there.
			If (!KAI_Math.IsEmptyVector3(CornerPos))
			{
				NextMovePos = CornerPos;
				Return;
			}
		}
		
		If (!(KMAFlags & KMA_STRAIGHT))
			NextMovePos = FindRandomMovePos (RunPos,Attempts,RunRad,FRMP_FURTHEST,Flags & KMT_3D); //Pick whichever position is the furthest from RunPos.
		//Run in the exact opposite direction of the target.
		Else
		{
			NextMovePos.XY = Vec2Angle (RunRad,GetAngleToPos(RunPos,0)-180);
			If (!(Flags & KMT_3D))
			{
				//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2),Level.Vec3Diff (Pos.PlusZ(Height/2),RunPos.PlusZ(Height/2)).Length());
				NextMovePos.Z = GetZAt (NextMovePos.X,NextMovePos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			//Use AngleToVector3D for getting the opposite pitch vector.
			Else
			{
				Double PitchTo = GetPitchToPos (RunPos,0); //Do NOT "-" the pitch since it's specifically meant to be the exact opposite pitch.
				Vector3 Vec = KAI_Math.AngleToVector3D (0,PitchTo,RunRad);
				NextMovePos.Z = Pos.Z + Vec.Z;
			}
		}
		//Take the first new step to not pause between new positions.
		KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags,ExtraParams.PitchLimit);
		NewPosStepCount++;
	}
	
	//Checks to the left and right of the caller for a position from where Targ can't see them. And returns it.
	//Targ: The actor (Or rather, the coordinate in general) from which we are running from, used for sight checks.
	//Divisions: How many split steps from the callers' origin to the left/rightmost position are done. i.e 32 steps with a distance of 512 is on check every 16MU.
	//Distance: The left/rightmost distance from the actor checked.
	Vector3 KAI_CheckCorners (Actor Targ, UInt Divisions, Double Distance)
	{
		//If we already have no line of sight to whatever we're supposed to be running from then well...
		If (Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			//Project a line of checks from the origin of the calling actor all the way out to the maximum length of CornerDist. Finding the closest corner.
			Vector3 RealPos = Pos;
			Double CheckLength = Distance;
			Double Division = (Distance/Divisions);
			
			//Check your left.
			Vector3 LeftPos;
			/*Note: If I = 0 and I < Distance. Then the first check is ran at the current NPC position instead of Division MU away,
			and the max distance away is skipped (i.e if the ckeck is set to check 394 MU on each side with a division of 12, it checks only 352MU away, AKA 384-32)*/
			For (Double I = Division; I < Distance+Division; I += Division)
			{
				LeftPos = Vec3Angle (I,Angle-90);
				If (KAI_DebugPrintMessages) console.printf ("left corner check is %.2f MU away from actual pos",level.vec3diff (leftpos,pos).length());
				SetOrigin (LeftPos, True);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool LeftSight = Targ.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, True);
				If (!LeftSight && Level.Vec3Diff (Pos,LeftPos).Length() >= MeleeRange && IsPosReachable (LeftPos,spacing:Speed,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my left corner.");
					Return LeftPos; //Move to the left.
				}
			}
			
			//Check your right.
			Vector3 RightPos;
			For (Double I = Division; I < Distance+Division; I += Division)
			{
				RightPos = Vec3Angle (I,Angle+90);
				If (KAI_DebugPrintMessages) console.printf ("right corner check is %.2f MU away from actual pos",level.vec3diff (rightpos,pos).length());
				SetOrigin (RightPos, True);
				//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
				Bool RightSight = Targ.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
				SetOrigin (RealPos, True);
				If (!RightSight && Level.Vec3Diff (Pos,RightPos).Length() > MeleeRange && IsPosReachable (RightPos,spacing:Speed,ignoreactors:True))
				{
					If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind my right corner.");
					Return RightPos; //Move to the left.
				}
			}
		}
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	//Works similar to its' 2D/land counterpart. Except that it fires a fan of checks around the caller. To allow it to also find vertical and diagonal corners.
	//Targ, Divisions, Distance: Works like its' 2D counterpart.
	//Slices: The slices that the clock-like pattern around the caller is split to. Similar to the slices in KAI_AvoidObstacles().
	//StartUp: By default the checks are fired from under the actor, this makes them start from above them. For biasing the check towards the ceiling instead.
	//Counterlockwise: By default the checks move left to right like a clock, this inverts that. For biasing the check towards the right.
	Vector3 KAI_CheckCorners3D (Actor Targ, UInt Slices, UInt Divisions, Double Distance, Bool StartUp = False, Bool Counterclockwise = False)
	{
		If (Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY))
		{
			Vector3 RealPos = Pos;
			
			Double Offset = 360/Slices;
			Vector3 Offs = (0,0,-Offset);
			If (StartUp)
				Offs.Z = Abs(Offs.Z);
			
			//Rotate the "clock".
			For (UInt I = 0; I < Slices; I++)
			{
				Double CRoll = Offs.Z*I;
				If (Counterclockwise)
					CRoll = -CRoll;
				Quat Base = Quat.FromAngles (GetAngleToPos(Targ.Pos,0),0,CRoll);
				Vector3 Dest;
				//Offs.Y += Offs.Y; //Increment for every slice.
				Double Division = (Distance/Divisions);
				Vector3 Rotated = Base * (0,0,Division);
				
				//Check slice.
				Int Iter;
				For (Double D = Division; D < Distance+Division; D += Division)
				{
					Iter++;
					Vector3 CheckPos;
					
					Dest = Level.Vec3Offset (Pos,Rotated*Iter);
					
					//This is out of bounds, or inside a 3D floor, get rid of it for performance.
					If (!Level.IsPointInLevel(Dest) || IsInside3DFloor (Dest,Height,True))
						Continue;
					
					CheckPos = Dest;
					SetOrigin (Dest,True);
					Bool Sight = Targ.CheckSight(Self,SF_IGNOREWATERBOUNDARY);
					SetOrigin (RealPos,True);
					If (KAI_Debug3DCornerCheck)
						KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_Debug3DCornerCheck);
					
					If (!Sight && Level.Vec3Diff (Pos,CheckPos).Length() > MeleeRange && IsPosReachable3D (CheckPos,spacing:Radius*2,ignoreactors:True,no3dfloors:True))
					{
						If (KAI_DebugPrintMessages) Console.Printf ("KAI_MoveAway(): KMA_USECORNERS: Running behind 3D corner.");
						Return CheckPos; 
					}
				}
			}
		}
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	//Fires a row of IsPosReachable checks around the actor. And if the first check isn't blocked, returns which unblock avoid position is further from Targ.
	//If there's no Targ, it just returns the first unblocked position it finds.
	//CheckDist: How far away the checks extend.
	//CheckSlices: How many checks are fired around the actor. (i.e at 16, it'll do one check per 22.5 degrees until it finds a reachable position).
	//CheckSpacing: The spacing of the IsPosReachable checks.
	//Targ: If this isn't NaN, the function gets all valid checks, and picks the furthest one as the unblocked position for the actor to go to.
	//Closest: If on, it will instead pick the position CLOSEST to Targ to go to.
	Vector3, Bool KAI_AvoidObstacles (Double CheckDist, Double CheckSlices, Double CheckSpacing, Vector3 Targ = (Double.NaN,Double.NaN,Double.NaN), Bool Closest = False)
	{
		If (CheckDist <= 0 || CheckSlices <= 0) Return (Double.NaN, Double.NaN, Double.NaN), False;
		Bool UseObstacleAvoidPos; //If on, the position passed in CheckPos will be used.
		Double CheckAngle = GetAngleToPos(NextMovePos,0); //Try at the NextMovePos, unless blocked.
		Vector3 CheckPos = (Vec2Angle (Radius+CheckDist,CheckAngle),0);
		CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
		
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		
		Vector3 FinalPos = (Double.NaN,Double.NaN,Double.NaN);
		//MAYDO: Make the code somehow ignore actors a vehicle can push away ? This would require reverting to using line traces.
		If (CheckDist > 0 && CheckSlices > 0)
		{
			//If (KAI_DebugPrintMessages) Console.Printf ("KAI_AvoidObstacles: Using basic obstacle avoiding algorithm with a distance of %.2f and %d slices",CheckDist,CheckSlices);
			//FLineTraceData PathCheck;
			//Check an arbitrary angles around the vehicle for a valid path. Ooga booga caveman pathfinding.
			For (Int I = 0; I < CheckSlices; I++)
			{
				If (IsPosReachable (CheckPos,spacing:CheckSpacing))
				{
					//Our current heading is good.
					If (I == 0)
						Return FinalPos, UseObstacleAvoidPos;
					If (KAI_DebugObstacleAvoid) KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_DebugObstacleAvoid);
					
					//Subtract the extra distance to check ahead of from the final move position.
					CheckPos.XY = Vec2Angle (CheckDist,CheckAngle);
					CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
					
					Xs.Push (CheckPos.X); Ys.Push (CheckPos.Y); Zs.Push (CheckPos.Z); //Epic GZDoom fail.
				}
				Else
				{
					If (KAI_DebugPrintMessages) Console.Printf ("%d %d %d isn't reachable, adjusting movepos",CheckPos);
					If (KAI_DebugObstacleAvoid)
					{
						Let Debug = KAI_DebugPointDelay.KAI_TempPointSpawn(CheckPos,KAI_DebugObstacleAvoid);
						If (Debug) Debug.A_SetTranslation ('KAI_DebugRed');
					}
					UseObstacleAvoidPos = True;
					//There's an obstacle in front of this path, try another angle.
				}
				CheckAngle += 360/CheckSlices; //Next angle.
				CheckPos.XY = (Vec2Angle (Radius+CheckDist,CheckAngle));
				CheckPos.Z = GetZAt (CheckPos.X,CheckPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			}
			
			If (!KAI_Math.IsEmptyVector3(Targ))
			{
				If (!Closest)
				{
					Double FurthestDistance;
					Vector3 CurPos;
					For (Int I = Xs.Size()-1; I >= 0; I--)
					{
						CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
						Double CurrentDistance = Level.Vec3Diff (Targ,CurPos).LengthSquared();
						If (FurthestDistance < CurrentDistance)
						{
							FurthestDistance = CurrentDistance;
							FinalPos = CurPos;
						}
					}
				}
				Else
				{
					Double NearestDistance = INT.MAX;
					Vector3 CurPos;
					For (Int I = Xs.Size()-1; I >= 0; I--)
					{
						CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
						Double CurrentDistance = Level.Vec3Diff (Targ,CurPos).LengthSquared();
						If (NearestDistance > CurrentDistance)
						{
							NearestDistance = CurrentDistance;
							FinalPos = CurPos;
						}
					}
				}
			}
			//No position to pick the furthest unblocked position from, so just return the first one.
			Else
				Return (Xs[0],Ys[0],Zs[0]), UseObstacleAvoidPos;
		}
		
		If (KAI_DebugObstacleAvoid && !KAI_Math.IsEmptyVector3(FinalPos))
		{
			Let Debug = KAI_DebugPointDelay.KAI_TempPointSpawn(FinalPos,KAI_DebugObstacleAvoid);
			If (Debug) Debug.Scale *= 3;
		}
		Return FinalPos, UseObstacleAvoidPos;
	}
	
	Enum FindMovePosFilters
	{
		FRMP_FURTHEST	= 1 << 0, //Pick the furthest of all available positions to move to. This is the default.
		FRMP_CLOSEST	= 1 << 1, //Pick the closest of all available positions to move to.
		FRMP_RANDOM		= 1 << 2, //Pick a random position out of all the viable ones found.
	}
	
	//Find a random position that the caller can actually move to.
	//RelativeTo: Which position should the distance checks be performed to ? Needed for the Furthest and Closest filters.
	//Attempts: How many random positions should be produced ? The more you add, the more heavy the function becomes. (Obviously)
	//CheckRad: What is the maximum radius around which random positions can be produced ?
	//Filter: What position are we looking for exactly ? Look above for a list of filters. These are NOT to be used as flags that stack !
	//Full3D: Generate fully 3D positions instead of alligning Z to the floor. For flying actors.
	Vector3 FindRandomMovePos (Vector3 RelativeTo = (Double.NaN, Double.NaN, Double.NaN), Int Attempts = 32, Double CheckRad = 128, Int Filter = FRMP_FURTHEST, Bool Full3D = False)
	{
		If (Filter == 0) Filter = FRMP_FURTHEST;
		
		//HACK: ZScript can't use Vector3 arrays. Because the only thing more dysfunctional than my code is the ZScript VM itself.
		//Nothing better than triple the amount of needed array accesses to slow an already expensive function down even more.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Vector3 CurPos; //The position we are currently checking. Reconstructed from the above arrays.
		
		For (Int I = 0; I <= Attempts; I++)
		{
			CurPos = Vec3Offset (FRandom(CheckRad,-CheckRad),FRandom(CheckRad,-CheckRad),Full3D ? FRandom(CheckRad,-CheckRad) : 0);
			If (!Full3D) CurPos.Z = GetZAt (CurPos.X,CurPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			Xs.Push (CurPos.X); Ys.Push (CurPos.Y); Zs.Push (CurPos.Z); //Epic GZDoom fail.
		}
		
		Actor SightTarget = Spawn ("KAI_TempPoint",Pos);
		For (Int I = Attempts-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			SightTarget.SetXYZ (CurPos); //Move the target to the pos for the visibility check.
			//If it's out of bounds, not visible, or can't be walked to. We can't go there. So remove that potential position.
			If (!Level.IsPointInLevel (CurPos) || Full3D && IsInside3DFloor (CurPos,Height,True) || !CheckSight(SightTarget,SF_IGNOREVISIBILITY) || !IsPosReachable (CurPos,full3d:Full3D))
			{
				Xs.Delete (I); Ys.Delete(I); Zs.Delete(I);
			}
			//else {actor mo = spawn ("candlestick",curpos); mo.bnogravity = true;} //EPIC WIN !!!!!!!!!!!!
			//For 3D positioning. Move down points that can't be directly reached due to the callers' height.
			If (Full3D && (CurPos.Z + Height) > CeilingZ)
				Zs[I] = CeilingZ-Height;
		}
		SightTarget.Destroy();
		
		//No valid positions found, return null.
		If (Xs.Size() == 0)
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Return a random position, this filter is checked first to at least make wandering NPCs a bit cheaper.
		If (Filter == FRMP_RANDOM)
		{
			Int RNGesus = Random (0,Xs.Size()-1);
			Return (Xs[RNGesus],Ys[RNGesus],Zs[RNGesus]);
		}
		//Return the furthest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_FURTHEST)
		{
			Double FurthestDistance;
			Vector3 FurthestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (FurthestDistance < CurrentDistance)
				{
					FurthestDistance = CurrentDistance;
					FurthestPos = CurPos;
				}
			}
			Return FurthestPos;
		}
		//Return the closest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_CLOSEST)
		{
			Double NearestDistance = INT.MAX;
			Vector3 NearestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestPos = CurPos;
				}
			}
			Return NearestPos;
		}
		
		Return (Double.NaN, Double.NaN, Double.NaN); //Return null position if all the above failed.
	}
	
	//BUG: For some reason the function will sometimes return positions that are behind drops too tall for the caller as valid. I have no fucking idea why.
	//BUG: It's not portal aware, because of course it isn't ! DESPITE LITERALLY CHECKING BY *ACTUALLY* MOVING THE CALLER IN A STRAIGHT LINE !
	//BUG: God, why is a function that literally walks the caller forward so fucking hard.
	//NOTE: A potential fix might be making Vec3Offset absolute, it should at least fix portals, since it fixed movement through them for KAI_MoveTowards.
	//Checks if the straight line between the callers' position and the specified position can be walked up to. Also returns where the position check ended.
	//TargetPos: The position to check if it's walkable.
	/*DistCutoff: The amount of map units to trim off the distance between the callers' pos and TargetPos. Useful for subtracting the radius of another actor,
	so that if you are checking if a position to another actor can be reached, the check doesn't return false because the actor itself is in the way !*/
	//Spacing: The spacing of the move checks. Default is 0, which means that the spacing is the diameter of the callers' hitbox.
	//IgnoreActors: Makes' the check ignore blocking actors entirely.
	//Dropoff: The Dropoff value passed to TryMove().
	Bool, Vector3 IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False, Int Dropoff = 1, Bool Full3D = False)
	{
		If (Full3D)
			Return IsPosReachable3D(TargetPos,DistCutoff,Spacing,IgnoreActors), (Double.NaN,Double.NaN,Double.NaN);
		Vector3 OldPos = Pos;
		Vector3 WhereTo;
		Bool Interp = bDontInterpolate;
		Bool ThruActs = bThruActors;
		Vector2 Path = Level.Vec2Diff( Pos.XY, TargetPos.XY );
		Double Distance = (Path.Length()-DistCutoff);
		
		If (Spacing == 0)
			Spacing = Radius*2;
		//Distance += Spacing; //HACK: According to RaveYard, apparently the last check in the row might be getting ignored, so this is a simple hack fix.
		If (Distance <= 1) Return False, (Double.NaN,Double.NaN,Double.NaN);
		Path /= Distance;
		
		bDontInterpolate = True; //No movement interpolation during the test.
		If (IgnoreActors) bThruActors = True;
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec2Diff (Pos.XY, OldPos.XY).Length() >= Distance) Break; //The check went further than the distance to the target position. Success.
			//Run as many times as it takes between you and your destination.
			FCheckPosition Data;
			Data.FromPMove = True;
			WhereTo = (Level.Vec2Offset(OldPos.XY, Path*I),0);
			WhereTo.Z = GetZAt (WhereTo.X,WhereTo.Y,flags:GZF_ABSOLUTEPOS);
			//console.printf ("z here is %.2f",whereto.z);
			//HACK: Try to manually check if the next step is too high up.
			If (CheckMove (WhereTo.XY, 0, tm:Data) && WhereTo.Z <= Pos.Z+MaxStepHeight)
			{
				//console.printf ("ACTOR Z %.2f, FLOORZ %.2f, ACTOR Z AND STEP HEIGHT %.2f, CHECKING AT %.2f %.2f",pos.z,data.floorz,pos.z+maxstepheight,whereto.xy);
				SetOrigin (WhereTo,True);
				//SetZ (WhereTo.Z); //HACK: Update the actors' Z position. TryMove should do that internally, but it doesn't. GZDoom moment.
				//actor debug = KAI_DebugPointDelay.KAI_TempPointSpawn((Level.Vec2Offset(OldPos.XY, Path*I),Pos.Z),16);
				//debug.scale *= 0.5;
			}
			//If one of them fails, then return false.
			Else
			{
				If (KAI_DebugPrintMessages)
				{
					console.printf ("i can't walk to %d %d %d",targetpos);
					If (!(WhereTo.Z <= Pos.Z+MaxStepHeight)) Console.Printf ("And it's SPECIFICALLY BECAUSE IT'S TOO HIGH UP, SOMETHING THAT GZDOOM DIDN'T CATCH!");
				}
				bDontInterpolate = Interp;
				bThruActors = ThruActs;
				SetOrigin (OldPos,True);
				Return False, WhereTo;
			}
		}
		
		bDontInterpolate = Interp;
		bThruActors = ThruActs;
		SetOrigin (OldPos,True);
		Return True, (Double.NaN,Double.NaN,Double.NaN); //No TryMove call returned false.
	}
	
	//Called in place of the stock one for flying actors. Also returns where the check failed, or NaN if it passed.
	//Works similarly to the normal one. Except that it relies on a row of CheckPosition() calls instead of moving the actor forward.
	//No3DFloors: If any of the intermediate positions hit a 3D floor, fail automatically. Since the function normally treats solid 3D floors as traversable.
	Bool, Vector3 IsPosReachable3D (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False, Bool No3DFloors = False)
	{
		Vector3 OldPos = Pos;
		Bool ThruActs = bThruActors;
		If (IgnoreActors) bThruActors = True;
		
		//This is where the fun begins. Get the direction to the target pos, and create a line towards there to iterate.
		Vector3 Path = Level.Vec3Diff(Pos, TargetPos);
		Double Distance = (Path.Length()-DistCutoff);
		If (Spacing == 0)
			Spacing = Radius*2;
		Distance += Spacing; //HACK: According to RaveYard, apparently the last check in the row might be getting ignored, so this is a simple hack fix.
		If (Distance <= 1) Return False, (Double.NaN,Double.NaN,Double.NaN);
		Path /= Distance;
		
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec3Diff (Pos, OldPos).Length() >= Distance) Break; //The check went further than the distance to the target position. Success.
			
			//Now, actually check for a bad position.
			FCheckPosition Data;
			Data.FromPMove = True;
			Vector3 CheckPos = Level.Vec3Offset (OldPos,Path*I);
			SetZ (CheckPos.Z); //Set the Z position before the check so CheckPosition's janky ass will hopefully not shit the bed.
			//Spawn ("KAI_DebugPoint",CheckPos);
			If (!CheckPosition(CheckPos.XY,False,Data) || No3DFloors && IsInside3DFloor (CheckPos,Height,True))
			{
				If (KAI_DebugPrintMessages) Console.Printf ("IsPosReachable3D(): %.2f %.2f %.2f is blocking %p",CheckPos,Self);
				bThruActors = ThruActs;
				SetOrigin(OldPos,True);
				Return False, CheckPos;
			}
		}
		
		bThruActors = ThruActs;
		SetOrigin(OldPos,True);
		Return True, (Double.NaN,Double.NaN,Double.NaN);
	}
	
	//Check how big the specified space is for the calling actor. Works by scaling up the actor to the desired size, and seeing if they are blocked by anything.
	//TargetRadius: The radius up to which the function checks if the actor is being blocked.
	//TargetHeight: Ditto, but for the height.
	//Iterations: How many steps is the caller scaled up from their real hitbox, to the hitbox being tested?
	//ActorBlock: Should the function be blocked by actors that would stop the callers' movement as well?
	//Returns after how many iterations it failed, if any, and at what radius and height it failed at.
	Int, Double, Double CheckSpaceSize (Double TargetRadius, Double TargetHeight, Int Iterations = 8, Bool ActorBlock = False)
	{
		Double RealRadius = Radius; Double RealHeight = Height;
		
		For (Int I = Iterations; I > 0; I--)
		{
			//Skip iterations smaller than the caller, they're expensive.
			If ((TargetRadius/I) <= RealRadius && (TargetHeight/I) <= RealHeight)
				Continue;
			A_SetSize (TargetRadius/I,TargetHeight/I);
			If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Checking if radius %f, height %f, iteration %d is valid",Radius,Height,I);
			Bool Thru = bThruActors;
			If (!ActorBlock) bThruActors = True;
			Bool Success = TestMobjLocation();
			bThruActors = Thru;
			
			If (!Success)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("CheckSpaceSize(): Epic fail");
				Double FailRadius = Radius; Double FailHeight = Height;
				A_SetSize (RealRadius,RealHeight);
				Return I, FailRadius, FailHeight;
			}
		}
		
		A_SetSize (RealRadius,RealHeight);
		Return -1, -1, -1; //Nothing is blocking us.
	}
	
	//=====|Order system|=====\\
	//Sets what order the NPC is currently following.
	//Order: The order to follow from the NPCOrders enum.
	//Increment: If true the NPC simply moves to the next order in the enum, and loops back around once reaching the end.
	//Commander: The actor, if any, ordering the NPC to change orders. If the order is set to ORDER_FOLLOW, they'll become the NPC' master, unless hostile.
	//IgnoreAllegiance: If true, the NPC will accept orders even from enemy actors, but still won't follow them if set to ORDER_FOLLOW.
	//FromACS: Marks this particular call as having being made by ACS_SetMarineOrder(), or just generally called by ACS. DO NOT USE UNLESS YOU ARE CALLING FROM ACS.
	Void SetNPCOrder (NPCOrders Order, Bool Increment = False, Actor Commander = Null, Bool IgnoreAllegiance = False, Bool FromACS = False)
	{
		If (bIgnoreOrders) Return;
		Bool EnemyCommand = IsActorHostile (Commander); //The order is being barked by an enemy.
		Bool LastOrder = CurrentOrder;
		If (Commander && EnemyCommand && !IgnoreAllegiance)
			Return;
		
		Int NewOrder = !Increment ? Order : 0;
		If (Increment)
		{
			NewOrder = CurrentOrder++;
			If (CurrentOrder >= ALLORDERS)
				CurrentOrder = 1;
		}
		If (!OnOrderChange(NewOrder, Increment, Commander, IgnoreAllegiance, FromACS)) //Run additional logic before changing orders.
			Return;
		
		If (Increment)
			CurrentOrder++;
		Else
			CurrentOrder = Order;
		
		If (CurrentOrder >= ALLORDERS) //If the NPCs' current order has reached the end of the list, loop back.
			CurrentOrder = 1;
		
		//If we are set to follow, and we have a commander that is friendly, follow them.
		If (CurrentOrder == ORDER_FOLLOW)
		{//If (KAI_DebugPrintMessages)console.printf ("Okay jolly green retard (%p), is your current order ORDER_FOLLOW ?",self);
			If (bFriendly && Commander == Players[KAI_GetFriendPlayer()].Mo) //If your commander is your friendplayer, remove your master pointer to follow friendplayer.
				Master = Null;
			
			If (Commander && !EnemyCommand && Commander != Players[KAI_GetFriendPlayer()].Mo) //Only set master pointer for non-player commanders.
			{If (KAI_DebugPrintMessages)console.printf ("set ORDER_FOLLOW and master for %p",self);
				Master = Commander;
				If (bFriendly)
					bDontFollowPlayers = True; //Friendly marine needs to follow an actor that isn't the friendplayer, so turn off player following.
			}
			Else If (!Master && !bFriendly && (!Commander || !EnemyCommand)) //We are set to follow but we don't have a (friendly) commander or existing master.
				{If (KAI_DebugPrintMessages)console.printf ("SETTING HOSTILE NPC %p TO ORDER_WANDER",self);CurrentOrder = ORDER_WANDER;}
		}
		
		If (CurrentOrder == ORDER_WANDER && bFriendly) //Friendly wandering NPCs don't follow the player.
			bDontFollowPlayers = True;
		
		//If we are set to follow and have no master or our master is our friend player.
		If (CurrentOrder == ORDER_FOLLOW && bFriendly)
		{
			If (!Master || Master == Players[KAI_GetFriendPlayer()].Mo)
				bDontFollowPlayers = False;
		}
		
		AfterOrderChange(LastOrder, Increment, Commander, IgnoreAllegiance, FromACS);
	}
	
	//This is for map script setups. Used to give orders to NPCS through ACS. For the ACS callback, the Commander is the activator.
	Static Void ACS_SetNPCOrder (Actor Activator, Int NPCTID, NPCOrders Order, Bool Increment, Bool IgnoreAllegiance = False)
	{
		Let NPCSearch = Level.CreateActorIterator (NPCTID,"KAI_Actor"); 
		
		KAI_Actor NPC;
		While ( (NPC = KAI_Actor(NPCSearch.Next())) )
		{
			If (!NPC || NPC.IsDead(NPC)) //Ignore nonexistent or dead NPCs.
				Continue;
			
			If (KAI_DebugPrintMessages)console.printf ("SetNPCOrder() was called from ACS, setting order %d for %p",order,NPC);
			NPC.SetNPCOrder (Order, Increment, Activator, IgnoreAllegiance, True);
		}
	}
	
	//=====|Search functions|=====\\
	Enum RetargetHullFlags
	{
		RVHF_NOTARGETCHANGE 		= 1 << 0, //This function should only return if the hull should be targeted, instead of also doing the actual retargeting.
		RVHF_NOTRANSFERDAMAGECHECK	= 1 << 1, //Don't retarget hulls larger than their bTransferDamage turret.
		RVHF_NOWEAKHULLCHECK		= 1 << 2, //Don't retarget hulls weaker than whatever turret the caller is targeting.
		RVHF_STRONGERHULL			= 1 << 3, //Retarget the hull if it is stronger (Healthier) than the turret.
	}
	
	//TODO: Add a check where even if any of these retarget conditions are met, the caller will not retarget if the hull is not actually hittable or visible. i.e out of melee range
	//Makes NPCs target the hulls of vehicles instead of their turrets' under certain conditions:
	//If the turret has bTransferDamage and is smaller than the vehicle it's attached to. Since attacking the turret only harms the vehicle, might as well shoot the bigger hull instead.
	//If the hulls' health is less than the health of the turret being targeted. Would be quicker to kill the vehicle than the turret.
	//Flags: Look above for a list of flags.
	Bool RetargetVehicleHull (Int Flags = 0)
	{
		If (!Target) Return False;
		
		//Turret must be attached on a vehicle to actually retarget.
		If (Target Is "KAI_BaseTurret" && Target.Master)
		{
			//If the damage that the targeted turret takes is transfered to the vehicle anyway (bTransferDamage).
			If (!(Flags & RVHF_NOTRANSFERDAMAGECHECK) && KAI_BaseTurret(Target).bTransferDamage)
			{
				Let SelfVeh = KAI_BaseVehicle (Target.Master);
				//And the vehicle the turret is attached to is overall bigger than the turret.
				If (SelfVeh && SelfVeh.Turret && Target.Master.Radius > SelfVeh.Turret.Radius && Target.Master.Height > SelfVeh.Turret.Height)
				{
					If (!(Flags & RVHF_NOTARGETCHANGE)) Target = Target.Master; //Then target the vehicle the turret is attached to.
					Return True;
				}
			}
			//If the turret doesn't have bTransferDamage, and it's health is higher than the hulls'.
			If (!(Flags & RVHF_NOWEAKHULLCHECK) && !KAI_BaseTurret(Target).bTransferDamage && Target.Master.Health < (Target.Health*0.8))
			{
				If (!(Flags & RVHF_NOTARGETCHANGE)) Target = Target.Master;
				Return True;
			}
			//Target the hull if it's stronger than the turret, basically targeting the strongest part of the vehicle.
			If (Flags & RVHF_STRONGERHULL && Target.Master.Health > Target.Health)
			{
				If (!(Flags & RVHF_NOTARGETCHANGE)) Target = Target.Master;
				Return True;
			}
		}
		Return False;
	}
	
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= 0) Return Null;
		
		Array <Actor> NearbyEnemies;
		LookForEnemiesEx (NearbyEnemies,Range,False,True);
		
		ForEach (Mobj : NearbyEnemies)
		{
			//Skip this actor if it's too far away.
			If (Distance3DSquared(Mobj) > Range*Range) Continue;
			
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		Return GetClosestActor (NearbyEnemies,Self.Pos,Range);
	}
	
	//A ZScript copy of A_MonsterRefire without the shitty HitFriend() check, and with the A_FaceTarget() call toggleable.
	//Chance, AbortState: Work the same as in A_MonsterRefire.
	//DontFaceTarget: If on, the turret won't instantly face the target after each refire.
	//RetargetCheckChance: The chance that RetargetVehicleHull() runs after each refire. Never runs if set to -1. 
	//RetargetCheckFlags: The flags to pass to RetargetVehicleHull() if it DOES run.
	//FOV: If the target is outside this FOV, then have a chance to stop shooting. Default is 180, which basically disables this check.
	//AimPos: If we're facing the target, what portion are we looking at?
	State KAI_NPCRefire (Int Chance, StateLabel AbortState, Bool DontFaceTarget = False, Int RetargetCheckChance = -1, Int RetargetCheckFlags = 0, Double FOV = 360, Int AimPos = 0)
	{
		If (!DontFaceTarget)
			A_FaceTarget(flags:AimPos);
		
		If (RetargetCheckChance != -1 && Random2[pr_monsterrefire]() < RetargetCheckChance)
			RetargetVehicleHull (RetargetCheckFlags);
		
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		If (KAI_BaseTurret(Self)) KAI_BaseTurret(Self).TurretAimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		//KLUDGE: Must manually check if Target is null for CheckFOV, because as of GZDoom 4.10, it doesn't natively do a null check, causing a hard crash !
		If (!Target /*|| HitFriend()*/ || IsDead (Target) || (Target && !CheckFOV (Target,FOV)) || !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
			Return FindState (AbortState);
		
		Return State (Null);
	}
	
	//Just use the flags from when it was KAI_TurretCheckLOF(), nevermind that the acronym is now inaccurate.
	Enum TurretLOFFlags
	{
		TLOF_FaceOther		= 1 << 0, //Should the ray be fired at the direction of the other actor instead of the direction the turret is facing ?
		TLOF_DoStayAround	= 1 << 1, //Should the function not mess with the turrets' bDontStayAround flag ?
		TLOF_FriendlyFire	= 1 << 2, //The turret can hit and harm its' allies.
		TLOF_OnlyAhead		= 1 << 3, //If the turret is lagging behind instead of aiming ahead of the target. Kinda assumes Other is the turrets' Target.
	}
	
	//TODO: Make this a generic LOF function.
	//A generic LOF check for monsters, that is a wrapper for the stock projectile line of fire check.
	//Other: The actor to check for, normally this will be the target. You can also simply not specify another actor.
	//PropHealthThreshold: If a destructible prop is in the actors' way with this much health or less, then still return true and fire through it.
	//SplashRadius: For explosive attacks, if the LOF misses and hits level geometry, then still return true if the Other actor would be caught in the blast.
	//CheckOffsets: How much to offset the checks' origin relative to the callers' position, default is offset 32 map units off the callers' Z position.
	//Flags: What flags to pass to the check, a list of flags can be found above.
	//ProjCls: What's the class of the projectile this check is used for ? Used to get additional attack info, like the rip level, depth, flags, etc.
	//AimPos: If we are explicitly aiming the LOF check at another actor, this is the explicit AimPos to use for them. For NPC turrets this is ignored in favor of TurretAimPos.
	Bool KAI_CheckLOF (Actor Other = Null, Int PropHealthThreshold = 400, Double SplashRadius = 0, Vector3 CheckOffsets = (0,0,32), Int Flags = 0, Class<Actor> ProjCls = Null, Int AimPos = 0)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		If (KAI_BaseTurret(Self)) KAI_BaseTurret(Self).TurretAimPos = GetFAFAimPos (Target);
		
		//If not aiming ahead of the target
		If (Flags & TLOF_OnlyAhead && !AimingAheadOfTarget())
			Return False;
		
		Vector3 Direction;
		If (!(Flags & TLOF_FaceOther))
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Other)
			{
				Int Aim = KAI_BaseTurret(Self) ? GetFAFPosOffset(Target,KAI_BaseTurret(Self).TurretAimPos) : GetFAFPosOffset(Target,AimPos);
				Double PitchTo = PitchTo (Other,Height/2,Aim);
				Direction = (AngleToVector(AngleTo(Other), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = Other ? Distance3D (Other)+32 : MaxTargetRange;
		Check.Shooter = Self;
		Check.Other = Other;
		Check.SplashRadius = SplashRadius;
		Check.PropHealthThreshold = PropHealthThreshold;
		Check.FriendlyFire = Flags & TLOF_FriendlyFire;
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = ProjCls; //Pass projectile class to class.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance);
		
		If (Check.BadLOF)
		{
			If (!(Flags & TLOF_DoStayAround) && KAI_BaseTurret(Self)) KAI_BaseTurret(Self).bDontStayAround = True;
			If (Check.ProjInfo) Check.ProjInfo.Destroy();
			Check.Destroy();
			Return False;
		}
		
		If (!(Flags & TLOF_DoStayAround) && KAI_BaseTurret(Self)) KAI_BaseTurret(Self).bDontStayAround = False;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return True;
	}
	
	//Find a height position (From the three FAF_ positions) at which the NPC can aim at the specified actor with a clear line of sight.
	//Useful for making NPCs aim at a different part of an actor when attacking.
	Int GetFAFAimPos (Actor Other, Vector3 Offset = (0,0,0))
	{
		If (!Other) Return FAF_MIDDLE; //No need to update anything.
		Vector3 OldPos = Other.Pos;
		Vector3 AimDir;
		Vector3 Start = Level.Vec3Offset (Pos,Offset);
		
		//Let's see if the middle of the other actor is hittable first.
		Let Check = New ("KAI_BasicSightCheck"); //Should be cheaper than CheckSight(), probably...
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height/2));
		AimDir = Vec3To (Other);
		Check.Shooter = Self;
		Check.SightTarget = Other;
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_MIDDLE;
		}
		
		//If we are this far that should mean the middle isn't visible, aim for the top.
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height));
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_TOP;
		}
		
		//If that too failed, aim for the bottom.
		Other.SetXYZ (Other.Pos);
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_BOTTOM;
		}
		
		//All else failed, aim to the middle again and return false;
		Return FAF_MIDDLE;
	}
	
	//Get what part of the actor the specified aim pos is looking at.
	Double GetFAFPosOffset (Actor Other, Int AimPos)
	{
		If (!Other)
			Return 0;
		
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Other.Height/2;
			Case FAF_TOP:
				Return Other.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	//Get the first NPC group you're in that has a leader in it, otherwise, fall back to returning whatever the first group in the array is.
	//IgnorePlayerLeaders: Ignore checking for the first player group leader and just return the first group.
	KAI_NPCGroup GetFirstPlayerNPCGroup (Bool IgnorePlayerLeaders = False)
	{
		If (!Groups.Size())
			Return Null;
		
		If (!IgnorePlayerLeaders)
		{
			ForEach (Group : Groups) //Focus on the first group you find whose leader is a player. AKA player groups take precedence.
			{
				If (Group && Group.Leader && Group.Leader.Player)
					Return Group;
			}
		}
		
		Return Groups[0]; //Fallback to just following the first group in the list.
	}
	
	//=====|Miscelleneous AI functions|=====\\
	//Makes the caller change their target to NewTarget, also passes which actor shared the target. Also does the needed status changes. Returns true if shared successfully.
	//Sharee: The actor sharing the target.
	//NewTarget: The potential target to have.
	//IgnoreAllegiance: If on, the target will be set even if the Sharee is hostile and/or the NewTarget is friendly.
	Bool KAI_ShareTarget (Actor Sharee, Actor NewTarget, Bool IgnoreAllegiance = False)
	{
		If (NewTarget != Null && !bDormant && !(IsPatrolling (Self) && bChaseGoal) && CanBeTargeted(Self,NewTarget))
		{
			If (!IgnoreAllegiance && (IsActorHostile(Sharee) || !IsActorHostile(NewTarget)))
				Return False;
			
			LastHeard = Target = NewTarget;
			Return True;
		}
		
		Return False;
	}
	
	//A crude replica of the clusterfuck that makes monsters natively able to use push and use lines.
	Bool KAI_NPCUseLines()
	{
		If (bNoTrigger || !BlockingLine) Return False;
       
        If (BlockingLine.Special)
        {
            If (bCanUseWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Use);
                Return True;
            }
            Else If (bCanPushWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Push);
                Return True;
            }
        }
        
        Return False;
	}
	
	Int KAI_GetFriendPlayer()
	{
		If (FriendPlayer != 0)
			Return FriendPlayer-1;
		Else
		{
			If (!Multiplayer)
				Return 0;
		}
		
		Return 0;
	}
	
	//Checks if the actor is in any of the attack states defined, and if it is, it also returns a pointer to that state.
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//ZScript port of this: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2568-2572
	Bool HandleNativeFright()
	{
		If (Target)
			Return (((!target.player || !((target.player.cheats & CF_FRIGHTENING) || (target.bFrightening))) && !(bFrightened)) || Random2[pr_scaredycat]() < 43);
		
		Return False;
	}
	
	//=====|A_Chase exports (Building blocks for custom chase functions)|=====\\
	//The checks A_Chase runs before it begins running the chase code.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2325-2376
	Void KAI_Chase_PreChecks (Int Flags = 0)
	{
		If (bInConversation || bInChase) Return;
		
		//bInChase = True;
		
		//PLAYTEST: I haven't checked if stealth monsters work with the exported A_Chase code.
		If (bStealth)
			VisDir -1;
		
		If (ReactionTime)
			ReactionTime--;
		
		//The latter half hasn't been implemented to mainline GZDoom yet, the bMInvisible flag that is.
		If (Target && (Target.bInvisible/* || Target.bMInvisible*/) && Target != Goal)
			Target = Null;
		
		If (Threshold)
		{
			If (!Target || IsDead (Target))
				Threshold = 0;
			Else
				Threshold--;
		}
		
		//Cocaine mode
		If (Flags && CHF_NIGHTMAREFAST && G_SkillPropertyInt (SKILLP_FASTMONSTERS))
		{
			If (Tics > 3)
			{
				Tics -= Tics/2;
				If (Tics < 3)
					Tics = 3;
			}
		}
		
		If (Target && Target != Goal && (IsDead(Target) || !IsActorHostile(Target)))
			Target = Null;
	}
	
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2401-2432
	//CREDIT: This section of the code was written by Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L74-L106
	//PLAYTEST: No idea if this actually works, or how to test it. It should, it's not only a direct rip, but it was written by someone who knows what they are actually doing (Not inkoalawetrust).
	//Makes friendly monsters using KAI chase functions chase their targets attack- basically just what A_Chase does.
	//It does return true if a new target was found though.
	Bool KAI_Chase_FriendsAttackPlayerEnemies (Int Flags)
	{
		// [RH] Friendly monsters will consider chasing whoever hurts a player if they
		// don't already have a target.
		if (bFRIENDLY && target == null)
		{
			PlayerInfo player;

			if (FriendPlayer != 0)
			{
				player = Players[FriendPlayer - 1];
			}
			else
			{
				int i;
				if (!multiplayer)
				{
					i = 0;
				}
				else for (i = random[newchasedirr](0,255) & (MAXPLAYERS-1); !PlayerInGame[i]; i = (i+1) & (MAXPLAYERS-1))
				{
				}

				player = Players[i];
			}
			if (player.attacker && !IsDead (Player.Attacker) && player.attacker.bSHOOTABLE && random[newchasedirr](0,255) < 80)
			{
				if (!player.attacker.bFRIENDLY ||
					deathmatch && FriendPlayer != 0 && player.attacker.FriendPlayer != 0 &&
					FriendPlayer != player.attacker.FriendPlayer)
				{
					target = player.attacker;
					Return True; //Found a player enemy to attack.
				}
			}
		}
		
		Return False;
	}
	
	//Makes the actor change targets if the current one is unavailable. If no target is found either hang out in the current state or go back to idling.
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2433-2467
	Bool KAI_Chase_Retarget (Int Flags, Bool FriendliesIdle = False)
	{
		If (!Target || !Target.bShootable)
		{
			If (Target && Target.bNonShootable)
			{
				LastEnemy = Target;
				Threshold = 0;
			}
			If (LookForPlayers (True) && Target != Goal)
				Return True;
			If (!Target)
			{
				If (Flags & CHF_DONTIDLE || bFriendly && !FriendliesIdle)
				{
					If (!Target)
					{
						If (!(Flags & CHF_DONTMOVE))
							KAI_Wander(flags:IsFlying(Self) ? KMT_3D : 0);
					}
				}
				Else
					SetIdle(); //Sleepy time
			}
		}
		Return False;
	}
	
	//This is an important one for every chase function of every NPC type. It handles going to patrol points and then heading to the next point in the route.
	//BUG: It seems that patrolling monsters ignore patrol point delays when they see an enemy. However that seems to also be a bug in the original logic so maybe I'll keep it as is.
	//WaitState: The statelabel for the actor to go to if it finds a delayed patrol point. If none is specified, it calls SetState().
	//The rest of the parameters here are what is passed to KAI_MoveTowards
	//This function returns 2 booleans. The first returns true if the goal was changed to the next one in the route, and the second returns true if the actor moved to the goal.
	Bool, Bool KAI_Chase_PatrolHandling (StateLabel WaitState = Null, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0, Double PitchLimit = 40)
	{
		If (Target == Goal || bChaseGoal && Goal != Null)
		{
			If (KAI_CheckMeleeRange(Goal,flags: Flags & KMT_3D ? CMR_3DDISTANCE : 0))
			{
				//Credit: Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L161-L212
				// reached the goal
				ActorIterator iterator = Level.CreateActorIterator(goal.args[0], "PatrolPoint");
				ActorIterator specit = Level.CreateActorIterator(goal.tid, "PatrolSpecial");
				Actor spec;

				// Execute the specials of any PatrolSpecials with the same TID
				// as the goal.
				while ( (spec = specit.Next()) )
				{
					level.ExecuteSpecial(
						spec.special, self, null, false,
						spec.args [0], spec.args [1], spec.args [2], spec.args [3], spec.args [4]
					);
				}

				double lastgoalang = goal.angle;
				int delay;
				actor newgoal = iterator.Next ();
				if (newgoal != null && goal == target)
				{
					delay = newgoal.args[1];
					reactiontime = delay * TICRATE + level.maptime;
				}
				else
				{
					delay = 0;
					reactiontime = Default.reactiontime;
					angle = lastgoalang;
				}
				if (target == goal) target = null;
				bJUSTATTACKED = true;
				if (newgoal != null && delay != 0)
				{
					bINCOMBAT = true;
					If (!WaitState)
						SetIdle();
					Else
						SetStateLabel (WaitState);
				}
				bINCHASE = false;
				goal = newgoal;
				if (goal) spawn ("kai_debugpoint",goal.pos);
				return True, False;
			}
			//We have a goal, go to it.
			If (Goal && Goal == Target)
			{
				KAI_MoveTowards (Goal.Pos,DetourFactor,AngleLimit,ChaseFlags,Flags,PitchLimit);
				Return False, True;
			}
		}
		Return False, False;
	}
	
	//Handles the playing of the active sound.
	Bool KAI_Chase_HandleActiveSound (Int Flags, Int Frequency = 3)
	{
		if (!(Flags & CHF_NOPLAYACTIVE) && random[pr_chase](0,255) < Frequency)
		{
			PlayActiveSound();
			Return True;
		}
		Return False;
	}
	
	//This handles Hexens' player boss strafing.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2537-2566
	//StrafeTarget: The actor to strafe relative to, normally this will be the target of course.
	//Flags: the A_Chase flags to pass and check for.
	//ForceStrafe: Force the caller to do a strafe.
	//StrafeRange: How close the StrafeTarget has to be to decide to strafe, default is CLASS_BOSS_STRAFE_RANGE.
	Void KAI_Chase_HandleStrafing (Actor StrafeTarget, Int Flags, Bool ForceStrafe = False, Double StrafeRange = 64*10)
	{
		If (!StrafeTarget) Return; //Nothing to dodge.
		
		If (ForceStrafe || Flags & CHF_FASTCHASE && !(Flags & CHF_DONTMOVE))
		{
			If (ForceStrafe) FastChaseStrafeCount = 0;
			If (FastChaseStrafeCount > 0)
				FastChaseStrafeCount--; //Decrement strafe delay.
			Else
			{
				FastChaseStrafeCount = 0;
				Vel.X = Vel.Y = 0;
				If ((ForceStrafe || Random[pr_chase](0,255) < 100) && Distance2D(StrafeTarget) < StrafeRange)
				{
					Double Ang = AngleTo (StrafeTarget);
					If (Random[pr_chase](0,255) < 128) Ang += 90;
					Else Ang -= 90;
					VelFromAngle (13,Ang);
					FastChaseStrafeCount = 3;
				}
			}
		}
	}
}

//This struct stores parameters passed to KAI_MoveTowards/Away. Used as a simple way to pass all params the functions support from another function that calls them.
//Without cluttering up the other function. i.e for passing additional more detailed parameters for a custom chase function like KAI_LandVehicleChase() does.
//Also used by KAI_MoveAway() to enable and pass custom parameters for the obstacle avoiding and running behind corners.
Struct KAIMoveParams
{
	//KAI_MoveTowards() parameters
	Vector3 TargetPos; //The position to actually move to.
	Double DetourFactor; //A multiplier for how many steps the caller can take around an obstacle before heading straight to the TargetPos again.
	Double AngleLimit; //How much the caller can turn to face their TargetPos per step.
	Double PitchLimit; //Ditto, but for the 3D movement of KMT_3D.
	Int ChaseFlags; //The A_Chase flags KAI_MoveTowards() supports, which are CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	Int Flags; //The functions' own flags, check the KAIMoveTowardsFlags enum for a list of them and what they do.
	
	//KAI_MoveAway() parameters, the function also supports KAI_MoveTowards() parameters, as it's effectivelly a wrapper for it.
	Actor Other; //The actor to run away from.
	Int Attempts; //How many potential points to run to should the function generate. The more you generate the more performance heavy it becomes !
	Double RunRad; //The radius around which additional points should be generated.
	Int MaxSteps; //How many steps trying to move to the current retreat position can the caller take before it picks a new location to run to.
	Int KMAFlags; //The functions' own flags, check the MoveAwayFlags enum for a list of them and what they do.
	Double KMAHidePlaneDist; //If non-0. KMA will check the callers' ceiling and floor heights. And see if they could hide at whichever is closest, if they're under this threshold.
	
	//Additional parameters that need to be passed through this struct to KAI_MoveAway().
	Double CornerDist; //How far away on the left and right sides should the corner running code check around the caller? If this is 0 or less, this is disabled.
	Int CornerDiv;	//How many additional fractional checks should the corner running code do? i.e divinding a CornerDist of 100 by 10 to check every 10 MU.
	Int CornerSlices; //Used by KMA when using KMT_3D movement. Determines how many slices to use for checking corners in a clock-like pattern.
	Double ObstacleDist; //How far ahead should the actor check for obstacles to try moving around from? If set to 0 or less, no obstacle avoidance occurs.
	Int ObstacleSlices; //How many reachability checks should be done around a 360 degree circle? i.e setting this to 16 checks in increments of 22.5 degrees around.
	Int ObstacleDiv; //Used by AvoidObstacles3D, how many vertical (Pitch) slices should the check have?
	Double ObstacleThreshold; //Ditto, makes KMA ignore any positions that are closer to the actors' current position than this threshold distance, i.e to ignore noise.
	Double ObstacleMagnitude; //Ditto, makes KMA increase just how extreme the averaged position to head to is, negative values make it use a special linear scaling factor.
	Double ObstacleSpeed; //The speed at which AvoidObstacles3D pushes the caller away from obstacles.
	Double ObstacleMinDist; //If any trace from AvoidObstacles3D hits something closer than this distance, the function returns NaN. Useful if you want the avoidance to give up if far too close anyway.
}
