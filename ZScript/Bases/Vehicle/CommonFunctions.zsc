//TODO:
//The smart marine spawning from the MVP will stay there. Until the marine rewrite to make them use this library.

Extend Class KAI_BaseVehicle
{
	//=====|Headlight Functions|=====\\
	//High quality code rips.
	Enum DynamicLightArgs
	{
	   LIGHT_RED = 0,
	   LIGHT_GREEN = 1,
	   LIGHT_BLUE = 2,
	   LIGHT_INTENSITY = 3,
	   LIGHT_SECONDARY_INTENSITY = 4,
	   LIGHT_SCALE = 3,
	}
	
	//VHSF = Vehicle Headlight Spawn Function
	Enum HeadlightSpawnFlags
	{
		VHSF_BACKLIGHT = 1 << 0 //Is this a backlight ? If yes, the angle it faces relative to the vehicle is inverted, so that it faces behind the vehicle.
	}
	
	//Spawns a headlight with the specified parameters. Then returns a pointer to it.
	//AttachTo: The actor to attach the headlight to, this is just the caller usually.
	//Offsets: The XYZ offsets to pass to the light. This doesn't call SetOffset() on the dynamic light because m_Ofs doesn't change before PostBeginPlay().
	//Flags: The flags to pass to the headlight.
	//LightColor: The RGB color of the headlight. This isn't a Color variable since that's not what dynamic light actors use. Default is white.
	//Intensity: The intensity of the headlight. Default is 256.
	//SpotlightAngles: The inner (X) and outer (Y) angle of the headlight. Default is (10,25), the default of the DynamicLight class.
	KAI_VehicleHeadlight SpawnVehicleHeadlight (Actor AttachTo, Vector3 Offsets, Int Flags = 0, Vector3 LightColor = (255,255,255), Int Intensity = 256, Vector2 SpotlightAngles = (10,25))
	{
		If (!AttachTo) AttachTo = Self; //Just in case.
		KAI_VehicleHeadlight Headlight = KAI_VehicleHeadlight(Spawn ("KAI_VehicleHeadlight",Pos,ALLOW_REPLACE));
		
		Headlight.Target = AttachTo; //Dynamic light actors use their target pointer to store who they are attached to.
		Headlight.Offset = Offsets;
		If (Flags & VHSF_BACKLIGHT) Headlight.IsBacklight = True;
		
		//XYZ = RGB
		Headlight.Args[LIGHT_RED] = Int(LightColor.X);
		Headlight.Args[LIGHT_GREEN] = Int(LightColor.Y);
		Headlight.Args[LIGHT_BLUE] = Int(LightColor.Z);
		Headlight.Args[LIGHT_INTENSITY] = Intensity;
		
		//X is the inner angle. Y is the outer angle.
		Headlight.SpotInnerAngle = SpotlightAngles.X;
		Headlight.SpotOuterAngle = SpotlightAngles.Y;
		
		Return Headlight;
	}
	
	//Turn the vehicles' headlights on.
	Void TurnHeadlightsOn()
	{
		If (LightsOnAlready) Return;
		LightLevel = 64; //Light up the vehicle.
		If (Turret) Turret.LightLevel = 64; //And the turret, if any.
		For (Int I = HeadLights.Size()-1; I >= 0; I--)
		{
			If (Headlights[I])
			{
				Headlights[I].Activate(Self);
				Headlights[I].Active = True;
			}
		}
		If (GetAge() > 1) LightsOnAlready = True; //1 tic delay to allow the lights to spawn in the first place.
	}
	
	//Turn them off.
	Void TurnHeadlightsOff()
	{
		LightLevel = 0;
		If (Turret) Turret.LightLevel = 0;
		For (Int I = HeadLights.Size()-1; I >= 0; I--)
		{
			If (Headlights[I])
			{
				Headlights[I].Deactivate(Self);
				Headlights[I].Active = False;
			}
		}
		LightsOnAlready = False;
	}
	
	//Remove them when the vehicle is killed or removed.
	Void RemoveHeadlights()
	{
		For (Int I = HeadLights.Size()-1; I >= 0; I--)
		{
			If (Headlights[I])
			{
				Headlights[I].Destroy();
				Headlights.Delete(I);
			}
		}
		LightsOnAlready = False;
	}
	
	//=====|AI functions|=====\\
	Enum MVPChaseFlags
	{
		MVPC_ATTACKWHENSCARED = 1 << 0, //The vehicle will still be very likely to attack when scared of an enemy.
		MVPC_NORANDOMTURN = 	1 << 1, //Turns on CHF_NORANDOMTURN on the A_Chase calls.
		MVPC_NOCHASE = 			1 << 2, //Don't run any code related to the vehicle moving. Useful for the turrets.
		MVPC_CORPSESEEKER = 	1 << 3,	//The vehicle will actively go after corpses to crush them if it has nothing else to do.
		MVPC_NOTURRETRETARGET =	1 << 4, //The vehicle will never target the hull of a vehicle instead of its' turret. Even if doing so would be better.
	}
	
	//Generic chase function shared by all vehicles.
	//Flags: Look above for available flags.
	//FollowDist: The distance below which the vehicle will stop trying to follow the player, to not get in their way.
	Void MVP_Chase (Int Flags = 0, Double FollowDist = 384)
	{
		Bool AlreadyRetreating; //The vehicle is already running away from something that doesn't involve the enemy avoiding code, so don't bother to run from nearby enemies.
		Double PowerfulEnemyRetreatRange = (User_RetreatDistance*4)*(User_RetreatDistance*4); //Vehicles stay 4 times further away from powerful enemies than normal ones.
		
		//Temporarily store the values that are changed by the fear code.
		Double OldAggro = AggressionMultiplier;
		
		//Vehicles get scared if they have a living, visible target, and are either defenseless or the target is too powerful.
		If (!bNoFear)
		{
			If (Target && !CanAttack() || Target && IsPowerful (Target) && Distance3DSquared (Target) <= PowerfulEnemyRetreatRange)
				If (!IsDead (Target) && IsVisible(Target, True))
				{
					FearTimer = Random (2,64);
					bFrightened = AlreadyRetreating = True;
				}
				Else
					bFrightened = False;
			Else
				bFrightened = False;
			
			If (FearTimer)
			{
				FearTimer--;
				bFrightened = AlreadyRetreating = True;
			}
			
			If ((Flags & MVPC_ATTACKWHENSCARED) && bFrightened)
				AggressionMultiplier *= 0.5;
		}
		
		If (!(Flags & MVPC_NOCHASE))
		{
			FollowPlayerControl (FollowDist);
			
			//Vehicles try to stay away from enemies that are too close.
			Actor OldTarget;
			If (!(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (User_RetreatDistance); //Only retreat from enemies if NOT set to patrol AND ignore targets.
			//Have a close enemy, and not already retreating from something like a powerful target.
			If (NearestEnemy && !AlreadyRetreating)
			{
				OldTarget = Target;
				Target = NearestEnemy;
				bFrightened = True;
				FearTimer = Random (2,48);
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & MVPC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0)); //So move away from the nearest enemy.
				Target = OldTarget;
			}
			//If the vehicle turrets' target is too high, move away from it to allow the turret to shoot it.
			Else If (Turret && Turret.Target && Turret.ElevationState == Turret.ELEVATION_TOOHIGH)
			{
				OldTarget = Target;
				Target = Turret.Target;
				bFrightened = True;
				FearTimer = Random (8,32);
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & MVPC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
				Target = OldTarget;
			}
			//Archvile trolling mode activated.
			Else If (!Target && !IsPatrolling(Self) && !NearestEnemy && CurrentOrder == ORDER_WANDER && (Flags & MVPC_CORPSESEEKER))
			{
				//Don't have a corpse to crush already.
				If (!CorpseTarget)
				{
					CorpseTarget = FindNearestCorpse();
					
					If (!CorpseTarget) //Still no corpse found.
						A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & MVPC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
					Else
						KAI_MoveTowards (CorpseTarget);
				}
				//There is an available corpse to head to and crush.
				Else
					KAI_MoveTowards (CorpseTarget);
			}
			Else
				A_Chase (Null,Null,CHF_DONTIDLE | ((Flags & MVPC_NORANDOMTURN) ? CHF_NORANDOMTURN : 0));
		}
		
		If (!(Flags & MVPC_NOTURRETRETARGET)) RetargetVehicleHull();
		Actor CheckFrom = Turret;
		If (!CheckFrom) CheckFrom = Self; 
		If (StayStillAndShoot (CheckFrom)) Return;
		
		If (ShouldAttack()) //Run the unique attack decision code of the vehicle.
		{
			AggressionMultiplier = OldAggro; //Reset aggression chance.
			ChaseTimer = 0;
			CorpseTarget = Null;
			Return; //End the function if the vehicle should attack.
		}
		AggressionMultiplier = OldAggro; //Reset aggression chance.
		
		HandleChaseTimer();
	}
	
	Void HandleChaseTimer() //Made into a separate function so it can be called independently by turrets and such.
	{
		//They also eventually stop chasing their target after it's out of sight for long enough.
		If (User_ChaseTime > 0)
		{
			If (ChaseTimer >= User_ChaseTime)
			{
				A_ClearTarget();
				ChaseTimer = 0;
				//Vehicles ordered to stay also go back to standing still once the timer runs out.
				If (CurrentOrder == ORDER_STAY)
				{
					SetStateLabel ("Spawn");
					Return;
				}
			}
			
			If (!IsPatrolling(Self))
			{
				If (!Target || Target && !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING))
					ChaseTimer++;
				//Target is visible again, reset the timer.
				Else
					ChaseTimer = 0;
			}
		}
	}
	
	//As a friendly vehicle, only follow the player until within a certain distance from them, to prevent the player from being dogpiled by vehicles.
	Void FollowPlayerControl (Double MaxDist = 384)
	{
		If (!PlayerInGame[FriendPlayer] || CurrentOrder == ORDER_WANDER)
			Return;
		
		If (bFriendly)
			bDontFollowPlayers = (Distance3DSquared (Players[FriendPlayer].Mo) <= MaxDist*MaxDist);
	}
	
	Enum RetargetHullFlags
	{
		RVHF_NOTARGETCHANGE 		= 1 << 0, //This function should only return if the hull should be targeted, instead of also doing the actual retargeting.
		RVHF_NOTRANSFERDAMAGECHECK	= 1 << 1, //The function should not retarget hulls larger than their bTransferDamage turret.
		RVHF_NOWEAKHULLCHECK		= 1 << 2, //The function should not retarget hulls weaker than whatever turret the caller is targeting.
	}
	
	//Makes vehicles target the hulls of vehicles instead of their turrets' under certain conditions:
	//If the turret has bTransferDamage and is smaller than the vehicle it's attached to. Since attacking the turret only harms the vehicle, might as well shoot the bigger hull instead.
	//If the hulls' health is less than the health of the turret being targeted. Would be quicker to kill the vehicle than the turret.
	//Flags: Look above for a list of flags.
	Bool RetargetVehicleHull (Int Flags = 0)
	{
		If (!Target || !Master) Return False;
		
		If (Target Is "KAI_BaseVehicleTurret" && Target.Master)
		{
			//If the damage that the targeted turret takes is transfered to the vehicle anyway (bTransferDamage).
			If (!(Flags & RVHF_NOTRANSFERDAMAGECHECK) && KAI_BaseVehicleTurret(Target).bTransferDamage)
			{
				//And the vehicle the turret is attached to is overall bigger than the turret.
				If (Master.Radius > Target.Radius && Master.Height > Turret.Height)
				{
					If (!(Flags & RVHF_NOTARGETCHANGE)) Target = Target.Master; //Then target the vehicle the turret is attached to.
					Return True;
				}
			}
			//If the turret doesn't have bTransferDamage, and it's health is higher than the hulls'.
			If (!(Flags & RVHF_NOWEAKHULLCHECK) && !KAI_BaseVehicleTurret(Target).bTransferDamage && Target.Master.Health < (Target.Health*0.8))
			{
				If (!(Flags & RVHF_NOTARGETCHANGE)) Target = Target.Master; //Then target the vehicle the turret is attached to.
				Return True;
			}
		}
		Return False;
	}
	
	Enum FindCorpseFlags
	{
		FNCF_RAISABLEONLY	= 1 << 0, //Only look for corpses that can be resurrected.
		FNCF_NOSIZECHECK	= 1 << 1, //Ignore the MaxCorpseRadius and MaxCorpseHeight properties.
		FNCF_STOPFORVILES	= 1 << 2, //Abort the check if a friendly Archvile-type NPC is in the search radius. This is handled here to not have to run another iterator just for the Vile search.
	}
	
	//Find the corpse nearest to the actor.
	Actor FindNearestCorpse (Int Flags = FNCF_RAISABLEONLY|FNCF_STOPFORVILES)
	{
		Array <Actor> NearbyCorpses;
		Double NearestDistance = INT.MAX;
		
		BlockThingsIterator CorpseSearch = BlockThingsIterator.Create (Self,1024);
		
		While (CorpseSearch.Next())
		{
			Actor Mobj = CorpseSearch.Thing;
			
			//Skip this actor if it's invalid or yourself.
			If (!Mobj || Mobj == Self) Continue;

			//Don't crush anything if a friendly necromancer is nearby.
			If (Flags & FNCF_STOPFORVILES && !IsDead(Mobj) && IsNecromancer(Mobj) && !IsActorHostile (Mobj) && CheckSight (Mobj)) Return Null;
			
			//Skip this actor if it's already your corpse target, is alive, is already crushed, is not a dead corpse, or cannot be targeted.
			If (Mobj == CorpseTarget || !IsDead (Mobj) || Mobj.bDontGib || Mobj.bDontCorpse || !CanBeTargeted (Self, Mobj)) Continue;
			
			If (!Mobj.bIsMonster && !Mobj.Player) Continue; //Ignore destroyed props.
			
			If (Flags & FNCF_RAISABLEONLY && !Mobj.CanRaise()) Continue; //Cannot even be resurrected.
			
			If (Mobj.Pos.Z > Mobj.FloorZ) Continue; //Corpse is off the ground. Like if it's falling.
			
			If (!(Flags & FNCF_NOSIZECHECK) && Mobj.Radius > MaxCorpseRadius || Mobj.Height > MaxCorpseHeight) Continue; //Actor is too big.
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the corpse is even visible.
			
			NearbyCorpses.Push(Mobj); //Add it to the list.
		}
		
		Return GetClosestActor (NearbyCorpses,Self.Pos);
	}
	
	//=====|Other functions|=====\\
	//Used to make vehicles able to run over and grind corpses like crushers.
	Void KAI_CrushCorpses (Double RadiusMultiplier = 1.75)
	{
		BlockThingsIterator Crusher = BlockThingsIterator.Create (Self);
		Actor Mobj;
		
		While (Crusher.Next())
		{
			Mobj = Crusher.Thing;
			If (!Mobj) Continue; //No actor to crush.
			//This runs before the bDontGib check, so that vehicles can remove corpse targets if they were already crushed.
			If (Mobj == CorpseTarget) CorpseTarget = Null; //If the corpse you crushed was one you were targeting already, then remove the pointer to it.
			If (!IsDead (Mobj)) Continue; //Actor isn't dead already.
			If (Mobj.bDontGib) Continue; //Has already been crushed.
			If (Mobj.Pos.Z > Mobj.FloorZ) Continue; //Corpse is off the ground. Like if it's falling.
			If (Mobj.Default.bFloat) Continue; //Don't crush floating corpses, particularly recently killed Lost Souls, which end up producing floating gibs.
			If (Mobj.Radius > MaxCorpseRadius || Mobj.Height > MaxCorpseHeight) Continue; //Actor is too big.
			If (Distance3DSquared (Mobj) > ((Radius*2)*RadiusMultiplier) * ((Radius*2)*RadiusMultiplier)) Continue;
			
			Mobj.Grind (False); //Crush corpse, but not items.
		}
	}
}