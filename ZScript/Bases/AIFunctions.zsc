//$GZDB_SKIP
//AI functions shared by all NPC types.
Extend Class KAI_Actor
{
	//=====|Range checks|=====\\
	Enum KAIRangeCheck
	{
		CMR_NOHITFRIEND	= 1 << 0, //The function should not run the native shit autoaimed P_HitFriend() check. Only useful for KAI_CheckMissileRange.
		CMR_3DDISTANCE	= 1 << 1, //The range check should use Distance3D instead of Distance2D.
	}
	
	//Returns true if the caller is in melee range of the other actor. Basically a rip of P_CheckMeleeRange().
	//PLAYTESt: Technically this isn't tested yet, however it's a direct rip of the native code. So it should already work.
	Bool KAI_CheckMeleeRange (Actor Other, Double Range = -1, Int Flags = 0)
	{
		Double Dist;
		
		If (!Target || CurSector.Flags & Sector.SECF_NOATTACK)
			Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other));
		If (Range < 0) Range = MeleeRange;
		
		If (Dist >= Range + Target.Radius)
			Return False;
		
		If (Target == Goal)
			Return True;
		
		If (!bNoVerticalMeleeRange)
		{
			If (Target.Pos.Z > Pos.Z+Height) Return False;
			If (Pos.Z+Height < Target.Pos.Z) Return False;
		}
		
		If (IsFriend (Other))
			Return False;
		
		If (!CheckSight (Target))
			Return False;
		
		Return True;
	}
	
	//The function is more or less the same as its' native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	Bool KAI_CheckMissileRange (Actor Other, Int Flags = 0)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		If (!(Flags & CMR_NOHITFRIEND) && bFriendly && HitFriend ()) Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other)) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (bMissileMore) Dist *= 0.5;
		If (bMissileEvenMore) Dist *= 0.125;
		Dist *= AggressionMultiplier;
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
	}
	
	//=====|Sight and locomotion|=====\\
	Enum KAILookFlags
	{
		KAIL_CHASETARGET = 1 << 0, //If the actor already has a target. Then go to the specified see state. For when the internal A_LookEx() doesn't do it itself.
		KAIL_NOTEMPSTAND = 1 << 1, //Should the actor not temporarily stay still if friendly (Not begin moving due to player fire) between A_LookEx() calls ?
	}
	
	//Generic wrapper for A_LookEx shared by all actors.
	//Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label: These properties are all directly transferred to A_LookEx, so  they work the same as in that function.
	//ExtraFlags: The extra flags that modify KAI_Look's behavior. Look above for available flags.
	Void KAI_Look (Int Flags = 0, Double MinSeeDist = 0, Double MaxSeeDist = 0, Double MaxHearDist = 0, Double FOV = 0, StateLabel Label = Null, Int ExtraFlags = 0)
	{
		//HACK: This shit is probably a super hacky way to just get actors that are already targeting an actor in their Spawn state to actually attack it.
		If (ExtraFlags & KAIL_CHASETARGET && Target)
		{
			If (Label)
				SetStateLabel (Label); //Go to specified state.
			Else
				SetState (SeeState); //Go to default See state.
		}
		Bool Stand = bStandStill;
		If (!(ExtraFlags & KAIL_NOTEMPSTAND))
		{
			Stand = bStandStill;
			bStandStill = True;
		}
		A_LookEx (Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label);
		If (!(ExtraFlags & KAIL_NOTEMPSTAND)) bStandStill = Stand;
	}
	
	Double LastTurnDir;
	Int TurnCount; //Keeps track of how many turns in a row an actor calling KAI_MoveTowards with CHF_NORANDOMTURN should make.
	//Makes the actor move towards the specified actor.
	//IDEA: Since I may just end up having this as a wholesale replacement. Maybe I should also implement support for patrol points, CANTLEAVEFLOORPIC, and CHF_FASTCHASE ?
	//FIXME: There's some flickering between different sprite angles, try fixing it.
	//CREDIT: Written by Custodian. Modified and expanded by me (inkoalawetrust).
	//Other: The actor to move to.
	//DetourFactor: How long the actor is allowed to move in a direction after hitting an obstacle, before heading straight for the target again.
	//AngleLimit: How much the actor can turn per detour. Used to not have it snap back 180 or anything like that.
	//ChaseFlags: What flags from A_Chase should the function use ? Supports CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	void KAI_MoveTowards (Vector3 TargetPos, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (ChaseFlags & CHF_DONTMOVE) Return;
		
		double LastAngle = angle;
		double NextAngle = LastAngle;
		
		//MoveCount is greater than 0 when avoiding an obstacle
		if (MoveCount)
		{
			MoveCount--;
		}
		else
		{
			lastturndir = 0;
			//move directly towards Other
			if (!(ChaseFlags & CHF_NORANDOMTURN)) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		}
		
		//When CHF_NORANDOMTURN is on. The actor can take a set amount of turns before no longer turning to face its' target.
		If (ChaseFlags & CHF_NORANDOMTURN && --TurnCount > 0) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		
		//absolute position of next movement
		vector2 NextPos = Vec2Angle(speed, NextAngle);
		bool moved = TryMove(NextPos, 0, false);
 
		//if I hit an obstacle while avoiding another, try moving straight towards Other
		if (!moved && MoveCount)
		{
			MoveCount = Int(random(16,32)*DetourFactor);
			NextAngle = GetAngleToPos(TargetPos,AngleLimit);
			NextPos = Vec2Angle(speed, NextAngle);
			moved = TryMove(NextPos, 0, false);
		}
		
		//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
		If (!moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
		{
			Switch (AngleLimit)
			{
				Case 20:
					TurnCount = Random (2,4);
					Break;
				Case 10:
					TurnCount = Random (3,6);
					Break;
				Case 5:
					TurnCount = Random (8,12);
					Break;
				Default:
					Break;
			}
		}
		
		//test movement angles until I find one that works, avoid that obstacle for MoveCount tics
		if (!moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
		{
			MoveCount = Int(random(16,32) * DetourFactor);
 
			//try moving the same relative direction as last time
			if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
			
			//find viable movement direction
			for (double i = 1; i < 6; i++)
			{
				NextAngle = LastAngle + (i * 48 * lastturndir);
				NextPos = Vec2Angle(speed, NextAngle);
				moved = TryMove(NextPos, 0, false);
				if (moved) break;
 
				lastTurnDir *= -1.0;
 
				NextAngle = LastAngle + (i * 48 * lastturndir);
				NextPos = Vec2Angle(speed, NextAngle);
				moved = TryMove(NextPos, 0, false);
				if (moved) break;
			}
		}
 
		//face movement direction
		If (!(ChaseFlags & CHF_NODIRECTIONTURN)) angle = Normalize180(NextAngle);
		
		/*If (!(Flags & MTFF_NOANGLESNAP)) Broken attempt at fixing the sprite flickering issue https://streamable.com/7y2uv2
		{
			Angle = GetNearestCardinalAngle (True),AngleTo (Players[ConsolePlayer].Camera));
		}*/
	}
	
	//Moves the caller AWAY from another actor.
	//Other: The actor to move away from.
	//Attempts: How many positions to try per next position picked.
	//RunRad: How big the moves from one retreat position to another can be.
	//StepThreshold: How many steps the actor is allowed to take before having to find a new position to move away to.
	Void KAI_MoveAway (Actor Other, Int Attempts = 32, Double RunRad = 128, Int StepThreshold = 32, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (!Other) Return;
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= StepThreshold && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{a_log ("moving away");
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{a_log ("removing movepos and finding new one");
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		//If there is no position to next move to, this is where the real magic happens.
		Actor SightTarget = Spawn ("KAI_Tracer",Pos);
		
		//Find a position to run to.
		//HACK: ZScript can't use Vector3 arrays. Because the only thing more dysfunctional than my code is the ZScript VM itself.
		//Nothing better than triple the amount of needed array accesses to slow an already expensive function down even more.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Vector3 CurPos;
		
		For (Int I = 0; I <= Attempts; I++)
		{
			CurPos = Vec3Offset (FRandom(RunRad,-RunRad),FRandom(RunRad,-RunRad),0);
			CurPos.Z = GetZAt (CurPos.X,CurPos.Y,0,GZF_ABSOLUTEPOS)+16;
			Xs.Push (CurPos.X); Ys.Push (CurPos.Y); Zs.Push (CurPos.Z); //Epic GZDoom fail.
		}
		
		For (Int I = Attempts-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			SightTarget.SetXYZ (CurPos);
			//If it's out of bounds, not visible, or can't be walked to. We can't run away there. So remove that potential position.
			If (!Level.IsPointInLevel (CurPos) || !CheckSight(SightTarget,SF_IGNOREVISIBILITY) || !IsPosReachable (CurPos))
			{//actor mo = spawn ("gibbedmarineextra",curpos); mo.bnogravity = true;//Epic fail 
				Xs.Delete (I); Ys.Delete(I); Zs.Delete(I);
			}//else {actor mo = spawn ("candlestick",curpos); mo.bnogravity = true;} //EPIC WIN !!!!!!!!!!!!
		}
		//=========================
		
		//Filter out the distances until the furthest one is found.
		Double FurthestDistance;
		Vector3 FurthestPos;
		For (Int I = Xs.Size()-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			Double CurrentDistance = Level.Vec3Diff (Other.Pos,CurPos).LengthSquared();
			If (FurthestDistance < CurrentDistance)
			{
				FurthestDistance = CurrentDistance;
				FurthestPos = CurPos;
			}
		}
		
		NextMovePos = FurthestPos; //We have finally found the random valid position furthest from the other actor.
		
		SightTarget.Destroy();
		//========================================================
	}
	
	//BUG: For some reason the function will sometimes return positions that are behind drops too tall for the caller as valid. I have no fucking idea why.
	//Checks if the straight line between the callers' position and the specified position can be walked up to.
	//TargetPos: The position to check if it's walkable.
	/*DistCutoff: The amount of map units to trim off the distance between the callers' pos and TargetPos. Useful for subtracting the radius of another actor,
	so that if you are checking if a position to another actor can be reached, the check doesn't return false because the actor itself is in the way !*/
	Bool IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0)
	{
		Vector3 OldPos = Pos;
		Bool Interp = bDontInterpolate;
		Vector2 Path = Level.Vec2Diff( Pos.XY, TargetPos.XY );
		Double Distance = Path.Length()-DistCutoff;
		Double Spacing = Radius*2;
		If (Distance <= 1) Return False;
		Path /= Distance;
		
		bDontInterpolate = True; //No movement interpolation during the test.
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec2Diff (Pos.XY, OldPos.XY).Length() >= Distance) Break; //The check went further than the distance to the target position. Success
			//Else If (Level.Vec2Diff (Pos.XY, TargetPos.XY).Length() <= Radius*2.5) Break; //The caller is with 2.5 radii of the target position. Success
			//Run as many times as it takes between you and your destination.
			FCheckPosition Data;
			If (TryMove (Level.Vec2Offset(OldPos.XY, Path*I), 1, tm:Data))
				{SetZ (GetZAt (Pos.X,Pos.Y,flags:GZF_ABSOLUTEPOS));/* spawn ("candlestick",pos);*/} //Update the actors' Z position. TryMove should do that internally, but it doesn't. GZDoom moment.
			//If one of them fails, then return false.
			Else
			{//a_log ("i can't head here");
				bDontInterpolate = Interp;
				SetOrigin (OldPos,False);
				Return False;
			}
		}//a_log ("valid path");
		bDontInterpolate = Interp;
		SetOrigin (OldPos,False);
		Return True; //No TryMove call returned false.
	}
	
	//=====|Search functions|=====\\
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= -1) Return Null; //Return nothing at negative ranges.
		
		Array <Actor> NearbyEnemies;
		Double NearestDistance = INT.MAX;
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (Distance3DSquared (Mobj) > Range*Range) Continue; //Out of range.
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		Return GetClosestActor (NearbyEnemies,Self.Pos);
	}
	
	//=====|Miscelleneous AI functions|=====\\
	//Checks if the actor is in any of the attack states defined, and if it is, it also returns a pointer to that state.
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//ZScript port of this: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2568-2572
	Bool HandleNativeFright()
	{
		If (Target)
			Return (((!target.player || !((target.player.cheats & CF_FRIGHTENING) || (target.bFrightening))) && !(bFrightened)) || Random2[pr_scaredycat]() < 43);
		
		Return False;
	}
}