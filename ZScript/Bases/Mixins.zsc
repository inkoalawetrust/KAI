//Math functions.
Mixin Class KAI_MathFunctions
{
	//=====|Talking in tongues|=====\\
	//CREDIT: Written Agent_Ash
	//What does this do ? I have no fucking idea, Agent_Ash gave it to me.
	//Initially it was used in the MVP tofix how much the truck slows down based on the mass of the object it hit while ramming.
	//But it might be useful in general, so I moved it in to the KAI library.
	Clearscope Double LinearMap (Double Val, Double O_Min, Double O_Max, Double N_Min, Double N_Max) 
	{
		Return (Val - O_Min) * (N_Max - N_Min) / (O_Max - O_Min) + N_Min;
	}
	
	Enum Vec3RelFlags
	{
		V3R_NOANGLE = 1 << 1, //Do not rotate based on angle.
		V3R_NOPITCH = 1 << 2, //Do not rotate based on pitch.
		V3R_NOROLL	= 1 << 3, //Do not rotate based on roll.
		
		V3R_ANGLEONLY = V3R_NOPITCH|V3R_NOROLL
	}
	
	//Like Vec3Offset, but also rotates the output vector based on the callers' angle.
	Clearscope Vector3 Vec3OffsetRelative (Actor Other, Vector3 Offs, Bool NoPortal = False, Int Flags = 0)
	{
		Double Angle2, Pitch2, Roll2;
		If (!(Flags & V3R_NOANGLE)) Angle2 = Other.Angle;
		If (!(Flags & V3R_NOPITCH)) Pitch2 = Other.Pitch;
		If (!(Flags & V3R_NOROLL)) Roll2 = Other.Roll;
		
		Quat Dir = Quat.FromAngles (Angle2,Pitch2,Roll2);
		Return Level.Vec3Offset (Other.Pos,Dir * Offs,NoPortal);
		//Return Other.Vec3Offset (Offs.X * Cos(Angle) + Offs.Y * Sin (Angle),Offs.X * Sin (Angle) - Offs.Y * Cos (Angle),Offs.Z,NoPortal);
	}
	
	//Is the vector empty ? Not (0,0,0), but completely empty.
	Clearscope Bool IsEmptyVector3 (Vector3 Vec)
	{
		Return (Vec != Vec);
	}
}

//Some miscelleneous generic functions
Mixin Class KAI_UniversalFunctions
{
	Array <Actor> ExpAllyList; //Used to prevent friends of the explosions' source from being harmed.
	
	//Temporarily give NORADIUSDMG to allies, to stop them from being harmed by explosions.
	//Used by exploding projectiles.
	Void MakeAlliesImmuneToExplosion (Double Radius = 256)
	{
		If (Radius <= 0) Return;
		BlockThingsIterator AllyFind = BlockThingsIterator.Create (Self,Radius);
		
		While (AllyFind.Next())
		{
			Actor Ally = AllyFind.Thing;
			//Add friendly living monsters or players to the list. But only ones that aren't already exempt from splash damage.
			If (Ally && Target && Ally != Target && Ally.Health > 0 && !Ally.bNoRadiusDmg)
			{
				If (Target.bFriendly || Target.Player)
				{
					If (!(Target.IsHostile(Ally)) && (Ally.bIsMonster || Ally.Player))
						ExpAllyList.Push (Ally);
				}
				//Unless the shooter is not friendly, in which case only count friendly actors of the same species as allies.
				Else
				{
					If (!(Target.IsHostile(Ally)) && Target.Species && Ally.Species == Target.Species)
						ExpAllyList.Push (Ally);
				}
			}
		}
		
		For (Int I = 0; I < ExpAllyList.Size(); I++)
			ExpAllyList[I].bNoRadiusDmg = True;
	}
	
	Void RemoveAllyExplosionImmunity()
	{
		For (Int I = 0; I < ExpAllyList.Size(); I++)
			ExpAllyList[I].bNoRadiusDmg = False;
		
		ExpAllyList.Clear();
	}
}

//Generic status checks.
Mixin Class KAI_CheckFunctions
{
	Bool CheckActorExists (String ActorClass)
	{
		Class<Actor> Act = ActorClass;
		Return !!Act;
	}
	
	Bool IsDead (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Player ? Other.Player.PlayerState == PST_DEAD : Other.Health <= 0);
	}
	
	Bool IsIndestructible (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.bInvulnerable || Other.bNoDamage/* || (!Other.bShootable)*/);
	}
	
	Bool HasGodMode (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Player && Other.Player.Cheats & (CF_GODMODE | CF_GODMODE2));
	}
	
	Bool IsInanimateObject (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bIsMonster && !Other.Player);
	}
	
	Bool IsCollidable (Actor Other, Actor Caller = Null)
	{
		If (!Other) Return False;
		Return ((Other.bSolid && !Other.bNoBlockmap)
		//The ThruBits check is untested, since nobody uses ThruBits lmao.
		&& !(Caller && Caller.bAllowThruBits && Other.bAllowThruBits && Caller.ThruBits & Other.ThruBits));
	}
	
	Bool IsPatrolling (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Goal || Other.Target Is "PatrolPoint");
	}
	
	Bool IsFlying (Actor Other)
	{
		If (!Other) Return False;
		
		If (!Other.Player && Other.bFloat) // Flying monster.
			Return True;
		Else If (Other.Player) //Flying player
		{
			If (Other.bFly || Other.bFlyCheat || Other.Player.Cheats & CF_NOCLIP2)
				Return True;
		}
		
		Return False;
	}
	
	Bool IsInState (Actor Other, StateLabel CheckFor = "Spawn")
	{
		If (!Other) Return False; 
		Return (Other.InStateSequence(Other.CurState,Other.FindState (CheckFor)));
	}
	
	//Can the other actor be targeted ? If the other actor has NOTARGET, but is already being targeted by the caller, then it returns true.
	Bool CanBeTargeted (Actor Caller, Actor Other)
	{
		If (!Other) Return False;
		If (Other.bNeverTarget) Return False;
		Return (Other == Caller.Target || !Other.bNoTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	//Returns if the calling actor is fast.
	//https://github.com/ZDoom/gzdoom/blob/master/src/playsim/p_mobj.cpp?L4892#L4892-L4897
	Bool IsFast (Actor Other)
	{
		If (Other.bAlwaysFast) Return True;
		If (Other.bNeverFast) Return False;
		Return !!G_SkillPropertyInt (SKILLP_FastMonsters);
	}
}
