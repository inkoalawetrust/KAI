/*KLUDGE: Mixins can't be used by different mods, so this class that contains ALL the mixin code in the KAI library is needed. You need to inherit from this
if you want to make something that's not an NPC, but can still use the mixin code the library includes.*/
Class KAI_MixinActor : Actor Abstract
{
	Mixin KAI_UniversalFunctions;
	Mixin KAI_CheckFunctions;
}

Class KAI_Actor : Actor Abstract
{
	Default
	{
		//Properties
		//These are the default player pawns' dimensions, and also my old Smart Marines' dimensions by extension.
		Radius 16;
		Height 56;
		CameraHeight 48; //I think that's about eye level ?
		Mass 100; //Generally, I (inkoalawetrust) basically measure ZDooms' mass units as 1 unit being 1 kilogram.
		Speed 8;
		FriendlySeeBlocks 48; //4096 map units, longer than the default of 1280 map units.
		MaxTargetRange 8196; //Maximum range the actor can attack enemies from.
		Obituary "%o managed to be killed by an abstract class, congratulations %o, we are all very proud of you. Or maybe a modder forgot to define a custom obituary.";
		
		//Flags
		Monster; //Of course.
		+AvoidHazards; //Obviously this is on by default for an intelligent NPC base. However, from what I've seen in the code and playtested, this flag doesn't actually do anything on its' own.
		+SeeFriendlyMonsters; //Hostile KAI NPCs can see friendly monsters by default.
		+FloorClip;
	}
	
	Mixin KAI_CheckFunctions; //Of course all KAI NPCs have access to the library's check functions.
	
	//=====|Virtual functions|=====\\
	//NOTE: The code on these virtuals is basically just the default. Different base classes will likely add on this base code or replace it entirely.
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay ();
		UserVariableDefaults(); //User variables cannot be handled in BeginPlay().
	}
	
	/*Allows actors to define the defaults for their own user variables. This is better than the //$UserDefaultValue editor key,
	because it allows default user variable values to be set for actors that are spawned in-game as well, not just ones placed in UDB*/
	Virtual Void UserVariableDefaults(){}
	
	//TODO: Maybe have this check for SECF_NOATTACK sectors ? Or not, since it would trigger vehicles to run away from enemies in them.
	//Used by the chase functions of each NPC type to check for all the different methods each actor has to attack.
	Virtual Bool CanAttack()
	{
		If ((MissileState || MeleeState) && !IsDead(Self)) Return True; //Actors just check if they have an attack state and are alive by default. More or less stock ZDoom.
		Return False;
	}
}

//TODO: Optimize the fast tracer code by storing the tracers in an array and moving them, instead of spawning new ones every tick.
//IDEA: Make a custom ripping system, where the ripper rips once per actor. Simplifying the damage process, and make it easier to make LOF checks for rippers.
//NOTE: This code is kinda mostly made for bullets and other such projectiles, hence the bullet tracer-like code and deflection system. But can be used for fireballs and the likes just fine !
//The base projectile for KAI actors, it's not necessary to really use this. But it does have some advantages:
//It's based on FastProjectile, so it can properly move both with fast and slow velocities.
/*It's got a toggleable custom trail system. The default trail spawn code for FastProjectile works for actors faster than normal projectiles.
But begins breaking up with truly fast projectiles, this custom trail code doesn't. You can reenable the stock FastProjectile trails.*/
//It has a deflection function, which makes the projectile deflect like a bullet.
//It has code that allows you to change the visual pitch of the projectile based on its' actual pitch. Similar to what KAI_BaseTurret allows for on the vehicle base.
//Has a virtual that is called for each trail spawned, with a pointer to the trail.
Class KAI_BaseProjectile : FastProjectile
{
	Default
	{
		MissileHeight 8;
		KAI_BaseProjectile.TrailLineSpacing 2;
		Projectile;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		If (Target) Species = Target.Species; //MAYDO: Have this rely on a flag ? It's kinda here because of the MVP where it was ripped from.
	}
	
	Override Void Tick ()
	{
		Vector3 OldPos = Pos;
		Super.Tick();
		
		//bMissile is removed when a projectile explodes.
		If (!bMissile || IsFrozen()) Return;
		
		If (TrailDelay)
		{
			TrailDelay--;
			Return;
		}
		
		If (bNoTrailLine) //Used stock FastProjectile trail. Simple as.
		{
			Effect();
			Return;
		}
		
		//CREDIT: Boondorl wrote the original code that draws a line of tracers between the current and previous position.
		If (TrailActor)
		{
			Vector3 Path = Level.Vec3Diff( Pos, OldPos );
			Double Distance = Path.Length();
			If (Distance <= 1) Return;
			Path /= Distance;
			
			Double CurScaleX = ScaleAmountX;
			Double CurScaleY = ScaleAmountY;
			Double CurAlpha = FadeAmount;
			
			For( Double I = InitialTrailsSkipped; I < Distance; I += TrailLineSpacing )
			{
				If (MaxTrails != 0 && MaxTrails <= I) Break; //Too many trail actors.
				
				Let Trail = Spawn(TrailActor,level.Vec3Offset(pos, Path*i));
				If (Trail)
				{
					TrailSpawn (Trail); //Return spawned trail.
					//If it's time to begin scaling and fading the trail.
					If (I >= TrailFadeAndScaleStart)
					{
						Trail.Scale.X += CurScaleX;
						Trail.Scale.Y += CurScaleY;
						Trail.Alpha += CurAlpha;
						CurScaleX += ScaleAmountX;
						CurScaleY += ScaleAmountY;
						CurAlpha += FadeAmount;
					}
				}
			}
		}
	}
	
	//Mostly ripped from the native FastProjectile, with some changes and additions.
	Override Void Effect()
	{
		If (!bNoTrailLine) Return;
		Class<Actor> Trail = TrailActor;
		Actor Act;
		If (Trail != Null)
		{
			Double HitZ = Pos.Z - 8;

			If (HitZ < FloorZ)
			{
				HitZ = FloorZ;
			}
			// Do not clip this offset to the floor.
			HitZ += MissileHeight;
			
			Act = Spawn (Trail, (Pos.XY, HitZ), ALLOW_REPLACE);
			If (Act != Null)
			{
				TrailSpawn (Act);
				If (bGetOwner && Target != Null)
					Act.Target = Target;
				Else
					Act.Target = Self;
				
				//Act.Angle = Angle; //These are handled by TrailSpawn().
				//Act.Pitch = Pitch;
			}
		}
	}
	
	//Returns each trail actor spawned, allowing you to perform per-trail modifications.
	Virtual Void TrailSpawn (Actor Trail)
	{
		If (!Trail) Return;
		
		Trail.Master = Self;
		Trail.Angle = Angle;
		Trail.Pitch = Pitch;
		//Pass trail properties. Only really works for the dedicated trail class in particular, so it only runs if the trail is KAI_Tracer or a child class.
		If (Trail Is "KAI_Tracer")
		{
			KAI_Tracer(Trail).SpawnOffsets.X = SpawnOffsetX;
			KAI_Tracer(Trail).SpawnOffsets.Y = SpawnOffsetY;
			KAI_Tracer(Trail).SpawnOffsets.Z = SpawnOffsetZ;
		}
	}
	
	//DOCUMENT: The actual parameters on this function. Here in the code, and on the GitHub wiki I'll set up once the KAI is tidy and finished enough.
	Bool DeflectProjectile (Actor Victim, Int DeflectChance, Double DamageReductionFactor, Double SlowDownFactor = 0,
	Vector2 RandomAngle = (0,0), Vector2 RandomPitch = (0,0), Double Volume = 1, Double Attenuation = 0.9)
	{
		If (Random (0,255) < DeflectChance) Return False; //Fission mailed.
		
		Int Damage = GetMissileDamage(7,1); //Get your damage, be it a static number or a damage function.
		Victim.DamageMobj (Self,Target,Int(Damage*DamageReductionFactor),DamageType); //Harm the caller even when deflected.
		Angle -= 180; //Turn around.
		Vel *= -1; //Opposite day today
		Speed *= SlowDownFactor; //Slow down by a set amount. Can just be randomized in the parameters instead.
		//Randomize the direction you'll fly to.
		Angle += FRandom (RandomAngle.X,RandomAngle.Y);
		Pitch += FRandom (RandomPitch.X,RandomPitch.Y);
		Vel3DFromAngle (Speed,Angle,Pitch);
		
		//Spark effect.
		//MAYDO: Make spark effect customizable ? Potentially through an OnDeflection() virtual.
		TextureID NullTex;
		For (Int I = 0; I < 24; I++)
		{
			A_SpawnParticleEx (
			"yellow",
			NullTex,
			STYLE_Add,
			lifetime:23,
			size:3,
			xoff:FRandom (6,-6),
			yoff:FRandom (6,-6),
			zoff:FRandom (6,-6),
			velx:FRandom (1,-1),
			vely:FRandom (1,-1),
			velz:FRandom (1,3),
			accelz: FRandom (-0.1,-0.25)
			);
		}
		Victim.A_StartSound (BounceSound,flags:CHANF_OVERLAP,Volume,Attenuation); //Ricochet sound, uses the BounceSound property, naturally.
		DontCollide = Victim; //You should no longer collide with the actor you just deflected, to avoid getting stuck inside it.
		
		Return True;
	}
	
	//Has different values than UpdateTurretElevation().
	Int UpdateProjectileElevation (Int FaceDown, Int FaceDown2, Int FaceStraight, Int FaceUp, Int FaceUp2)
	{
		If (Pitch >= 70)
			Return FaceDown2;
		Else If (Pitch >= 30 && Pitch < 70)
			Return FaceDown;
		Else If (Pitch < 30 && Pitch > -30)
			Return FaceStraight;
		Else If (Pitch <= -30 && Pitch > -70)
			Return FaceUp;
		Else If (Pitch <= -70)
			Return FaceUp2;
		
		Return FaceStraight;
	}
	
	Override Int SpecialMissileHit (Actor Victim)
	{
		If (!Victim || Victim && Victim == DontCollide) Return 1;
		//MAYDO: This makes the now bad assumption that projectile is for vehicles only- actually no. I think this may be fine ?
		//If not, maybe replace this with a dynamic array of specific actors the projectile should't collide with.
		If (Target && Target Is "KAI_BaseTurret" && Victim && Victim == Target.Master) Return 1; //If fired from a turret, ignore the vehicle it's attached on.
		
		Return -1;
	}
	
	Actor DontCollide; //Stores an actor that will be ignored by SpecialMissileHit, so deflected projectiles don't deflect dozens of times when bouncing off. Sorse spaghetti has nothing on Doom spaghet.
	
	Mixin KAI_UniversalFunctions;
	Mixin KAI_CheckFunctions;
	Private Int ProjectileFlags;
	FlagDef NoTrailLine : ProjectileFlags, 0; //The projectile uses the normal FastProjectile trail spawning code.
	Class <Actor> TrailActor;
	Property TrailActor : TrailActor;
	
	Int TrailDelay, MaxTrails, InitialTrailsSkipped, TrailFadeAndScaleStart;
	Property TrailDelay : TrailDelay;
	Property MaxTrails : MaxTrails;
	Property InitialTrailsSkipped : InitialTrailsSkipped;
	Property TrailFadeAndScaleStart : TrailFadeAndScaleStart;
	
	Double TrailLineSpacing;
	Property TrailLineSpacing : TrailLineSpacing;
	
	Double ScaleAmountX, ScaleAmountY, FadeAmount;
	Property ScaleAmountX : ScaleAmountX;
	Property ScaleAmountY : ScaleAmountY;
	Property FadeAmount : FadeAmount;
	
	Double SpawnOffsetX, SpawnOffsetY, SpawnOffsetZ;
	Property SpawnOffsetX : SpawnOffsetX;
	Property SpawnOffsetY : SpawnOffsetY;
	Property SpawnOffsetZ : SpawnOffsetZ;
}

//A generic tracer effect particle.
//MAYDO: A flag to enable state progression ? Maybe not. The entire point is for this actor to be as "light" as ZScript allows.
Class KAI_Tracer : Actor
{
	Default {RenderStyle "Add"; Scale 0.5; ReactionTime 1; +NoBlockmap; +NoInteraction;}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		SetOrigin (KAI_Math.Vec3OffsetRelative (Self,SpawnOffsets),False);
	}
	Override Void Tick()
	{
		If (IsFrozen()) Return;
		//Super.Tick(); //Not needed.
		If (GetAge() >= ReactionTime)
			Destroy();
	}
	
	Vector3 SpawnOffsets;
}