//$GZDB_SKIP
//Code that's not directly related to KAI NPCs goes here. Largely stuff like mixins and the math container class.
Class KAI_Math
{
	//=====|Talking in tongues|=====\\
	//What does this do ? I have no fucking idea, Agent_Ash gave it to me to fix how much the truck slows down based on the mass of the object it hit while ramming.
	//DOCUMENT: I need someone who passed elementary school math to document what the fuck this does.
	Clearscope Static Double LinearMap (Double Val, Double O_Min, Double O_Max, Double N_Min, Double N_Max) 
	{
		Return (Val - O_Min) * (N_Max - N_Min) / (O_Max - O_Min) + N_Min;
	}
	//==============================\\
	
	Enum Vec3RelFlags
	{
		V3R_NOANGLE = 1 << 1, //Do not rotate based on angle.
		V3R_NOPITCH = 1 << 2, //Do not rotate based on pitch.
		V3R_NOROLL	= 1 << 3, //Do not rotate based on roll.
		
		V3R_ANGLEONLY = V3R_NOPITCH|V3R_NOROLL
	}
	
	//Like Vec3Offset, but also rotates the output vector based on the callers' angle.
	//Other: The actor to offset from.
	//Offs: The vector3 offsets to use.
	//NoPortal: Should the function account for static portals or not ?
	//Flags: See above for list of flags.
	Clearscope Static Vector3 Vec3OffsetRelative (Actor Other, Vector3 Offs, Bool NoPortal = False, Int Flags = 0)
	{
		Double Angle, Pitch, Roll;
		If (!(Flags & V3R_NOANGLE)) Angle = Other.Angle;
		If (!(Flags & V3R_NOPITCH)) Pitch = Other.Pitch;
		If (!(Flags & V3R_NOROLL)) Roll = Other.Roll;
		
		Quat Dir = Quat.FromAngles (Angle,Pitch,Roll);
		Return Level.Vec3Offset (Other.Pos,Dir * Offs,NoPortal);
	}
	
	//Is the vector empty ? Not (0,0,0), but completely empty.
	Clearscope Static Bool IsEmptyVector3 (Vector3 Vec)
	{
		Return (Vec != Vec);
	}
}

Mixin Class KAI_UniversalFunctions
{
	Array <Actor> TempAllyList; //Used to prevent friends of the explosions' source from being harmed.
	
	//Temporarily give NORADIUSDMG to allies, to stop them from being harmed by explosions.
	//Used by exploding projectiles.
	Void MakeAlliesImmuneToExplosion (Double Radius = 256)
	{
		If (Radius <= 0) Return;
		BlockThingsIterator AllyFind = BlockThingsIterator.Create (Self,Radius);
		
		While (AllyFind.Next())
		{
			Actor Ally = AllyFind.Thing;
			//Add friendly living monsters or players to the list. But only ones that aren't already exempt from splash damage.
			If (Ally && Target && Ally != Target && Ally.Health > 0 && !Ally.bNoRadiusDmg)
			{
				If (Target.bFriendly || Target.Player)
				{
					If (!(Target.IsHostile(Ally)) && (Ally.bIsMonster || Ally.Player))
						TempAllyList.Push (Ally);
				}
				//Unless the shooter is not friendly, in which case only count friendly actors of the same species as allies.
				Else
				{
					If (!(Target.IsHostile(Ally)) && Target.Species && Ally.Species == Target.Species)
						TempAllyList.Push (Ally);
				}
			}
		}
		
		For (Int I = 0; I < TempAllyList.Size(); I++)
			TempAllyList[I].bNoRadiusDmg = True;
	}
	
	Void RemoveAllyExplosionImmunity()
	{
		For (Int I = 0; I < TempAllyList.Size(); I++)
			TempAllyList[I].bNoRadiusDmg = False;
		
		TempAllyList.Clear();
	}
}

//Generic status checks.
Mixin Class KAI_CheckFunctions
{
	Bool CheckActorExists (String ActorClass)
	{
		Class<Actor> Act = ActorClass;
		Return !!Act;
	}
	
	Bool IsDead (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Player ? Other.Player.PlayerState == PST_DEAD : Other.Health <= 0);
	}
	
	Bool IsIndestructible (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.bInvulnerable || Other.bNoDamage/* || (!Other.bShootable)*/);
	}
	
	Bool HasGodMode (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Player && Other.Player.Cheats & (CF_GODMODE | CF_GODMODE2));
	}
	
	Bool IsInanimateObject (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bIsMonster && !Other.Player);
	}
	
	Bool IsCollidable (Actor Other, Actor Caller = Null)
	{
		If (!Other) Return False;
		Return ((Other.bSolid && !Other.bNoBlockmap)
		//PLAYTEST: The ThruBits check is untested, since nobody uses ThruBits lmao.
		&& !(Caller && Caller.bAllowThruBits && Other.bAllowThruBits && Caller.ThruBits & Other.ThruBits));
	}
	
	Bool IsPatrolling (Actor Other)
	{
		If (!Other) Return False;
		Return (Other.Goal || Other.Target Is "PatrolPoint");
	}
	
	Bool IsFlying (Actor Other)
	{
		If (!Other) Return False;
		
		If (!Other.Player && Other.bFloat) // Flying monster.
			Return True;
		Else If (Other.Player) //Flying player
		{
			If (Other.bFly || Other.bFlyCheat || Other.Player.Cheats & CF_NOCLIP2)
				Return True;
		}
		
		Return False;
	}
	
	Bool IsInState (Actor Other, StateLabel CheckFor = "Spawn")
	{
		If (!Other) Return False; 
		Return (Other.InStateSequence(Other.CurState,Other.FindState (CheckFor)));
	}
	
	//Can the other actor be targeted ? If the other actor has NOTARGET, but is already being targeted by the caller, then it returns true.
	Bool CanBeTargeted (Actor Caller, Actor Other)
	{
		If (!Other) Return False;
		If (Other.bNeverTarget) Return False;
		Return (Other == Caller.Target || !Other.bNoTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	//Returns if the calling actor is fast.
	//https://github.com/ZDoom/gzdoom/blob/master/src/playsim/p_mobj.cpp?L4892#L4892-L4897
	Bool IsFast (Actor Other)
	{
		If (Other.bAlwaysFast) Return True;
		If (Other.bNeverFast) Return False;
		Return !!G_SkillPropertyInt (SKILLP_FastMonsters);
	}
	
	//Returns true if the specified actor can resurrect corpses like an Archvile does.
	Bool IsNecromancer (Actor Other)
	{
		If (!Other) Return False;
		
		If (Other.FindState ("Heal")) Return True; //I checked several mods with Archvile-type monsters. And all of them have a Heal state. Making this the only universal way to check for them.
		
		Return False;
	}
	
	//TODO: Add a flag that is needed to explicitly enable this special logic ?
	//Is the other actor hostile? This is special hostile check logic for NPCs hostile to the player.
	//The native IsHostile() just leaves the return up to the infighting settings.
	//But this function checks if the other fellow enemy NPC is targetting the vehicle or one of its' turrets, or an actor of the same species.
	//TODO: Actually, wouldn't it be better to make this into an IsTargettingAllies() function, with an optional flag to enable the check for enemy NPCs ?
	Bool KAIVehicle_IsHostile (Actor Caller, Actor Other)
	{
		If (!Caller || !Other) Return False;
		
		If (Caller.bFriendly) //It's as shrimple as that.
			Return Caller.IsHostile (Other);
		//Enemy vehicles are the reason this function exists.
		//They generally don't attack other non-enemy military NPCs. But they will do so if those NPCs are targetting them, or another enemy military NPC.
		Else
		{
			//Non-friendly actors always hate players and their allies.
			If (Other.Player || Other.bFriendly)
				Return True;
			
			//Don't consider own species hostile.
			//If (Caller.bNoInfightSpecies && Caller.Species == Other.Species)
			//	{console.printf ("that's my own species");Return False;} //DEBUG
			
			//Is the other actor targetting you or your turret ?
			If (Other.Target && (Other.Target == Caller || Other.Target == KAI_BaseVehicle(Caller).Turret))
				Return True;
			
			//Is the other actor targetting an actor with the same species as you ? Then they are an enemy as far as you are concerned.
			If (Other.Target && (Caller.bNoInfightSpecies && Caller.Species == Other.Target.Species))
				Return True;
		}
		
		Return False;
	}
}