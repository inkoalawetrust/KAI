//$GZDB_SKIP
//AI functions shared by all NPC types.
Extend Class KAI_Actor
{
	//=====|Range checks|=====\\
	Enum KAIRangeCheck
	{
		CMR_NOHITFRIEND	= 1 << 0, //The function should not run the native shit autoaimed P_HitFriend() check. Only useful for KAI_CheckMissileRange.
		CMR_3DDISTANCE	= 1 << 1, //The range check should use Distance3D instead of Distance2D.
		CMR_INVERTDIST	= 1 << 2, //Invert the missile attack chance with distance. Making the NPC MORE likely to attack the further the target is.
		CMR_IGNOREDIST	= 1 << 3, //Ignore the distance check attack chance code for missile attacks entirely.
	}
	
	//Returns true if the caller is in melee range of the other actor. Basically a rip of P_CheckMeleeRange().
	Bool KAI_CheckMeleeRange (Actor Other, Double Range = -1, Int Flags = 0)
	{
		Double Dist;
		
		If (!Target || CurSector.Flags & Sector.SECF_NOATTACK)
			Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other));
		If (Range < 0) Range = MeleeRange;
		
		If (Dist >= Range + Target.Radius)
			Return False;
		
		If (Target == Goal)
			Return True;
		
		If (!bNoVerticalMeleeRange)
		{
			If (Target.Pos.Z > Pos.Z+Height) Return False;
			If (Pos.Z+Height < Target.Pos.Z) Return False;
		}
		
		If (IsFriend (Other))
			Return False;
		
		If (!CheckSight (Target))
			Return False;
		
		Return True;
	}
	
	//The function is more or less the same as its' native counterpart, give or take the syntax and code comments, and it being slower by being non-native.
	Bool KAI_CheckMissileRange (Actor Other, Int Flags = 0)
	{
		Double Dist;
		
		If (CurSector.Flags & Sector.SECF_NOATTACK) Return False;
		
		If (!Other || !CheckSight (Other, SF_SEEPASTBLOCKEVERYTHING)) Return False;
		
		If (bJustHit)
		{
			bJustHit = False;
			
			If (!bFriendly) Return True;
			If (IsDead(Other)) Return False;
			If (!IsFriend(Other)) Return True;
			
			If (Other.Player)
				Return (Random2[PR_Defect]() > 128);
			Else
				Return !(Other.bJustHit && Random2[PR_Defect]() > 128);
		}
		
		If (ReactionTime) Return False;
		
		If (IsFriend (Other)) Return False;
		
		If (!(Flags & CMR_NOHITFRIEND) && bFriendly && HitFriend ()) Return False;
		
		Dist = (!(Flags & CMR_3DDISTANCE) ? Distance2D (Other) : Distance3D (Other)) - 64;
		
		If (!MeleeState)
			Dist -= 128;
		
		If (MaxTargetRange > 0 && Dist > MaxTargetRange) Return False;
		
		If (MeleeState && Dist < MeleeThreshold) Return False;
		
		If (Flags & CMR_IGNOREDIST) //Skip stupid distance formula.
			Return True;
		
		Bool Invert = (Flags & CMR_INVERTDIST);
		If (bMissileMore) Dist *= !Invert ? 0.5 : 1.5;
		If (bMissileEvenMore) Dist *= !Invert ? 0.125 : 2.5;
		Dist *= AggressionMultiplier; //If CMF_INVERTDIST is on, keep in mind that the behavior of the AggressionMultiplier is also effectively inverted !
		
		Int MMC = Int(MinMissileChance * G_SkillPropertyFloat(SKILLP_Aggressiveness));
		If (!Invert)
			Return Random2[PR_CheckMissileRange]() >= Min(Int(Dist), MMC);
		Else
			Return Random2[PR_CheckMissileRange]() <= Max(Int(Dist), MMC);
	}
	
	//=====|Sight and locomotion|=====\\
	Enum KAILookFlags
	{
		KAIL_CHASETARGET = 1 << 0, //If the actor already has a target. Then go to the specified see state. For when the internal A_LookEx() doesn't do it itself.
		KAIL_NOTEMPSTAND = 1 << 1, //Should the actor not temporarily stay still if friendly (Not begin moving due to player fire) between A_LookEx() calls ?
	}
	
	//Generic wrapper for A_LookEx shared by all actors.
	//Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label: These properties are all directly transferred to A_LookEx, so  they work the same as in that function.
	//ExtraFlags: The extra flags that modify KAI_Look's behavior. Look above for available flags.
	Void KAI_Look (Int Flags = 0, Double MinSeeDist = 0, Double MaxSeeDist = 0, Double MaxHearDist = 0, Double FOV = 0, StateLabel Label = Null, Int ExtraFlags = 0)
	{
		//HACK: This shit is probably a super hacky way to just get actors that are already targeting an actor in their Spawn state to actually attack it.
		If (!(Flags & LOF_NOJUMP) && ExtraFlags & KAIL_CHASETARGET && Target)
		{
			If (Label)
				SetStateLabel (Label); //Go to specified state.
			Else
				SetState (SeeState); //Go to default See state.
		}
		Bool Stand = bStandStill;
		If (!(ExtraFlags & KAIL_NOTEMPSTAND))
		{
			Stand = bStandStill;
			bStandStill = True;
		}
		A_LookEx (Flags, MinSeeDist, MaxSeeDist, MaxHearDist, FOV, Label);
		If (!(ExtraFlags & KAIL_NOTEMPSTAND)) bStandStill = Stand;
	}
	
	Enum KAIMoveTowardsFlags
	{
		KMT_CHASEGOAL = 1 << 0, //If the caller has a goal pointer, and the bChaseGoal flag on. It will follow the goal instead of the TargetPos.
		KMT_ZIGZAG	  = 1 << 1, //Move around with more A_Chase-esque movement (Like zigzagging), instead of only moving in a straight line.
		KMT_NOLINEUSE = 1 << 2, //Disable the function being able to make the monster use crossed over lines at all, in case you want your own code for that.
	}
	
	Double LastTurnDir;
	Int TurnCount; //Keeps track of how many turns in a row an actor calling KAI_MoveTowards with CHF_NORANDOMTURN should make.
	Vector3 ZigZagPos;
	
	//Makes the actor move towards the specified actor.
	//TODO: Add a check for if a vehicles' turret would collide with the next move. And probably find a way to call it recursively for turrets on turrets.
	//CREDIT: Written by Custodian. Modified and expanded by me (inkoalawetrust).
	//TargetPos: The position to move to.
	//DetourFactor: How long the actor is allowed to move in a direction after hitting an obstacle, before heading straight for the target again.
	//AngleLimit: How much the actor can turn per detour. Used to not have it snap back 180 or anything like that.
	//ChaseFlags: What flags from A_Chase should the function use ? Supports CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	//Flags: The functions' own flags, see above for a list of flags.
	Void KAI_MoveTowards (Vector3 TargetPos, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (ChaseFlags & CHF_DONTMOVE || KAI_Math.IsEmptyVector3 (TargetPos)) Return;
		
		//Basically does what P_NewChaseDir() does to handle Thing_SetGoal's "Don't chase target" flag: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L943-946
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
			TargetPos = Goal.Pos;
		
		//Handle making the NPC zig zag in a manner similar to KAI_MoveAway.
		If (Flags & KMT_ZIGZAG)
		{
			If (NewPosStepCount <= 64 && Level.Vec3Diff (Pos,ZigZagPos).Length() >= MeleeRange)
			{
				If (!KAI_Math.IsEmptyVector3 (ZigZagPos))
					TargetPos = ZigZagPos;
				NewPosStepCount++;
			}
			Else
			{
				ZigZagPos = FindRandomMovePos (TargetPos,16,256,FRMP_CLOSEST);
				NewPosStepCount = 0;
			}
		}
		Else
			ZigZagPos = (Double.NaN,Double.NaN,Double.NaN);
		
		//The function works with the CANTLEAVEFLOORPIC flag as well.
		TextureID OldFloor = FloorPic;
		
		double LastAngle = angle;
		double NextAngle = LastAngle;
		Bool IsVehicle = (Self Is "KAI_BaseVehicle");
		
		//MoveCount is greater than 0 when avoiding an obstacle
		if (MoveCount)
		{
			MoveCount--;
		}
		else
		{
			lastturndir = 0;
			//move directly towards Other
			if (!(ChaseFlags & CHF_NORANDOMTURN)) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
		}
		
		//When CHF_NORANDOMTURN is on. The actor can take a set amount of turns before no longer turning to face its' target.
		If (ChaseFlags & CHF_NORANDOMTURN && --TurnCount > 0) NextAngle = GetAngleToPos(TargetPos,AngleLimit);
				
		//absolute position of next movement
		vector2 NextPos = Vec2Angle(speed, NextAngle, True);
		If (IsVehicle) //Vehicle push and crush handling.
		{
			Let Vehicle = KAI_BaseVehicle(Self);
			Array <Actor> Pushovers;
			KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
			KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
		}
		
		//If (!(Flags & KMT_NOLINEUSE)) {a_log ("lemme try opening this door");CheckMonsterUseSpecials ();}
		FCheckPosition Move;
		Move.FromPMove = True; //Move anyways if there's an actor within your hitbox already.
		bool moved = TryMove(NextPos, 0, false, Move);
		
		//if I hit an obstacle while avoiding another, try moving straight towards Other
		if (!moved && MoveCount || bCantLeaveFloorPic && FloorPic != OldFloor)
		{
			If (!(Flags & KMT_NOLINEUSE)) KAI_NPCUseLines();
			MoveCount = Int(random(16,32)*DetourFactor);
			NextAngle = GetAngleToPos(TargetPos,AngleLimit);
			NextPos = Vec2Angle(speed, NextAngle, True);
			If (IsVehicle) //Vehicle push and crush handling.
			{
				Let Vehicle = KAI_BaseVehicle(Self);
				Array <Actor> Pushovers;
				KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
				KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
			}
			moved = TryMove(NextPos, 0, false, Move);
		}
		
		//If there's a limit to how much the actor can turn per step. Decide an amount of turns for CHF_NORANDOMTURN to make after it hits an obstacle.
		If (!moved && AngleLimit > 0 && ChaseFlags & CHF_NORANDOMTURN)
		{
			Switch (AngleLimit)
			{
				Case 20:
					TurnCount = Random (2,4);
					Break;
				Case 10:
					TurnCount = Random (3,6);
					Break;
				Case 5:
					TurnCount = Random (8,12);
					Break;
				Default:
					Break;
			}
		}
		
		//test movement angles until I find one that works, avoid that obstacle for MoveCount tics
		if (!moved && !(ChaseFlags & CHF_STOPIFBLOCKED))
		{
			MoveCount = Int(random(16,32) * DetourFactor);
 
			//try moving the same relative direction as last time
			if (lastturndir == 0) lastTurnDir = random(0,1) ? 1.0 : -1.0;
			
			//find viable movement direction
			for (double i = 1; i < 6; i++)
			{
				NextAngle = LastAngle + (i * 48 * lastturndir);
				NextPos = Vec2Angle(speed, NextAngle, True);
				If (IsVehicle) //Vehicle push and crush handling.
				{
					Let Vehicle = KAI_BaseVehicle(Self);
					Array <Actor> Pushovers;
					KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
					KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
				}
				moved = TryMove(NextPos, 0, false, Move);
				if (moved) break;
				
				lastTurnDir *= -1.0;
				
				NextAngle = LastAngle + (i * 48 * lastturndir);
				NextPos = Vec2Angle(speed, NextAngle, True);
				If (IsVehicle) //Vehicle push and crush handling.
				{
					Let Vehicle = KAI_BaseVehicle(Self);
					Array <Actor> Pushovers;
					KAI_BaseVehicle(Self).KAI_VehiclePushActors(Self, NextPos,Vehicle.MaxPushRadius,Vehicle.MaxPushHeight,Pushovers);
					KAI_BaseVehicle(Self).KAI_VehicleCrushObstacles (Pushovers,Vehicle.VehicleCrushDamage);
				}
				moved = TryMove(NextPos, 0, false, Move);
				if (moved) break;
			}
		}
		
		//face movement direction
		If (!(ChaseFlags & CHF_NODIRECTIONTURN)) angle = Normalize180(NextAngle);
	}
	
	//Makes the NPC wander around aimlessly.
	//Attempts: How many positions to try per next position picked.
	//MoveRad: The radius around which to find a viable position to move to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move to.
	//The rest are KAI_MoveTowards' parameters.
	Void KAI_Wander (Int Attempts = 24, Double MoveRad = 256, Int MaxSteps = 72, Double DetourFactor = 0.5, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		Int Friend = KAI_GetFriendPlayer();
		If (!OnWander()) //Virtual callback
			Return;
		
		//Friendly monsters follow the player they work for by default.
		If (bFriendly && !bDontFollowPlayers && PlayerInGame[Friend] && Players[Friend].Mo)
		{
			KAI_MoveTowards (Players[Friend].Mo.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		NextMovePos = FindRandomMovePos (Pos,Attempts,MoveRad,FRMP_RANDOM); //Pick a random position to go to.
	}
	
	Enum MoveAwayFlags
	{
		KMA_STRAIGHT	= 1 << 0, //Move in a straight line away from the Other actor, like A_Chase, instead of using the further random position around you.
		KMA_USECORNERS	= 1 << 1, //When running away, trying walking to places on your sides, where the Other actor has no line of sight to you.
	}
	
	//Moves the caller AWAY from another actor.
	//Other: The actor to move away from.
	//Attempts: How many positions to try per next position picked.
	//RunRad: The radius around which to find a viable position to run away to.
	//MaxSteps: How many steps the actor is allowed to take before having to find a new position to move away to.
	//The rest are KAI_MoveTowards' parameters.
	//KMAFlags: The flags unique to KAI_MoveAway.
	//TargPos: If this is set to a non-NaN value. This position vector will be used directly instead of the Other pointer.
	Void KAI_MoveAway (Actor Other, Int Attempts = 32, Double RunRad = 128, Int MaxSteps = 32, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0,
	Int KMAFlags = 0, Vector3 TargPos = (Double.NaN, Double.NaN, Double.NaN))
	{
		If (!Other && KAI_Math.IsEmptyVector3(TargPos)) {If (KAI_DebugPrintMessages)console.printf ("KAI_MoveAway(): Premptively stopping execution");Return;}
		
		Vector3 RunPos = Other ? Other.Pos : TargPos;
		
		//Got a goal to head to, no time to get spooked.
		If (Flags & KMT_CHASEGOAL && Goal && bChaseGoal)
		{
			KAI_MoveTowards (Goal.Pos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			Return;
		}
		
		//If there's already a prior position to move to, begin moving there instead. Until within melee range of that position.
		If (!KAI_Math.IsEmptyVector3 (NextMovePos) && NewPosStepCount <= MaxSteps && Level.Vec3Diff (Pos,NextMovePos).Length() >= MeleeRange)
		{
			KAI_MoveTowards (NextMovePos, DetourFactor, AngleLimit, ChaseFlags, Flags);
			NewPosStepCount++;
			Return;
		}
		//Once the position is reached, empty the the NextMovePos vector;
		Else
		{
			NextMovePos = (Double.NaN,Double.NaN,Double.NaN);
			NewPosStepCount = 0;
		}
		
		Actor SightTarget = Other;
		If (!SightTarget) SightTarget = Spawn ("KAI_DebugPoint",TargPos); //Spawn a debug point to check the sight of at TargPos instead for running from a coordinate.
		
		//Try to run behind corners.
		If (KMAFlags & KMA_USECORNERS && CheckSight(SightTarget,SF_IGNOREWATERBOUNDARY))
		{
			Vector3 RealPos = Pos;
			Double CheckLength = (Radius*2)*8; //Check 8 diameters to your right or left for a corner.
			
			//Check your left.
			Vector3 LeftPos = Vec3Angle (CheckLength,Angle-90);
			SetOrigin (LeftPos,False);
			//I think CheckSight() is literally cheaper than IsPosReachable() so run these checks first.
			Bool LeftSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
			SetOrigin (RealPos, False);
			If (!LeftSight && IsPosReachable (LeftPos,ignoreactors:True))
			{
				NextMovePos = LeftPos; //Move to the left.
				Return;
			}
			
			//Check your right.
			Vector3 RightPos = Vec3Angle (CheckLength,Angle+90);
			SetOrigin (RightPos,False);
			Bool RightSight = SightTarget.CheckSight (Self,SF_IGNOREWATERBOUNDARY);
			SetOrigin (RealPos, False);
			If (!RightSight && IsPosReachable (RightPos,ignoreactors:True))
			{
				NextMovePos = RightPos; //Move to the right.
				Return;
			}
		}
		If (!(KMAFlags & KMA_STRAIGHT))
			NextMovePos = FindRandomMovePos (RunPos,Attempts,RunRad,FRMP_FURTHEST); //Pick whichever position is the furthest from Runpos.
		Else
		{
			NextMovePos.XY = Vec2Angle (RunRad,GetAngleToPos(RunPos)-180);
			NextMovePos.Z = GetZAt (NextMovePos.X,NextMovePos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
		}
	}
	
	Enum FindMovePosFilters
	{
		FRMP_FURTHEST	= 1 << 0, //Pick the furthest of all available positions to move to. This is the default.
		FRMP_CLOSEST	= 1 << 1, //Pick the closest of all available positions to move to.
		FRMP_RANDOM		= 1 << 2, //Pick a random position out of all the viable ones found.
	}
	
	//Find a random position that the caller can actually move to.
	//RelativeTo: Which position should the distance checks be performed to ? Needed for the Furthest and Closest filters.
	//Attempts: How many random positions should be produced ? The more you add, the more heavy the function becomes. (Obviously)
	//CheckRad: What is the maximum radius around which random positions can be produced ?
	//Filter: What position are we looking for exactly ? Look above for a list of filters. These are NOT to be used as flags that stack !
	Vector3 FindRandomMovePos (Vector3 RelativeTo = (Double.NaN, Double.NaN, Double.NaN), Int Attempts = 32, Double CheckRad = 128, Int Filter = FRMP_FURTHEST)
	{
		If (Filter == 0) Filter = FRMP_FURTHEST;
		
		//HACK: ZScript can't use Vector3 arrays. Because the only thing more dysfunctional than my code is the ZScript VM itself.
		//Nothing better than triple the amount of needed array accesses to slow an already expensive function down even more.
		Array <Double> Xs; Array <Double> Ys; Array <Double> Zs;
		Vector3 CurPos; //The position we are currently checking. Reconstructed from the above arrays.
		
		For (Int I = 0; I <= Attempts; I++)
		{
			CurPos = Vec3Offset (FRandom(CheckRad,-CheckRad),FRandom(CheckRad,-CheckRad),0);
			CurPos.Z = GetZAt (CurPos.X,CurPos.Y,0,GZF_ABSOLUTEPOS)+(Height/2);
			Xs.Push (CurPos.X); Ys.Push (CurPos.Y); Zs.Push (CurPos.Z); //Epic GZDoom fail.
		}
		
		Actor SightTarget = Spawn ("KAI_Tracer",Pos);
		For (Int I = Attempts-1; I >= 0; I--)
		{
			CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
			SightTarget.SetXYZ (CurPos); //Move the target to the pos for the visibility check.
			//If it's out of bounds, not visible, or can't be walked to. We can't go there. So remove that potential position.
			If (!Level.IsPointInLevel (CurPos) || !CheckSight(SightTarget,SF_IGNOREVISIBILITY) || !IsPosReachable (CurPos))
			{//actor mo = spawn ("gibbedmarineextra",curpos); mo.bnogravity = true;//Epic fail 
				Xs.Delete (I); Ys.Delete(I); Zs.Delete(I);
			}//else {actor mo = spawn ("candlestick",curpos); mo.bnogravity = true;} //EPIC WIN !!!!!!!!!!!!
		}
		SightTarget.Destroy();
		
		//No valid positions found, return null.
		If (Xs.Size() == 0)
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Return a random position, this filter is checked first to at least make wandering NPCs a bit cheaper.
		If (Filter == FRMP_RANDOM)
		{
			Int RNGesus = Random (0,Xs.Size()-1);
			Return (Xs[RNGesus],Ys[RNGesus],Zs[RNGesus]);
		}
		//Return the furthest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_FURTHEST)
		{
			Double FurthestDistance;
			Vector3 FurthestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (FurthestDistance < CurrentDistance)
				{
					FurthestDistance = CurrentDistance;
					FurthestPos = CurPos;
				}
			}
			Return FurthestPos;
		}
		//Return the closest random position.
		Else If (!KAI_Math.IsEmptyVector3(RelativeTo) && Filter == FRMP_CLOSEST)
		{
			Double NearestDistance = INT.MAX;
			Vector3 NearestPos;
			For (Int I = Xs.Size()-1; I >= 0; I--)
			{
				CurPos = (Xs[I],Ys[I],Zs[I]); //Reconstruct each vector.
				Double CurrentDistance = Level.Vec3Diff (RelativeTo,CurPos).LengthSquared();
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestPos = CurPos;
				}
			}
			Return NearestPos;
		}
		
		Return (Double.NaN, Double.NaN, Double.NaN); //Return null position if all the above failed.
	}
	
	//BUG: For some reason the function will sometimes return positions that are behind drops too tall for the caller as valid. I have no fucking idea why.
	//BUG: It's not portal aware, because of course it isn't ! DESPITE LITERALLY CHECKING BY *ACTUALLY* MOVING THE CALLER IN A STRAIGHT LINE !
	//BUG: God, why is a function that literally walks the caller forward so fucking hard.
	//NOTE: A potential fix might be making Vec3Offset absolute, it should at least fix portals, since it fixed movement through them for KAI_MoveTowards.
	//Checks if the straight line between the callers' position and the specified position can be walked up to.
	//TargetPos: The position to check if it's walkable.
	/*DistCutoff: The amount of map units to trim off the distance between the callers' pos and TargetPos. Useful for subtracting the radius of another actor,
	so that if you are checking if a position to another actor can be reached, the check doesn't return false because the actor itself is in the way !*/
	//Spacing: The spacing of the move checks. Default is 0, which means that the spacing is the diameter of the callers' hitbox.
	//IgnoreActors: Makes' the check ignore blocking actors entirely.
	Bool IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False)
	{
		Vector3 OldPos = Pos;
		Bool Interp = bDontInterpolate;
		Bool ThruActs = bThruActors;
		Vector2 Path = Level.Vec2Diff( Pos.XY, TargetPos.XY );
		Double Distance = Path.Length()-DistCutoff;
		If (Spacing == 0)
			Spacing = Radius*2;
		If (Distance <= 1) Return False;
		Path /= Distance;
		
		bDontInterpolate = True; //No movement interpolation during the test.
		If (IgnoreActors) bThruActors = True;
		For (Int I = 0; I < Distance; I += Spacing)
		{
			If (Level.Vec2Diff (Pos.XY, OldPos.XY).Length() >= Distance) Break; //The check went further than the distance to the target position. Success
			//Run as many times as it takes between you and your destination.
			FCheckPosition Data;
			If (TryMove (Level.Vec2Offset(OldPos.XY, Path*I), 1, tm:Data))
			{
				SetZ (GetZAt (Pos.X,Pos.Y,flags:GZF_ABSOLUTEPOS)); //Update the actors' Z position. TryMove should do that internally, but it doesn't. GZDoom moment.
				//actor debug = spawn ("kai_debugpoint",(Level.Vec2Offset(OldPos.XY, Path*I),Pos.Z));
				//debug.scale *= 0.5;
			}
			//If one of them fails, then return false.
			Else
			{//If (KAI_DebugPrintMessages)console.printf ("i can't walk to %d %d %d",targetpos);
				bDontInterpolate = Interp;
				bThruActors = ThruActs;
				SetOrigin (OldPos,False);
				Return False;
			}
		}
		bDontInterpolate = Interp;
		bThruActors = ThruActs;
		SetOrigin (OldPos,False);
		Return True; //No TryMove call returned false.
	}
	
	//=====|Search functions|=====\\
	//Does exactly what it says, finds the nearest enemy that can be targeted and is visible, and returns a pointer to it.
	Actor FindNearestEnemy (Double Range = 256)
	{
		If (Range <= 0) Return Null;
		
		Array <Actor> NearbyEnemies;
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || Mobj.Health >= 10000 || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			NearbyEnemies.Push(Mobj); //Add it to the list.
		}
		Return GetClosestActor (NearbyEnemies,Self.Pos,Range);
	}
	
	//Find a height position (From the three FAF_ positions) at which the NPC can aim at the specified actor with a clear line of sight.
	//Useful for making NPCs aim at a different part of an actor when attacking.
	Int GetFAFAimPos (Actor Other, Vector3 Offset = (0,0,0))
	{
		If (!Other) Return FAF_MIDDLE; //No need to update anything.
		Vector3 OldPos = Other.Pos;
		Vector3 AimDir;
		Vector3 Start = Level.Vec3Offset (Pos,Offset);
		
		//Let's see if the middle of the other actor is hittable first.
		Let Check = New ("KAI_BasicSightCheck"); //Should be cheaper than CheckSight(), probably...
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height/2));
		AimDir = Vec3To (Other);
		Check.Shooter = Self;
		Check.SightTarget = Other;
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_MIDDLE;
		}
		
		//If we are this far that should mean the middle isn't visible, aim for the top.
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height));
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_TOP;
		}
		
		//If that too failed, aim for the bottom.
		Other.SetXYZ (Other.Pos.PlusZ(Other.Height));
		AimDir = Vec3To (Other);
		Check.Trace (Start,CurSector,AimDir,MaxTargetRange,0);
		Other.SetXYZ(OldPos);
		
		If (Check.GoodLOS)
		{
			Check.Destroy();
			Return FAF_BOTTOM;
		}
		
		//All else failed, aim to the middle again and return false;
		Return FAF_MIDDLE;
	}
	//=====|Miscelleneous AI functions|=====\\
	//A crude replica of the clusterfuck that makes monsters natively able to use push and use lines.
	Bool KAI_NPCUseLines()
	{
		If (bNoTrigger || !BlockingLine) Return False;
       
        If (BlockingLine.Special)
        {
            If (bCanUseWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Use);
                Return True;
            }
            Else If (bCanPushWalls)
            {
                BlockingLine.Activate (Self,0,SPAC_Push);
                Return True;
            }
        }
        
        Return False;
	}
	
	Int KAI_GetFriendPlayer()
	{
		If (FriendPlayer != 0)
			Return FriendPlayer-1;
		Else
		{
			If (!Multiplayer)
				Return 0;
		}
		
		Return 0;
	}
	
	//Checks if the actor is in any of the attack states defined, and if it is, it also returns a pointer to that state.
	State IsInAttackState()
	{
		State FoundState = State (Null);
		
		If (InStateSequence (CurState,MissileState) || InStateSequence (CurState,MeleeState)) Return CurState;
		
		//Loop through available states.
		For (Int I = AttackStates.Size()-1; 0 <= I; I--)
		{
			//The state in the array matches the current state we are in.
			If (InStateSequence (CurState,AttackStates[I]))
			{
				FoundState = AttackStates[I];
				Break;
			}
		}
		
		Return FoundState;
	}
	
	//ZScript port of this: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2568-2572
	Bool HandleNativeFright()
	{
		If (Target)
			Return (((!target.player || !((target.player.cheats & CF_FRIGHTENING) || (target.bFrightening))) && !(bFrightened)) || Random2[pr_scaredycat]() < 43);
		
		Return False;
	}
	
	//=====|A_Chase exports (Building blocks for custom chase functions)|=====\\
	//The checks A_Chase runs before it begins running the chase code.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2325-2376
	Void KAI_Chase_PreChecks (Int Flags = 0)
	{
		If (bInConversation || bInChase) Return;
		
		//bInChase = True;
		
		//PLAYTEST: I haven't checked if stealth monsters work with the exported A_Chase code.
		If (bStealth)
			VisDir -1;
		
		If (ReactionTime)
			ReactionTime--;
		
		//The latter half hasn't been implemented to mainline GZDoom yet, the bMInvisible flag that is.
		If (Target && (Target.bInvisible/* || Target.bMInvisible*/) && Target != Goal)
			Target = Null;
		
		If (Threshold)
		{
			If (!Target || IsDead (Target))
				Threshold = 0;
			Else
				Threshold--;
		}
		
		//Cocaine mode
		If (Flags && CHF_NIGHTMAREFAST && G_SkillPropertyInt (SKILLP_FASTMONSTERS))
		{
			If (Tics > 3)
			{
				Tics -= Tics/2;
				If (Tics < 3)
					Tics = 3;
			}
		}
		
		If (Target && Target != Goal && (IsDead(Target) || !IsActorHostile(Target)))
			Target = Null;
	}
	
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2401-2432
	//CREDIT: This section of the code was written by Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L74-L106
	//PLAYTEST: No idea if this actually works, or how to test it. It should, it's not only a direct rip, but it was written by someone who knows what they are actually doing (Not inkoalawetrust).
	//Makes friendly monsters using KAI chase functions chase their targets attack- basically just what A_Chase does.
	//It does return true if a new target was found though.
	Bool KAI_Chase_FriendsAttackPlayerEnemies (Int Flags)
	{
		// [RH] Friendly monsters will consider chasing whoever hurts a player if they
		// don't already have a target.
		if (bFRIENDLY && target == null)
		{
			PlayerInfo player;

			if (FriendPlayer != 0)
			{
				player = Players[FriendPlayer - 1];
			}
			else
			{
				int i;
				if (!multiplayer)
				{
					i = 0;
				}
				else for (i = random[newchasedirr](0,255) & (MAXPLAYERS-1); !PlayerInGame[i]; i = (i+1) & (MAXPLAYERS-1))
				{
				}

				player = Players[i];
			}
			if (player.attacker && !IsDead (Player.Attacker) && player.attacker.bSHOOTABLE && random[newchasedirr](0,255) < 80)
			{
				if (!player.attacker.bFRIENDLY ||
					deathmatch && FriendPlayer != 0 && player.attacker.FriendPlayer != 0 &&
					FriendPlayer != player.attacker.FriendPlayer)
				{
					target = player.attacker;
					Return True; //Found a player enemy to attack.
				}
			}
		}
		
		Return False;
	}
	
	//Makes the actor change targets if the current one is unavailable. If no target is found either hang out in the current state or go back to idling.
	//Ported from here: https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2433-2467
	Bool KAI_Chase_Retarget (Int Flags, Bool FriendliesIdle = False)
	{
		If (!Target || !Target.bShootable)
		{
			If (Target && Target.bNonShootable)
			{
				LastEnemy = Target;
				Threshold = 0;
			}
			If (LookForPlayers (True) && Target != Goal)
				Return True;
			If (!Target)
			{
				If (Flags & CHF_DONTIDLE || bFriendly && !FriendliesIdle)
				{
					If (!Target)
					{
						If (!(Flags & CHF_DONTMOVE))
							KAI_Wander();
					}
				}
				Else
					SetIdle(); //Sleepy time
			}
		}
		Return False;
	}
	
	//This is an important one for every chase function of every NPC type. It handles going to patrol points and then heading to the next point in the route.
	//WaitState: The statelabel for the actor to go to if it finds a delayed patrol point. If none is specified, it calls SetState().
	//The rest of the parameters here are what is passed to KAI_MoveTowards
	//This function returns 2 booleans. The first returns true if the goal was changed to the next one in the route, and the second returns true if the actor moved to the goal.
	Bool, Bool KAI_Chase_PatrolHandling (StateLabel WaitState = Null, Double DetourFactor = 1.0, Double AngleLimit = 10, Int ChaseFlags = 0, Int Flags = 0)
	{
		If (Target == Goal || bChaseGoal && Goal != Null)
		{
			If (KAI_CheckMeleeRange(Goal))
			{
				//Credit: Kizoky: https://github.com/Kizoky/CPPtoZScript/blob/main/A_Chase.txt#L161-L212
				// reached the goal
				ActorIterator iterator = Level.CreateActorIterator(goal.args[0], "PatrolPoint");
				ActorIterator specit = Level.CreateActorIterator(goal.tid, "PatrolSpecial");
				Actor spec;

				// Execute the specials of any PatrolSpecials with the same TID
				// as the goal.
				while ( (spec = specit.Next()) )
				{
					level.ExecuteSpecial(
						spec.special, self, null, false,
						spec.args [0], spec.args [1], spec.args [2], spec.args [3], spec.args [4]
					);
				}

				double lastgoalang = goal.angle;
				int delay;
				actor newgoal = iterator.Next ();
				if (newgoal != null && goal == target)
				{
					delay = newgoal.args[1];
					reactiontime = delay * TICRATE + level.maptime;
				}
				else
				{
					delay = 0;
					reactiontime = Default.reactiontime;
					angle = lastgoalang;
				}
				if (target == goal) target = null;
				bJUSTATTACKED = true;
				if (newgoal != null && delay != 0)
				{
					bINCOMBAT = true;
					If (!WaitState)
						SetIdle();
					Else
						SetStateLabel (WaitState);
				}
				bINCHASE = false;
				goal = newgoal;
				return True, False;
			}
			//We have a goal, go to it.
			If (Goal && Goal == Target)
			{
				KAI_MoveTowards (Goal.Pos,DetourFactor,AngleLimit,ChaseFlags,Flags);
				Return False, True;
			}
		}
		Return False, False;
	}
	
	//Handles the playing of the active sound.
	Bool KAI_Chase_HandleActiveSound (Int Flags, Int Frequency = 3)
	{
		if (!(Flags & CHF_NOPLAYACTIVE) && random[pr_chase](0,255) < Frequency)
		{
			PlayActiveSound();
			Return True;
		}
		Return False;
	}
	
	//This handles Hexens' player boss strafing.
	//https://sourcegraph.com/github.com/ZDoom/gzdoom/-/blob/src/playsim/p_enemy.cpp?L2537-2566
	//StrafeTarget: The actor to strafe relative to, normally this will be the target of course.
	//Flags: the A_Chase flags to pass and check for.
	//ForceStrafe: Force the caller to do a strafe.
	//StrafeRange: How close the StrafeTarget has to be to decide to strafe, default is CLASS_BOSS_STRAFE_RANGE.
	Void KAI_Chase_HandleStrafing (Actor StrafeTarget, Int Flags, Bool ForceStrafe = False, Double StrafeRange = 64*10)
	{
		If (!StrafeTarget) Return; //Nothing to dodge.
		
		If (ForceStrafe || Flags & CHF_FASTCHASE && !(Flags & CHF_DONTMOVE))
		{
			If (ForceStrafe) FastChaseStrafeCount = 0;
			If (FastChaseStrafeCount > 0)
				FastChaseStrafeCount--; //Decrement strafe delay.
			Else
			{
				FastChaseStrafeCount = 0;
				Vel.X = Vel.Y = 0;
				If ((ForceStrafe || Random[pr_chase](0,255) < 100) && Distance2D(StrafeTarget) < StrafeRange)
				{
					Double Ang = AngleTo (StrafeTarget);
					If (Random[pr_chase](0,255) < 128) Ang += 90;
					Else Ang -= 90;
					VelFromAngle (13,Ang);
					FastChaseStrafeCount = 3;
				}
			}
		}
	}
}

//This struct stores parameters passed to KAI_MoveTowards/Away. Used as a simple way to pass all params the functions support from another function that calls them.
//Without cluttering up the other function.
Struct MoveToParams
{
	//KAI_MoveTowards parameters
	Vector3 TargetPos; //The position to actually move to.
	Double DetourFactor; //A multiplier for how many steps the caller can take around an obstacle before heading straight to the TargetPos again.
	Double AngleLimit; //How much the caller can turn to face their TargetPos per step.
	Int ChaseFlags; //The A_Chase flags KAI_MoveTowards supports, which are CHF_DONTMOVE, CHF_NODIRECTIONTURN, CHF_NORANDOMTURN, and CHF_STOPIFBLOCKED.
	Int Flags; //The functions' own flags, check the KAIMoveTowardsFlags enum for a list of them and what they do.
	
	//KAI_MoveAway parameters, the function also supports KAI_MoveTowards parameters, as it's effectivelly a wrapper for it.
	Actor Other; //The actor to run away from.
	Int Attempts; //How many potential points to run to should the function generate. The more you generate the more performance heavy it becomes !
	Double RunRad; //The radius around which additional points should be generated.
	Int StepThreshold; //How many steps trying to move to the current retreat position can the caller take before it picks a new location to run to.
}